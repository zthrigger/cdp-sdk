#[allow(unused_imports)]
use progenitor_middleware_client::{encode_path, ClientHooks, OperationInfo, RequestBuilderExt};
#[allow(unused_imports)]
pub use progenitor_middleware_client::{ByteStream, ClientInfo, Error, ResponseValue};
/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
    /// Error types.
    pub mod error {
        /// Error from a `TryFrom` or `FromStr` implementation.
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }
        impl ::std::fmt::Debug for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }
        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }
        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }
    ///Contract ABI Specification following Solidity's external JSON interface format.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contract ABI Specification following Solidity's external JSON interface format.",
    ///  "examples": [
    ///    [
    ///      {
    ///        "inputs": [
    ///          {
    ///            "internalType": "address",
    ///            "name": "spender",
    ///            "type": "address"
    ///          },
    ///          {
    ///            "internalType": "uint256",
    ///            "name": "amount",
    ///            "type": "uint256"
    ///          }
    ///        ],
    ///        "name": "approve",
    ///        "outputs": [
    ///          {
    ///            "internalType": "bool",
    ///            "name": null,
    ///            "type": "bool"
    ///          }
    ///        ],
    ///        "stateMutability": "nonpayable",
    ///        "type": "function"
    ///      },
    ///      {
    ///        "anonymous": false,
    ///        "inputs": [
    ///          {
    ///            "indexed": true,
    ///            "internalType": "address",
    ///            "name": "from",
    ///            "type": "address"
    ///          }
    ///        ],
    ///        "name": "Transfer",
    ///        "type": "event"
    ///      },
    ///      {
    ///        "inputs": [
    ///          {
    ///            "internalType": "address",
    ///            "name": "spender",
    ///            "type": "address"
    ///          }
    ///        ],
    ///        "name": "ERC20InvalidSpender",
    ///        "type": "error"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "array",
    ///  "items": {
    ///    "oneOf": [
    ///      {
    ///        "$ref": "#/components/schemas/AbiFunction"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/AbiInput"
    ///      }
    ///    ]
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct Abi(pub ::std::vec::Vec<AbiItem>);
    impl ::std::ops::Deref for Abi {
        type Target = ::std::vec::Vec<AbiItem>;
        fn deref(&self) -> &::std::vec::Vec<AbiItem> {
            &self.0
        }
    }
    impl ::std::convert::From<Abi> for ::std::vec::Vec<AbiItem> {
        fn from(value: Abi) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&Abi> for Abi {
        fn from(value: &Abi) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::vec::Vec<AbiItem>> for Abi {
        fn from(value: ::std::vec::Vec<AbiItem>) -> Self {
            Self(value)
        }
    }
    ///ABI function type for contract functions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "AbiFunction",
    ///  "description": "ABI function type for contract functions.",
    ///  "examples": [
    ///    {
    ///      "inputs": [
    ///        {
    ///          "internalType": "address",
    ///          "name": "owner",
    ///          "type": "address"
    ///        }
    ///      ],
    ///      "name": "balanceOf",
    ///      "outputs": [
    ///        {
    ///          "internalType": "uint256",
    ///          "name": null,
    ///          "type": "uint256"
    ///        }
    ///      ],
    ///      "stateMutability": "view",
    ///      "type": "function"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "inputs",
    ///    "name",
    ///    "outputs",
    ///    "stateMutability",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "constant": {
    ///      "description": "Deprecated. Use pure or view from stateMutability instead.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "gas": {
    ///      "description": "Deprecated. Vyper used to provide gas estimates.",
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "inputs": {
    ///      "description": "The list of ABI parameters used for this function.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "internalType": "address",
    ///            "name": "spender",
    ///            "type": "address"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AbiParameter"
    ///      }
    ///    },
    ///    "name": {
    ///      "description": "The name of the ABI function.",
    ///      "examples": [
    ///        "approve"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "outputs": {
    ///      "description": "The values returned by this function.",
    ///      "examples": [
    ///        {
    ///          "internalType": "bool",
    ///          "name": "",
    ///          "type": "bool"
    ///        }
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AbiParameter"
    ///      }
    ///    },
    ///    "payable": {
    ///      "description": "Deprecated. Use payable or nonpayable from `stateMutability` instead.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "stateMutability": {
    ///      "$ref": "#/components/schemas/AbiStateMutability"
    ///    },
    ///    "type": {
    ///      "description": "The type of the ABI item, must be `function`.",
    ///      "examples": [
    ///        "function"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "function"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AbiFunction {
        ///Deprecated. Use pure or view from stateMutability instead.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub constant: ::std::option::Option<bool>,
        ///Deprecated. Vyper used to provide gas estimates.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub gas: ::std::option::Option<i64>,
        ///The list of ABI parameters used for this function.
        pub inputs: ::std::vec::Vec<AbiParameter>,
        ///The name of the ABI function.
        pub name: ::std::string::String,
        ///The values returned by this function.
        pub outputs: ::std::vec::Vec<AbiParameter>,
        ///Deprecated. Use payable or nonpayable from `stateMutability` instead.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payable: ::std::option::Option<bool>,
        #[serde(rename = "stateMutability")]
        pub state_mutability: AbiStateMutability,
        ///The type of the ABI item, must be `function`.
        #[serde(rename = "type")]
        pub type_: AbiFunctionType,
    }
    impl ::std::convert::From<&AbiFunction> for AbiFunction {
        fn from(value: &AbiFunction) -> Self {
            value.clone()
        }
    }
    impl AbiFunction {
        pub fn builder() -> builder::AbiFunction {
            Default::default()
        }
    }
    ///The type of the ABI item, must be `function`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of the ABI item, must be `function`.",
    ///  "examples": [
    ///    "function"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "function"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AbiFunctionType {
        #[serde(rename = "function")]
        Function,
    }
    impl ::std::convert::From<&Self> for AbiFunctionType {
        fn from(value: &AbiFunctionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AbiFunctionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Function => f.write_str("function"),
            }
        }
    }
    impl ::std::str::FromStr for AbiFunctionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "function" => Ok(Self::Function),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for AbiFunctionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for AbiFunctionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for AbiFunctionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Generic ABI item type encapsulating all other types besides `function`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "AbiInput",
    ///  "description": "Generic ABI item type encapsulating all other types besides `function`.",
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "additionalProperties": {
    ///      "description": "For additional information on the ABI JSON specification, see [the Solidity documentation](https://docs.soliditylang.org/en/latest/abi-spec.html#json).",
    ///      "examples": [
    ///        {
    ///          "inputs": [
    ///            {
    ///              "internalType": "address",
    ///              "name": "spender",
    ///              "type": "address"
    ///            }
    ///          ],
    ///          "name": "ERC20InvalidSpender",
    ///          "type": "error"
    ///        }
    ///      ]
    ///    },
    ///    "type": {
    ///      "description": "The type of the ABI item.",
    ///      "examples": [
    ///        "constructor"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "constructor",
    ///        "error",
    ///        "event",
    ///        "fallback",
    ///        "receive"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AbiInput {
        ///For additional information on the ABI JSON specification, see [the Solidity documentation](https://docs.soliditylang.org/en/latest/abi-spec.html#json).
        #[serde(
            rename = "additionalProperties",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub additional_properties: ::std::option::Option<::serde_json::Value>,
        ///The type of the ABI item.
        #[serde(rename = "type")]
        pub type_: AbiInputType,
    }
    impl ::std::convert::From<&AbiInput> for AbiInput {
        fn from(value: &AbiInput) -> Self {
            value.clone()
        }
    }
    impl AbiInput {
        pub fn builder() -> builder::AbiInput {
            Default::default()
        }
    }
    ///The type of the ABI item.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of the ABI item.",
    ///  "examples": [
    ///    "constructor"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "constructor",
    ///    "error",
    ///    "event",
    ///    "fallback",
    ///    "receive"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AbiInputType {
        #[serde(rename = "constructor")]
        Constructor,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "event")]
        Event,
        #[serde(rename = "fallback")]
        Fallback,
        #[serde(rename = "receive")]
        Receive,
    }
    impl ::std::convert::From<&Self> for AbiInputType {
        fn from(value: &AbiInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AbiInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Constructor => f.write_str("constructor"),
                Self::Error => f.write_str("error"),
                Self::Event => f.write_str("event"),
                Self::Fallback => f.write_str("fallback"),
                Self::Receive => f.write_str("receive"),
            }
        }
    }
    impl ::std::str::FromStr for AbiInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "constructor" => Ok(Self::Constructor),
                "error" => Ok(Self::Error),
                "event" => Ok(Self::Event),
                "fallback" => Ok(Self::Fallback),
                "receive" => Ok(Self::Receive),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for AbiInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for AbiInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for AbiInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`AbiItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AbiFunction"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AbiInput"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum AbiItem {
        Function(AbiFunction),
        Input(AbiInput),
    }
    impl ::std::convert::From<&Self> for AbiItem {
        fn from(value: &AbiItem) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<AbiFunction> for AbiItem {
        fn from(value: AbiFunction) -> Self {
            Self::Function(value)
        }
    }
    impl ::std::convert::From<AbiInput> for AbiItem {
        fn from(value: AbiInput) -> Self {
            Self::Input(value)
        }
    }
    ///Parameter definition for ABI functions, errors, and constructors.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Parameter definition for ABI functions, errors, and constructors.",
    ///  "examples": [
    ///    {
    ///      "internalType": "uint256",
    ///      "name": "tokenId",
    ///      "type": "uint256"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "components": {
    ///      "description": "Used for tuple types.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "name": "x",
    ///            "type": "uint256"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AbiParameter"
    ///      }
    ///    },
    ///    "internalType": {
    ///      "description": "The internal Solidity type used by the compiler.",
    ///      "examples": [
    ///        "uint256"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "The name of the parameter.",
    ///      "examples": [
    ///        "tokenId"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The canonical type of the parameter.",
    ///      "examples": [
    ///        "uint256"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AbiParameter {
        ///Used for tuple types.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub components: ::std::vec::Vec<AbiParameter>,
        ///The internal Solidity type used by the compiler.
        #[serde(
            rename = "internalType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub internal_type: ::std::option::Option<::std::string::String>,
        ///The name of the parameter.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The canonical type of the parameter.
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }
    impl ::std::convert::From<&AbiParameter> for AbiParameter {
        fn from(value: &AbiParameter) -> Self {
            value.clone()
        }
    }
    impl AbiParameter {
        pub fn builder() -> builder::AbiParameter {
            Default::default()
        }
    }
    ///State mutability of a function in Solidity.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "State mutability of a function in Solidity.",
    ///  "examples": [
    ///    "view"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "pure",
    ///    "view",
    ///    "nonpayable",
    ///    "payable"
    ///  ],
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AbiStateMutability {
        #[serde(rename = "pure")]
        Pure,
        #[serde(rename = "view")]
        View,
        #[serde(rename = "nonpayable")]
        Nonpayable,
        #[serde(rename = "payable")]
        Payable,
    }
    impl ::std::convert::From<&Self> for AbiStateMutability {
        fn from(value: &AbiStateMutability) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AbiStateMutability {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pure => f.write_str("pure"),
                Self::View => f.write_str("view"),
                Self::Nonpayable => f.write_str("nonpayable"),
                Self::Payable => f.write_str("payable"),
            }
        }
    }
    impl ::std::str::FromStr for AbiStateMutability {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "pure" => Ok(Self::Pure),
                "view" => Ok(Self::View),
                "nonpayable" => Ok(Self::Nonpayable),
                "payable" => Ok(Self::Payable),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for AbiStateMutability {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for AbiStateMutability {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for AbiStateMutability {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Response containing token addresses that an account has received.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response containing token addresses that an account has received.",
    ///  "type": "object",
    ///  "properties": {
    ///    "accountAddress": {
    ///      "description": "The account address that was queried.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tokenAddresses": {
    ///      "description": "List of token contract addresses that the account has received.",
    ///      "examples": [
    ///        [
    ///          "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    ///          "0x4200000000000000000000000000000000000006",
    ///          "0x0000000000000000000000000000000000000000"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "Token contract address.",
    ///        "type": "string",
    ///        "pattern": "^0x[0-9a-fA-F]{40}$"
    ///      }
    ///    },
    ///    "totalCount": {
    ///      "description": "Total number of unique token addresses discovered.",
    ///      "examples": [
    ///        15
    ///      ],
    ///      "type": "integer",
    ///      "minimum": 0.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountTokenAddressesResponse {
        ///The account address that was queried.
        #[serde(
            rename = "accountAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub account_address: ::std::option::Option<::std::string::String>,
        ///List of token contract addresses that the account has received.
        #[serde(
            rename = "tokenAddresses",
            default,
            skip_serializing_if = "::std::vec::Vec::is_empty"
        )]
        pub token_addresses: ::std::vec::Vec<AccountTokenAddressesResponseTokenAddressesItem>,
        ///Total number of unique token addresses discovered.
        #[serde(
            rename = "totalCount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub total_count: ::std::option::Option<u64>,
    }
    impl ::std::convert::From<&AccountTokenAddressesResponse> for AccountTokenAddressesResponse {
        fn from(value: &AccountTokenAddressesResponse) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for AccountTokenAddressesResponse {
        fn default() -> Self {
            Self {
                account_address: Default::default(),
                token_addresses: Default::default(),
                total_count: Default::default(),
            }
        }
    }
    impl AccountTokenAddressesResponse {
        pub fn builder() -> builder::AccountTokenAddressesResponse {
            Default::default()
        }
    }
    ///Token contract address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Token contract address.",
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct AccountTokenAddressesResponseTokenAddressesItem(::std::string::String);
    impl ::std::ops::Deref for AccountTokenAddressesResponseTokenAddressesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<AccountTokenAddressesResponseTokenAddressesItem>
        for ::std::string::String
    {
        fn from(value: AccountTokenAddressesResponseTokenAddressesItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&AccountTokenAddressesResponseTokenAddressesItem>
        for AccountTokenAddressesResponseTokenAddressesItem
    {
        fn from(value: &AccountTokenAddressesResponseTokenAddressesItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for AccountTokenAddressesResponseTokenAddressesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for AccountTokenAddressesResponseTokenAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for AccountTokenAddressesResponseTokenAddressesItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for AccountTokenAddressesResponseTokenAddressesItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AccountTokenAddressesResponseTokenAddressesItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///Information about how the end user is authenticated.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Information about how the end user is authenticated.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/EmailAuthentication"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SmsAuthentication"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/DeveloperJWTAuthentication"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/OAuth2Authentication"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum AuthenticationMethod {
        EmailAuthentication(EmailAuthentication),
        SmsAuthentication(SmsAuthentication),
        DeveloperJwtAuthentication(DeveloperJwtAuthentication),
        OAuth2Authentication(OAuth2Authentication),
    }
    impl ::std::convert::From<&Self> for AuthenticationMethod {
        fn from(value: &AuthenticationMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<EmailAuthentication> for AuthenticationMethod {
        fn from(value: EmailAuthentication) -> Self {
            Self::EmailAuthentication(value)
        }
    }
    impl ::std::convert::From<SmsAuthentication> for AuthenticationMethod {
        fn from(value: SmsAuthentication) -> Self {
            Self::SmsAuthentication(value)
        }
    }
    impl ::std::convert::From<DeveloperJwtAuthentication> for AuthenticationMethod {
        fn from(value: DeveloperJwtAuthentication) -> Self {
            Self::DeveloperJwtAuthentication(value)
        }
    }
    impl ::std::convert::From<OAuth2Authentication> for AuthenticationMethod {
        fn from(value: OAuth2Authentication) -> Self {
            Self::OAuth2Authentication(value)
        }
    }
    ///The list of valid authentication methods linked to the end user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The list of valid authentication methods linked to the end user.",
    ///  "examples": [
    ///    [
    ///      {
    ///        "email": "user@example.com",
    ///        "type": "email"
    ///      },
    ///      {
    ///        "phoneNumber": "+12055555555",
    ///        "type": "sms"
    ///      },
    ///      {
    ///        "kid": "NjVBRjY5MDlCMUIwNzU4RTA2QzZFMDQ4QzQ2MDAyQjVDNjk1RTM2Qg",
    ///        "sub": "e051beeb-7163-4527-a5b6-35e301529ff2",
    ///        "type": "jwt"
    ///      },
    ///      {
    ///        "email": "test.user@gmail.com",
    ///        "sub": "115346410074741490243",
    ///        "type": "google"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "array",
    ///  "items": {
    ///    "$ref": "#/components/schemas/AuthenticationMethod"
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct AuthenticationMethods(pub ::std::vec::Vec<AuthenticationMethod>);
    impl ::std::ops::Deref for AuthenticationMethods {
        type Target = ::std::vec::Vec<AuthenticationMethod>;
        fn deref(&self) -> &::std::vec::Vec<AuthenticationMethod> {
            &self.0
        }
    }
    impl ::std::convert::From<AuthenticationMethods> for ::std::vec::Vec<AuthenticationMethod> {
        fn from(value: AuthenticationMethods) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&AuthenticationMethods> for AuthenticationMethods {
        fn from(value: &AuthenticationMethods) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::vec::Vec<AuthenticationMethod>> for AuthenticationMethods {
        fn from(value: ::std::vec::Vec<AuthenticationMethod>) -> Self {
            Self(value)
        }
    }
    ///`CommonSwapResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "blockNumber": "17038723",
    ///      "fees": {
    ///        "gasFee": {
    ///          "amount": "1000000000000000000",
    ///          "token": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///        },
    ///        "protocolFee": {
    ///          "amount": "1000000000000000000",
    ///          "token": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///        }
    ///      },
    ///      "fromAmount": "1000000000000000000",
    ///      "fromToken": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
    ///      "issues": {
    ///        "allowance": {
    ///          "currentAllowance": "1000000000",
    ///          "spender": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///        },
    ///        "balance": {
    ///          "currentBalance": "1000000000000000000",
    ///          "requiredBalance": "1000000000000000000",
    ///          "token": "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///        },
    ///        "simulationIncomplete": false
    ///      },
    ///      "liquidityAvailable": true,
    ///      "minToAmount": "900000000000000000",
    ///      "toAmount": "1000000000000000000",
    ///      "toToken": "0x7F5c764cBc14f9669B88837ca1490cCa17c31607"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "blockNumber",
    ///    "fees",
    ///    "fromAmount",
    ///    "fromToken",
    ///    "issues",
    ///    "liquidityAvailable",
    ///    "minToAmount",
    ///    "toAmount",
    ///    "toToken"
    ///  ],
    ///  "properties": {
    ///    "blockNumber": {
    ///      "description": "The block number at which the liquidity conditions were examined.",
    ///      "examples": [
    ///        "17038723"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[1-9]\\d*$"
    ///    },
    ///    "fees": {
    ///      "description": "The estimated fees for the swap.",
    ///      "examples": [
    ///        {
    ///          "gasFee": {
    ///            "amount": "1000000000000000000",
    ///            "token": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///          },
    ///          "protocolFee": {
    ///            "amount": "1000000000000000000",
    ///            "token": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///          }
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "required": [
    ///        "gasFee",
    ///        "protocolFee"
    ///      ],
    ///      "properties": {
    ///        "gasFee": {
    ///          "description": "The estimated gas fee for the swap.",
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/TokenFee"
    ///            }
    ///          ]
    ///        },
    ///        "protocolFee": {
    ///          "description": "The estimated protocol fee for the swap.",
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/TokenFee"
    ///            }
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    "fromAmount": {
    ///      "description": "The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^(0|[1-9]\\d*)$"
    ///    },
    ///    "fromToken": {
    ///      "description": "The 0x-prefixed contract address of the token that will be sent.",
    ///      "examples": [
    ///        "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    },
    ///    "issues": {
    ///      "description": "An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.",
    ///      "examples": [
    ///        {
    ///          "allowance": {
    ///            "currentAllowance": "1000000000",
    ///            "spender": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///          },
    ///          "balance": {
    ///            "currentBalance": "900000000000000000",
    ///            "requiredBalance": "1000000000000000000",
    ///            "token": "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///          },
    ///          "simulationIncomplete": false
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "required": [
    ///        "allowance",
    ///        "balance",
    ///        "simulationIncomplete"
    ///      ],
    ///      "properties": {
    ///        "allowance": {
    ///          "description": "Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.",
    ///          "examples": [
    ///            {
    ///              "currentAllowance": "1000000000",
    ///              "spender": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///            }
    ///          ],
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "required": [
    ///            "currentAllowance",
    ///            "spender"
    ///          ],
    ///          "properties": {
    ///            "currentAllowance": {
    ///              "description": "The current allowance of the `fromToken` by the `taker`.",
    ///              "examples": [
    ///                "1000000000"
    ///              ],
    ///              "type": "string",
    ///              "pattern": "^\\d+$"
    ///            },
    ///            "spender": {
    ///              "description": "The 0x-prefixed address of to set the allowance on.",
    ///              "examples": [
    ///                "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///              ],
    ///              "type": "string",
    ///              "pattern": "^0x[a-fA-F0-9]{40}$"
    ///            }
    ///          }
    ///        },
    ///        "balance": {
    ///          "description": "Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.",
    ///          "examples": [
    ///            {
    ///              "currentBalance": "1000000000000000000",
    ///              "requiredBalance": "1000000000000000000",
    ///              "token": "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///            }
    ///          ],
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "required": [
    ///            "currentBalance",
    ///            "requiredBalance",
    ///            "token"
    ///          ],
    ///          "properties": {
    ///            "currentBalance": {
    ///              "description": "The current balance of the `fromToken` by the `taker`.",
    ///              "examples": [
    ///                "10000000"
    ///              ],
    ///              "type": "string",
    ///              "pattern": "^\\d+$"
    ///            },
    ///            "requiredBalance": {
    ///              "description": "The amount of the token that the `taker` must hold.",
    ///              "examples": [
    ///                "1000000000000000000"
    ///              ],
    ///              "type": "string",
    ///              "pattern": "^\\d+$"
    ///            },
    ///            "token": {
    ///              "description": "The 0x-prefixed contract address of the token.",
    ///              "type": "string",
    ///              "pattern": "^0x[a-fA-F0-9]{40}$"
    ///            }
    ///          }
    ///        },
    ///        "simulationIncomplete": {
    ///          "description": "This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.",
    ///          "examples": [
    ///            false
    ///          ],
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    },
    ///    "liquidityAvailable": {
    ///      "description": "Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean",
    ///      "enum": [
    ///        true
    ///      ]
    ///    },
    ///    "minToAmount": {
    ///      "description": "The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.",
    ///      "examples": [
    ///        "900000000000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^(0|[1-9]\\d*)$"
    ///    },
    ///    "toAmount": {
    ///      "description": "The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^(0|[1-9]\\d*)$"
    ///    },
    ///    "toToken": {
    ///      "description": "The 0x-prefixed contract address of the token that will be received.",
    ///      "examples": [
    ///        "0x7F5c764cBc14f9669B88837ca1490cCa17c31607"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CommonSwapResponse {
        ///The block number at which the liquidity conditions were examined.
        #[serde(rename = "blockNumber")]
        pub block_number: CommonSwapResponseBlockNumber,
        pub fees: CommonSwapResponseFees,
        ///The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
        #[serde(rename = "fromAmount")]
        pub from_amount: CommonSwapResponseFromAmount,
        ///The 0x-prefixed contract address of the token that will be sent.
        #[serde(rename = "fromToken")]
        pub from_token: CommonSwapResponseFromToken,
        pub issues: CommonSwapResponseIssues,
        ///Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
        #[serde(rename = "liquidityAvailable")]
        pub liquidity_available: bool,
        ///The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
        #[serde(rename = "minToAmount")]
        pub min_to_amount: CommonSwapResponseMinToAmount,
        ///The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
        #[serde(rename = "toAmount")]
        pub to_amount: CommonSwapResponseToAmount,
        ///The 0x-prefixed contract address of the token that will be received.
        #[serde(rename = "toToken")]
        pub to_token: CommonSwapResponseToToken,
    }
    impl ::std::convert::From<&CommonSwapResponse> for CommonSwapResponse {
        fn from(value: &CommonSwapResponse) -> Self {
            value.clone()
        }
    }
    impl CommonSwapResponse {
        pub fn builder() -> builder::CommonSwapResponse {
            Default::default()
        }
    }
    ///The block number at which the liquidity conditions were examined.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The block number at which the liquidity conditions were examined.",
    ///  "examples": [
    ///    "17038723"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[1-9]\\d*$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CommonSwapResponseBlockNumber(::std::string::String);
    impl ::std::ops::Deref for CommonSwapResponseBlockNumber {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CommonSwapResponseBlockNumber> for ::std::string::String {
        fn from(value: CommonSwapResponseBlockNumber) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CommonSwapResponseBlockNumber> for CommonSwapResponseBlockNumber {
        fn from(value: &CommonSwapResponseBlockNumber) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CommonSwapResponseBlockNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^[1-9]\\d*$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9]\\d*$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CommonSwapResponseBlockNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CommonSwapResponseBlockNumber {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CommonSwapResponseBlockNumber {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CommonSwapResponseBlockNumber {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The estimated fees for the swap.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The estimated fees for the swap.",
    ///  "examples": [
    ///    {
    ///      "gasFee": {
    ///        "amount": "1000000000000000000",
    ///        "token": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///      },
    ///      "protocolFee": {
    ///        "amount": "1000000000000000000",
    ///        "token": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "gasFee",
    ///    "protocolFee"
    ///  ],
    ///  "properties": {
    ///    "gasFee": {
    ///      "description": "The estimated gas fee for the swap.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/TokenFee"
    ///        }
    ///      ]
    ///    },
    ///    "protocolFee": {
    ///      "description": "The estimated protocol fee for the swap.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/TokenFee"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CommonSwapResponseFees {
        ///The estimated gas fee for the swap.
        #[serde(rename = "gasFee")]
        pub gas_fee: ::std::option::Option<TokenFee>,
        ///The estimated protocol fee for the swap.
        #[serde(rename = "protocolFee")]
        pub protocol_fee: ::std::option::Option<TokenFee>,
    }
    impl ::std::convert::From<&CommonSwapResponseFees> for CommonSwapResponseFees {
        fn from(value: &CommonSwapResponseFees) -> Self {
            value.clone()
        }
    }
    impl CommonSwapResponseFees {
        pub fn builder() -> builder::CommonSwapResponseFees {
            Default::default()
        }
    }
    ///The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0|[1-9]\\d*)$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CommonSwapResponseFromAmount(::std::string::String);
    impl ::std::ops::Deref for CommonSwapResponseFromAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CommonSwapResponseFromAmount> for ::std::string::String {
        fn from(value: CommonSwapResponseFromAmount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CommonSwapResponseFromAmount> for CommonSwapResponseFromAmount {
        fn from(value: &CommonSwapResponseFromAmount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CommonSwapResponseFromAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(0|[1-9]\\d*)$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^(0|[1-9]\\d*)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CommonSwapResponseFromAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CommonSwapResponseFromAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CommonSwapResponseFromAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CommonSwapResponseFromAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed contract address of the token that will be sent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed contract address of the token that will be sent.",
    ///  "examples": [
    ///    "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CommonSwapResponseFromToken(::std::string::String);
    impl ::std::ops::Deref for CommonSwapResponseFromToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CommonSwapResponseFromToken> for ::std::string::String {
        fn from(value: CommonSwapResponseFromToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CommonSwapResponseFromToken> for CommonSwapResponseFromToken {
        fn from(value: &CommonSwapResponseFromToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CommonSwapResponseFromToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CommonSwapResponseFromToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CommonSwapResponseFromToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CommonSwapResponseFromToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CommonSwapResponseFromToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.",
    ///  "examples": [
    ///    {
    ///      "allowance": {
    ///        "currentAllowance": "1000000000",
    ///        "spender": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///      },
    ///      "balance": {
    ///        "currentBalance": "900000000000000000",
    ///        "requiredBalance": "1000000000000000000",
    ///        "token": "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///      },
    ///      "simulationIncomplete": false
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "allowance",
    ///    "balance",
    ///    "simulationIncomplete"
    ///  ],
    ///  "properties": {
    ///    "allowance": {
    ///      "description": "Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.",
    ///      "examples": [
    ///        {
    ///          "currentAllowance": "1000000000",
    ///          "spender": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///        }
    ///      ],
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "required": [
    ///        "currentAllowance",
    ///        "spender"
    ///      ],
    ///      "properties": {
    ///        "currentAllowance": {
    ///          "description": "The current allowance of the `fromToken` by the `taker`.",
    ///          "examples": [
    ///            "1000000000"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^\\d+$"
    ///        },
    ///        "spender": {
    ///          "description": "The 0x-prefixed address of to set the allowance on.",
    ///          "examples": [
    ///            "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^0x[a-fA-F0-9]{40}$"
    ///        }
    ///      }
    ///    },
    ///    "balance": {
    ///      "description": "Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.",
    ///      "examples": [
    ///        {
    ///          "currentBalance": "1000000000000000000",
    ///          "requiredBalance": "1000000000000000000",
    ///          "token": "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///        }
    ///      ],
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "required": [
    ///        "currentBalance",
    ///        "requiredBalance",
    ///        "token"
    ///      ],
    ///      "properties": {
    ///        "currentBalance": {
    ///          "description": "The current balance of the `fromToken` by the `taker`.",
    ///          "examples": [
    ///            "10000000"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^\\d+$"
    ///        },
    ///        "requiredBalance": {
    ///          "description": "The amount of the token that the `taker` must hold.",
    ///          "examples": [
    ///            "1000000000000000000"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^\\d+$"
    ///        },
    ///        "token": {
    ///          "description": "The 0x-prefixed contract address of the token.",
    ///          "type": "string",
    ///          "pattern": "^0x[a-fA-F0-9]{40}$"
    ///        }
    ///      }
    ///    },
    ///    "simulationIncomplete": {
    ///      "description": "This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CommonSwapResponseIssues {
        ///Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
        pub allowance: ::std::option::Option<CommonSwapResponseIssuesAllowance>,
        ///Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
        pub balance: ::std::option::Option<CommonSwapResponseIssuesBalance>,
        ///This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.
        #[serde(rename = "simulationIncomplete")]
        pub simulation_incomplete: bool,
    }
    impl ::std::convert::From<&CommonSwapResponseIssues> for CommonSwapResponseIssues {
        fn from(value: &CommonSwapResponseIssues) -> Self {
            value.clone()
        }
    }
    impl CommonSwapResponseIssues {
        pub fn builder() -> builder::CommonSwapResponseIssues {
            Default::default()
        }
    }
    ///Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.",
    ///  "examples": [
    ///    {
    ///      "currentAllowance": "1000000000",
    ///      "spender": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "currentAllowance",
    ///    "spender"
    ///  ],
    ///  "properties": {
    ///    "currentAllowance": {
    ///      "description": "The current allowance of the `fromToken` by the `taker`.",
    ///      "examples": [
    ///        "1000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    },
    ///    "spender": {
    ///      "description": "The 0x-prefixed address of to set the allowance on.",
    ///      "examples": [
    ///        "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CommonSwapResponseIssuesAllowance {
        ///The current allowance of the `fromToken` by the `taker`.
        #[serde(rename = "currentAllowance")]
        pub current_allowance: CommonSwapResponseIssuesAllowanceCurrentAllowance,
        ///The 0x-prefixed address of to set the allowance on.
        pub spender: CommonSwapResponseIssuesAllowanceSpender,
    }
    impl ::std::convert::From<&CommonSwapResponseIssuesAllowance>
        for CommonSwapResponseIssuesAllowance
    {
        fn from(value: &CommonSwapResponseIssuesAllowance) -> Self {
            value.clone()
        }
    }
    impl CommonSwapResponseIssuesAllowance {
        pub fn builder() -> builder::CommonSwapResponseIssuesAllowance {
            Default::default()
        }
    }
    ///The current allowance of the `fromToken` by the `taker`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The current allowance of the `fromToken` by the `taker`.",
    ///  "examples": [
    ///    "1000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CommonSwapResponseIssuesAllowanceCurrentAllowance(::std::string::String);
    impl ::std::ops::Deref for CommonSwapResponseIssuesAllowanceCurrentAllowance {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CommonSwapResponseIssuesAllowanceCurrentAllowance>
        for ::std::string::String
    {
        fn from(value: CommonSwapResponseIssuesAllowanceCurrentAllowance) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CommonSwapResponseIssuesAllowanceCurrentAllowance>
        for CommonSwapResponseIssuesAllowanceCurrentAllowance
    {
        fn from(value: &CommonSwapResponseIssuesAllowanceCurrentAllowance) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CommonSwapResponseIssuesAllowanceCurrentAllowance {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CommonSwapResponseIssuesAllowanceCurrentAllowance {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CommonSwapResponseIssuesAllowanceCurrentAllowance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CommonSwapResponseIssuesAllowanceCurrentAllowance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CommonSwapResponseIssuesAllowanceCurrentAllowance {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed address of to set the allowance on.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed address of to set the allowance on.",
    ///  "examples": [
    ///    "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CommonSwapResponseIssuesAllowanceSpender(::std::string::String);
    impl ::std::ops::Deref for CommonSwapResponseIssuesAllowanceSpender {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CommonSwapResponseIssuesAllowanceSpender> for ::std::string::String {
        fn from(value: CommonSwapResponseIssuesAllowanceSpender) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CommonSwapResponseIssuesAllowanceSpender>
        for CommonSwapResponseIssuesAllowanceSpender
    {
        fn from(value: &CommonSwapResponseIssuesAllowanceSpender) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CommonSwapResponseIssuesAllowanceSpender {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CommonSwapResponseIssuesAllowanceSpender {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CommonSwapResponseIssuesAllowanceSpender {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CommonSwapResponseIssuesAllowanceSpender {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CommonSwapResponseIssuesAllowanceSpender {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.",
    ///  "examples": [
    ///    {
    ///      "currentBalance": "1000000000000000000",
    ///      "requiredBalance": "1000000000000000000",
    ///      "token": "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "currentBalance",
    ///    "requiredBalance",
    ///    "token"
    ///  ],
    ///  "properties": {
    ///    "currentBalance": {
    ///      "description": "The current balance of the `fromToken` by the `taker`.",
    ///      "examples": [
    ///        "10000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    },
    ///    "requiredBalance": {
    ///      "description": "The amount of the token that the `taker` must hold.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    },
    ///    "token": {
    ///      "description": "The 0x-prefixed contract address of the token.",
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CommonSwapResponseIssuesBalance {
        ///The current balance of the `fromToken` by the `taker`.
        #[serde(rename = "currentBalance")]
        pub current_balance: CommonSwapResponseIssuesBalanceCurrentBalance,
        ///The amount of the token that the `taker` must hold.
        #[serde(rename = "requiredBalance")]
        pub required_balance: CommonSwapResponseIssuesBalanceRequiredBalance,
        ///The 0x-prefixed contract address of the token.
        pub token: CommonSwapResponseIssuesBalanceToken,
    }
    impl ::std::convert::From<&CommonSwapResponseIssuesBalance> for CommonSwapResponseIssuesBalance {
        fn from(value: &CommonSwapResponseIssuesBalance) -> Self {
            value.clone()
        }
    }
    impl CommonSwapResponseIssuesBalance {
        pub fn builder() -> builder::CommonSwapResponseIssuesBalance {
            Default::default()
        }
    }
    ///The current balance of the `fromToken` by the `taker`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The current balance of the `fromToken` by the `taker`.",
    ///  "examples": [
    ///    "10000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CommonSwapResponseIssuesBalanceCurrentBalance(::std::string::String);
    impl ::std::ops::Deref for CommonSwapResponseIssuesBalanceCurrentBalance {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CommonSwapResponseIssuesBalanceCurrentBalance> for ::std::string::String {
        fn from(value: CommonSwapResponseIssuesBalanceCurrentBalance) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CommonSwapResponseIssuesBalanceCurrentBalance>
        for CommonSwapResponseIssuesBalanceCurrentBalance
    {
        fn from(value: &CommonSwapResponseIssuesBalanceCurrentBalance) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CommonSwapResponseIssuesBalanceCurrentBalance {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CommonSwapResponseIssuesBalanceCurrentBalance {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CommonSwapResponseIssuesBalanceCurrentBalance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CommonSwapResponseIssuesBalanceCurrentBalance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CommonSwapResponseIssuesBalanceCurrentBalance {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The amount of the token that the `taker` must hold.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount of the token that the `taker` must hold.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CommonSwapResponseIssuesBalanceRequiredBalance(::std::string::String);
    impl ::std::ops::Deref for CommonSwapResponseIssuesBalanceRequiredBalance {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CommonSwapResponseIssuesBalanceRequiredBalance>
        for ::std::string::String
    {
        fn from(value: CommonSwapResponseIssuesBalanceRequiredBalance) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CommonSwapResponseIssuesBalanceRequiredBalance>
        for CommonSwapResponseIssuesBalanceRequiredBalance
    {
        fn from(value: &CommonSwapResponseIssuesBalanceRequiredBalance) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CommonSwapResponseIssuesBalanceRequiredBalance {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CommonSwapResponseIssuesBalanceRequiredBalance {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CommonSwapResponseIssuesBalanceRequiredBalance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CommonSwapResponseIssuesBalanceRequiredBalance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CommonSwapResponseIssuesBalanceRequiredBalance {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed contract address of the token.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed contract address of the token.",
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CommonSwapResponseIssuesBalanceToken(::std::string::String);
    impl ::std::ops::Deref for CommonSwapResponseIssuesBalanceToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CommonSwapResponseIssuesBalanceToken> for ::std::string::String {
        fn from(value: CommonSwapResponseIssuesBalanceToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CommonSwapResponseIssuesBalanceToken>
        for CommonSwapResponseIssuesBalanceToken
    {
        fn from(value: &CommonSwapResponseIssuesBalanceToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CommonSwapResponseIssuesBalanceToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CommonSwapResponseIssuesBalanceToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CommonSwapResponseIssuesBalanceToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CommonSwapResponseIssuesBalanceToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CommonSwapResponseIssuesBalanceToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.",
    ///  "examples": [
    ///    "900000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0|[1-9]\\d*)$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CommonSwapResponseMinToAmount(::std::string::String);
    impl ::std::ops::Deref for CommonSwapResponseMinToAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CommonSwapResponseMinToAmount> for ::std::string::String {
        fn from(value: CommonSwapResponseMinToAmount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CommonSwapResponseMinToAmount> for CommonSwapResponseMinToAmount {
        fn from(value: &CommonSwapResponseMinToAmount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CommonSwapResponseMinToAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(0|[1-9]\\d*)$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^(0|[1-9]\\d*)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CommonSwapResponseMinToAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CommonSwapResponseMinToAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CommonSwapResponseMinToAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CommonSwapResponseMinToAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0|[1-9]\\d*)$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CommonSwapResponseToAmount(::std::string::String);
    impl ::std::ops::Deref for CommonSwapResponseToAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CommonSwapResponseToAmount> for ::std::string::String {
        fn from(value: CommonSwapResponseToAmount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CommonSwapResponseToAmount> for CommonSwapResponseToAmount {
        fn from(value: &CommonSwapResponseToAmount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CommonSwapResponseToAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(0|[1-9]\\d*)$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^(0|[1-9]\\d*)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CommonSwapResponseToAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CommonSwapResponseToAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CommonSwapResponseToAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CommonSwapResponseToAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed contract address of the token that will be received.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed contract address of the token that will be received.",
    ///  "examples": [
    ///    "0x7F5c764cBc14f9669B88837ca1490cCa17c31607"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CommonSwapResponseToToken(::std::string::String);
    impl ::std::ops::Deref for CommonSwapResponseToToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CommonSwapResponseToToken> for ::std::string::String {
        fn from(value: CommonSwapResponseToToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CommonSwapResponseToToken> for CommonSwapResponseToToken {
        fn from(value: &CommonSwapResponseToToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CommonSwapResponseToToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CommonSwapResponseToToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CommonSwapResponseToToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CommonSwapResponseToToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CommonSwapResponseToToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateEndUserBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "authenticationMethods"
    ///  ],
    ///  "properties": {
    ///    "authenticationMethods": {
    ///      "$ref": "#/components/schemas/AuthenticationMethods"
    ///    },
    ///    "evmAccount": {
    ///      "description": "Configuration for creating an EVM account for the end user.",
    ///      "type": "object",
    ///      "properties": {
    ///        "createSmartAccount": {
    ///          "description": "If true, creates an EVM smart account and a default EVM EOA account as the owner. If false, only a EVM EOA account is created.",
    ///          "default": false,
    ///          "examples": [
    ///            true
    ///          ],
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    },
    ///    "solanaAccount": {
    ///      "description": "Configuration for creating a Solana account for the end user.",
    ///      "type": "object",
    ///      "properties": {
    ///        "createSmartAccount": {
    ///          "description": "Only false is a valid option since currently smart accounts on Solana are not supported.",
    ///          "default": false,
    ///          "examples": [
    ///            false
    ///          ],
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    },
    ///    "userId": {
    ///      "description": "A stable, unique identifier for the end user. The `userId` must be unique across all end users in the developer's CDP Project. It must be between 1 and 100 characters long and can only contain alphanumeric characters and hyphens.\n\nIf `userId` is not provided in the request, the server will generate a random UUID.",
    ///      "examples": [
    ///        "e051beeb-7163-4527-a5b6-35e301529ff2"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[a-zA-Z0-9-]{1,100}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateEndUserBody {
        #[serde(rename = "authenticationMethods")]
        pub authentication_methods: AuthenticationMethods,
        #[serde(
            rename = "evmAccount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub evm_account: ::std::option::Option<CreateEndUserBodyEvmAccount>,
        #[serde(
            rename = "solanaAccount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub solana_account: ::std::option::Option<CreateEndUserBodySolanaAccount>,
        /**A stable, unique identifier for the end user. The `userId` must be unique across all end users in the developer's CDP Project. It must be between 1 and 100 characters long and can only contain alphanumeric characters and hyphens.

        If `userId` is not provided in the request, the server will generate a random UUID.*/
        #[serde(
            rename = "userId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub user_id: ::std::option::Option<CreateEndUserBodyUserId>,
    }
    impl ::std::convert::From<&CreateEndUserBody> for CreateEndUserBody {
        fn from(value: &CreateEndUserBody) -> Self {
            value.clone()
        }
    }
    impl CreateEndUserBody {
        pub fn builder() -> builder::CreateEndUserBody {
            Default::default()
        }
    }
    ///Configuration for creating an EVM account for the end user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Configuration for creating an EVM account for the end user.",
    ///  "type": "object",
    ///  "properties": {
    ///    "createSmartAccount": {
    ///      "description": "If true, creates an EVM smart account and a default EVM EOA account as the owner. If false, only a EVM EOA account is created.",
    ///      "default": false,
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateEndUserBodyEvmAccount {
        ///If true, creates an EVM smart account and a default EVM EOA account as the owner. If false, only a EVM EOA account is created.
        #[serde(rename = "createSmartAccount", default)]
        pub create_smart_account: bool,
    }
    impl ::std::convert::From<&CreateEndUserBodyEvmAccount> for CreateEndUserBodyEvmAccount {
        fn from(value: &CreateEndUserBodyEvmAccount) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for CreateEndUserBodyEvmAccount {
        fn default() -> Self {
            Self {
                create_smart_account: Default::default(),
            }
        }
    }
    impl CreateEndUserBodyEvmAccount {
        pub fn builder() -> builder::CreateEndUserBodyEvmAccount {
            Default::default()
        }
    }
    ///Configuration for creating a Solana account for the end user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Configuration for creating a Solana account for the end user.",
    ///  "type": "object",
    ///  "properties": {
    ///    "createSmartAccount": {
    ///      "description": "Only false is a valid option since currently smart accounts on Solana are not supported.",
    ///      "default": false,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateEndUserBodySolanaAccount {
        ///Only false is a valid option since currently smart accounts on Solana are not supported.
        #[serde(rename = "createSmartAccount", default)]
        pub create_smart_account: bool,
    }
    impl ::std::convert::From<&CreateEndUserBodySolanaAccount> for CreateEndUserBodySolanaAccount {
        fn from(value: &CreateEndUserBodySolanaAccount) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for CreateEndUserBodySolanaAccount {
        fn default() -> Self {
            Self {
                create_smart_account: Default::default(),
            }
        }
    }
    impl CreateEndUserBodySolanaAccount {
        pub fn builder() -> builder::CreateEndUserBodySolanaAccount {
            Default::default()
        }
    }
    /**A stable, unique identifier for the end user. The `userId` must be unique across all end users in the developer's CDP Project. It must be between 1 and 100 characters long and can only contain alphanumeric characters and hyphens.

    If `userId` is not provided in the request, the server will generate a random UUID.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A stable, unique identifier for the end user. The `userId` must be unique across all end users in the developer's CDP Project. It must be between 1 and 100 characters long and can only contain alphanumeric characters and hyphens.\n\nIf `userId` is not provided in the request, the server will generate a random UUID.",
    ///  "examples": [
    ///    "e051beeb-7163-4527-a5b6-35e301529ff2"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[a-zA-Z0-9-]{1,100}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEndUserBodyUserId(::std::string::String);
    impl ::std::ops::Deref for CreateEndUserBodyUserId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEndUserBodyUserId> for ::std::string::String {
        fn from(value: CreateEndUserBodyUserId) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEndUserBodyUserId> for CreateEndUserBodyUserId {
        fn from(value: &CreateEndUserBodyUserId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEndUserBodyUserId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[a-zA-Z0-9-]{1,100}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[a-zA-Z0-9-]{1,100}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEndUserBodyUserId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEndUserBodyUserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEndUserBodyUserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEndUserBodyUserId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateEndUserXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEndUserXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for CreateEndUserXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEndUserXIdempotencyKey> for ::std::string::String {
        fn from(value: CreateEndUserXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEndUserXIdempotencyKey> for CreateEndUserXIdempotencyKey {
        fn from(value: &CreateEndUserXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEndUserXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEndUserXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEndUserXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEndUserXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEndUserXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateEvmAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "accountPolicy": {
    ///      "description": "The ID of the account-level policy to apply to the account.",
    ///      "examples": [
    ///        "123e4567-e89b-12d3-a456-426614174000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
    ///      "x-audience": "public"
    ///    },
    ///    "name": {
    ///      "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.",
    ///      "examples": [
    ///        "my-wallet"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateEvmAccountBody {
        ///The ID of the account-level policy to apply to the account.
        #[serde(
            rename = "accountPolicy",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub account_policy: ::std::option::Option<CreateEvmAccountBodyAccountPolicy>,
        /**An optional name for the account.
        Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
        Account names must be unique across all EVM accounts in the developer's CDP Project.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<CreateEvmAccountBodyName>,
    }
    impl ::std::convert::From<&CreateEvmAccountBody> for CreateEvmAccountBody {
        fn from(value: &CreateEvmAccountBody) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for CreateEvmAccountBody {
        fn default() -> Self {
            Self {
                account_policy: Default::default(),
                name: Default::default(),
            }
        }
    }
    impl CreateEvmAccountBody {
        pub fn builder() -> builder::CreateEvmAccountBody {
            Default::default()
        }
    }
    ///The ID of the account-level policy to apply to the account.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The ID of the account-level policy to apply to the account.",
    ///  "examples": [
    ///    "123e4567-e89b-12d3-a456-426614174000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEvmAccountBodyAccountPolicy(::std::string::String);
    impl ::std::ops::Deref for CreateEvmAccountBodyAccountPolicy {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEvmAccountBodyAccountPolicy> for ::std::string::String {
        fn from(value: CreateEvmAccountBodyAccountPolicy) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEvmAccountBodyAccountPolicy>
        for CreateEvmAccountBodyAccountPolicy
    {
        fn from(value: &CreateEvmAccountBodyAccountPolicy) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEvmAccountBodyAccountPolicy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(
                || {
                    ::regress::Regex::new(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
                    )
                    .unwrap()
                },
            );
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEvmAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEvmAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEvmAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEvmAccountBodyAccountPolicy {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    /**An optional name for the account.
    Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
    Account names must be unique across all EVM accounts in the developer's CDP Project.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.",
    ///  "examples": [
    ///    "my-wallet"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEvmAccountBodyName(::std::string::String);
    impl ::std::ops::Deref for CreateEvmAccountBodyName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEvmAccountBodyName> for ::std::string::String {
        fn from(value: CreateEvmAccountBodyName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEvmAccountBodyName> for CreateEvmAccountBodyName {
        fn from(value: &CreateEvmAccountBodyName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEvmAccountBodyName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEvmAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEvmAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEvmAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEvmAccountBodyName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateEvmAccountXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEvmAccountXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for CreateEvmAccountXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEvmAccountXIdempotencyKey> for ::std::string::String {
        fn from(value: CreateEvmAccountXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEvmAccountXIdempotencyKey> for CreateEvmAccountXIdempotencyKey {
        fn from(value: &CreateEvmAccountXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEvmAccountXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEvmAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEvmAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEvmAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEvmAccountXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateEvmSmartAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "owners"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.",
    ///      "examples": [
    ///        "my-smart-wallet"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///    },
    ///    "owners": {
    ///      "description": "Today, only a single owner can be set for a Smart Account, but this is an array to allow setting multiple owners in the future.",
    ///      "examples": [
    ///        [
    ///          "0xfc807D1bE4997e5C7B33E4d8D57e60c5b0f02B1a"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "pattern": "^0x[0-9a-fA-F]{40}$"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateEvmSmartAccountBody {
        /**An optional name for the account.
        Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
        Account names must be unique across all EVM accounts in the developer's CDP Project.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<CreateEvmSmartAccountBodyName>,
        ///Today, only a single owner can be set for a Smart Account, but this is an array to allow setting multiple owners in the future.
        pub owners: ::std::vec::Vec<CreateEvmSmartAccountBodyOwnersItem>,
    }
    impl ::std::convert::From<&CreateEvmSmartAccountBody> for CreateEvmSmartAccountBody {
        fn from(value: &CreateEvmSmartAccountBody) -> Self {
            value.clone()
        }
    }
    impl CreateEvmSmartAccountBody {
        pub fn builder() -> builder::CreateEvmSmartAccountBody {
            Default::default()
        }
    }
    /**An optional name for the account.
    Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
    Account names must be unique across all EVM accounts in the developer's CDP Project.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.",
    ///  "examples": [
    ///    "my-smart-wallet"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEvmSmartAccountBodyName(::std::string::String);
    impl ::std::ops::Deref for CreateEvmSmartAccountBodyName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEvmSmartAccountBodyName> for ::std::string::String {
        fn from(value: CreateEvmSmartAccountBodyName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEvmSmartAccountBodyName> for CreateEvmSmartAccountBodyName {
        fn from(value: &CreateEvmSmartAccountBodyName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEvmSmartAccountBodyName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEvmSmartAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEvmSmartAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEvmSmartAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEvmSmartAccountBodyName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateEvmSmartAccountBodyOwnersItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEvmSmartAccountBodyOwnersItem(::std::string::String);
    impl ::std::ops::Deref for CreateEvmSmartAccountBodyOwnersItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEvmSmartAccountBodyOwnersItem> for ::std::string::String {
        fn from(value: CreateEvmSmartAccountBodyOwnersItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEvmSmartAccountBodyOwnersItem>
        for CreateEvmSmartAccountBodyOwnersItem
    {
        fn from(value: &CreateEvmSmartAccountBodyOwnersItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEvmSmartAccountBodyOwnersItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEvmSmartAccountBodyOwnersItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEvmSmartAccountBodyOwnersItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEvmSmartAccountBodyOwnersItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEvmSmartAccountBodyOwnersItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateEvmSmartAccountXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEvmSmartAccountXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for CreateEvmSmartAccountXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEvmSmartAccountXIdempotencyKey> for ::std::string::String {
        fn from(value: CreateEvmSmartAccountXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEvmSmartAccountXIdempotencyKey>
        for CreateEvmSmartAccountXIdempotencyKey
    {
        fn from(value: &CreateEvmSmartAccountXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEvmSmartAccountXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEvmSmartAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEvmSmartAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEvmSmartAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEvmSmartAccountXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateEvmSwapQuoteBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "fromAmount",
    ///    "fromToken",
    ///    "network",
    ///    "taker",
    ///    "toToken"
    ///  ],
    ///  "properties": {
    ///    "fromAmount": {
    ///      "description": "The amount of the `fromToken` to send in atomic units of the token. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    },
    ///    "fromToken": {
    ///      "description": "The 0x-prefixed contract address of the token to send.",
    ///      "examples": [
    ///        "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    },
    ///    "gasPrice": {
    ///      "description": "The target gas price for the swap transaction, in Wei. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. If not provided, the API will use an estimate based on the current network conditions.",
    ///      "examples": [
    ///        "1000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    },
    ///    "network": {
    ///      "$ref": "#/components/schemas/EvmSwapsNetwork"
    ///    },
    ///    "signerAddress": {
    ///      "description": "The 0x-prefixed Externally Owned Account (EOA) address that will sign the `Permit2` EIP-712 permit message. This is only needed if `taker` is a smart contract.",
    ///      "examples": [
    ///        "0x922f49447d8a07e3bd95bd0d56f35241523fbab8"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    },
    ///    "slippageBps": {
    ///      "description": "The maximum acceptable slippage of the `toToken` in basis points. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100 bps (i.e., 1%).",
    ///      "default": 100,
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "integer",
    ///      "maximum": 10000.0,
    ///      "minimum": 0.0
    ///    },
    ///    "taker": {
    ///      "description": "The 0x-prefixed address that holds the `fromToken` balance and has the `Permit2` allowance set for the swap.",
    ///      "examples": [
    ///        "0xAc0974bec39a17e36ba4a6b4d238ff944bacb478"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    },
    ///    "toToken": {
    ///      "description": "The 0x-prefixed contract address of the token to receive.",
    ///      "examples": [
    ///        "0x7F5c764cBc14f9669B88837ca1490cCa17c31607"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateEvmSwapQuoteBody {
        ///The amount of the `fromToken` to send in atomic units of the token. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
        #[serde(rename = "fromAmount")]
        pub from_amount: CreateEvmSwapQuoteBodyFromAmount,
        ///The 0x-prefixed contract address of the token to send.
        #[serde(rename = "fromToken")]
        pub from_token: CreateEvmSwapQuoteBodyFromToken,
        ///The target gas price for the swap transaction, in Wei. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. If not provided, the API will use an estimate based on the current network conditions.
        #[serde(
            rename = "gasPrice",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub gas_price: ::std::option::Option<CreateEvmSwapQuoteBodyGasPrice>,
        pub network: EvmSwapsNetwork,
        ///The 0x-prefixed Externally Owned Account (EOA) address that will sign the `Permit2` EIP-712 permit message. This is only needed if `taker` is a smart contract.
        #[serde(
            rename = "signerAddress",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub signer_address: ::std::option::Option<CreateEvmSwapQuoteBodySignerAddress>,
        ///The maximum acceptable slippage of the `toToken` in basis points. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100 bps (i.e., 1%).
        #[serde(rename = "slippageBps", default = "defaults::default_u64::<i64, 100>")]
        pub slippage_bps: i64,
        ///The 0x-prefixed address that holds the `fromToken` balance and has the `Permit2` allowance set for the swap.
        pub taker: CreateEvmSwapQuoteBodyTaker,
        ///The 0x-prefixed contract address of the token to receive.
        #[serde(rename = "toToken")]
        pub to_token: CreateEvmSwapQuoteBodyToToken,
    }
    impl ::std::convert::From<&CreateEvmSwapQuoteBody> for CreateEvmSwapQuoteBody {
        fn from(value: &CreateEvmSwapQuoteBody) -> Self {
            value.clone()
        }
    }
    impl CreateEvmSwapQuoteBody {
        pub fn builder() -> builder::CreateEvmSwapQuoteBody {
            Default::default()
        }
    }
    ///The amount of the `fromToken` to send in atomic units of the token. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount of the `fromToken` to send in atomic units of the token. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEvmSwapQuoteBodyFromAmount(::std::string::String);
    impl ::std::ops::Deref for CreateEvmSwapQuoteBodyFromAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEvmSwapQuoteBodyFromAmount> for ::std::string::String {
        fn from(value: CreateEvmSwapQuoteBodyFromAmount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEvmSwapQuoteBodyFromAmount> for CreateEvmSwapQuoteBodyFromAmount {
        fn from(value: &CreateEvmSwapQuoteBodyFromAmount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEvmSwapQuoteBodyFromAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEvmSwapQuoteBodyFromAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEvmSwapQuoteBodyFromAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEvmSwapQuoteBodyFromAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEvmSwapQuoteBodyFromAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed contract address of the token to send.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed contract address of the token to send.",
    ///  "examples": [
    ///    "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEvmSwapQuoteBodyFromToken(::std::string::String);
    impl ::std::ops::Deref for CreateEvmSwapQuoteBodyFromToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEvmSwapQuoteBodyFromToken> for ::std::string::String {
        fn from(value: CreateEvmSwapQuoteBodyFromToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEvmSwapQuoteBodyFromToken> for CreateEvmSwapQuoteBodyFromToken {
        fn from(value: &CreateEvmSwapQuoteBodyFromToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEvmSwapQuoteBodyFromToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEvmSwapQuoteBodyFromToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEvmSwapQuoteBodyFromToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEvmSwapQuoteBodyFromToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEvmSwapQuoteBodyFromToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The target gas price for the swap transaction, in Wei. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. If not provided, the API will use an estimate based on the current network conditions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The target gas price for the swap transaction, in Wei. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. If not provided, the API will use an estimate based on the current network conditions.",
    ///  "examples": [
    ///    "1000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEvmSwapQuoteBodyGasPrice(::std::string::String);
    impl ::std::ops::Deref for CreateEvmSwapQuoteBodyGasPrice {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEvmSwapQuoteBodyGasPrice> for ::std::string::String {
        fn from(value: CreateEvmSwapQuoteBodyGasPrice) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEvmSwapQuoteBodyGasPrice> for CreateEvmSwapQuoteBodyGasPrice {
        fn from(value: &CreateEvmSwapQuoteBodyGasPrice) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEvmSwapQuoteBodyGasPrice {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEvmSwapQuoteBodyGasPrice {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEvmSwapQuoteBodyGasPrice {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEvmSwapQuoteBodyGasPrice {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEvmSwapQuoteBodyGasPrice {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed Externally Owned Account (EOA) address that will sign the `Permit2` EIP-712 permit message. This is only needed if `taker` is a smart contract.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed Externally Owned Account (EOA) address that will sign the `Permit2` EIP-712 permit message. This is only needed if `taker` is a smart contract.",
    ///  "examples": [
    ///    "0x922f49447d8a07e3bd95bd0d56f35241523fbab8"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEvmSwapQuoteBodySignerAddress(::std::string::String);
    impl ::std::ops::Deref for CreateEvmSwapQuoteBodySignerAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEvmSwapQuoteBodySignerAddress> for ::std::string::String {
        fn from(value: CreateEvmSwapQuoteBodySignerAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEvmSwapQuoteBodySignerAddress>
        for CreateEvmSwapQuoteBodySignerAddress
    {
        fn from(value: &CreateEvmSwapQuoteBodySignerAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEvmSwapQuoteBodySignerAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEvmSwapQuoteBodySignerAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEvmSwapQuoteBodySignerAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEvmSwapQuoteBodySignerAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEvmSwapQuoteBodySignerAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed address that holds the `fromToken` balance and has the `Permit2` allowance set for the swap.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed address that holds the `fromToken` balance and has the `Permit2` allowance set for the swap.",
    ///  "examples": [
    ///    "0xAc0974bec39a17e36ba4a6b4d238ff944bacb478"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEvmSwapQuoteBodyTaker(::std::string::String);
    impl ::std::ops::Deref for CreateEvmSwapQuoteBodyTaker {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEvmSwapQuoteBodyTaker> for ::std::string::String {
        fn from(value: CreateEvmSwapQuoteBodyTaker) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEvmSwapQuoteBodyTaker> for CreateEvmSwapQuoteBodyTaker {
        fn from(value: &CreateEvmSwapQuoteBodyTaker) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEvmSwapQuoteBodyTaker {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEvmSwapQuoteBodyTaker {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEvmSwapQuoteBodyTaker {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEvmSwapQuoteBodyTaker {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEvmSwapQuoteBodyTaker {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed contract address of the token to receive.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed contract address of the token to receive.",
    ///  "examples": [
    ///    "0x7F5c764cBc14f9669B88837ca1490cCa17c31607"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEvmSwapQuoteBodyToToken(::std::string::String);
    impl ::std::ops::Deref for CreateEvmSwapQuoteBodyToToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEvmSwapQuoteBodyToToken> for ::std::string::String {
        fn from(value: CreateEvmSwapQuoteBodyToToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEvmSwapQuoteBodyToToken> for CreateEvmSwapQuoteBodyToToken {
        fn from(value: &CreateEvmSwapQuoteBodyToToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEvmSwapQuoteBodyToToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEvmSwapQuoteBodyToToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEvmSwapQuoteBodyToToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEvmSwapQuoteBodyToToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEvmSwapQuoteBodyToToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateEvmSwapQuoteXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateEvmSwapQuoteXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for CreateEvmSwapQuoteXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateEvmSwapQuoteXIdempotencyKey> for ::std::string::String {
        fn from(value: CreateEvmSwapQuoteXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateEvmSwapQuoteXIdempotencyKey>
        for CreateEvmSwapQuoteXIdempotencyKey
    {
        fn from(value: &CreateEvmSwapQuoteXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateEvmSwapQuoteXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateEvmSwapQuoteXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateEvmSwapQuoteXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateEvmSwapQuoteXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateEvmSwapQuoteXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateOnrampOrderBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "agreementAcceptedAt",
    ///    "destinationAddress",
    ///    "destinationNetwork",
    ///    "email",
    ///    "partnerUserRef",
    ///    "paymentCurrency",
    ///    "paymentMethod",
    ///    "phoneNumber",
    ///    "phoneNumberVerifiedAt",
    ///    "purchaseCurrency"
    ///  ],
    ///  "properties": {
    ///    "agreementAcceptedAt": {
    ///      "description": "The timestamp of when the user acknowledged that by using Coinbase Onramp they are accepting the Coinbase Terms  (https://www.coinbase.com/legal/guest-checkout/us), User Agreement (https://www.coinbase.com/legal/user_agreement),  and Privacy Policy (https://www.coinbase.com/legal/privacy).",
    ///      "examples": [
    ///        "2025-04-24T00:00:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "clientIp": {
    ///      "description": "The IP address of the end user requesting the onramp transaction.",
    ///      "examples": [
    ///        "127.0.0.1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "destinationAddress": {
    ///      "description": "The address the purchased crypto will be sent to.",
    ///      "examples": [
    ///        "0x71C7656EC7ab88b098defB751B7401B5f6d8976F"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "destinationNetwork": {
    ///      "description": "The name of the crypto network the purchased currency will be sent on.\n\nUse the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported networks for your user's location.",
    ///      "examples": [
    ///        "base"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "domain": {
    ///      "description": "The domain that the Apple Pay button will be rendered on. Required when using the `GUEST_CHECKOUT_APPLE_PAY`  payment method and embedding the payment link in an iframe.",
    ///      "examples": [
    ///        "pay.coinbase.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "email": {
    ///      "description": "The verified email address of the user requesting the onramp transaction. This email must be verified by your app (via OTP) before being used with the Onramp API.",
    ///      "examples": [
    ///        "test@example.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isQuote": {
    ///      "description": "If true, this API will return a quote without creating any transaction.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "partnerOrderRef": {
    ///      "description": "Optional partner order reference ID.",
    ///      "examples": [
    ///        "order-1234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "partnerUserRef": {
    ///      "description": "A unique string that represents the user in your app. This can be used to link individual transactions  together so you can retrieve the transaction history for your users. Prefix this string with sandbox-  (e.g. \"sandbox-user-1234\") to perform a sandbox transaction which will allow you to test your integration  without any real transfer of funds.\n\nThis value can be used with with [Onramp User Transactions API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-onramp-transactions-by-id) to retrieve all transactions created by the user.",
    ///      "examples": [
    ///        "user-1234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentAmount": {
    ///      "description": "A string representing the amount of fiat the user wishes to pay in exchange for crypto. When using  this parameter, the returned quote will be inclusive of fees i.e. the user will pay this exact amount  of the payment currency.",
    ///      "examples": [
    ///        "100.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentCurrency": {
    ///      "description": "The fiat currency to be converted to crypto.",
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentMethod": {
    ///      "$ref": "#/components/schemas/OnrampOrderPaymentMethodTypeId"
    ///    },
    ///    "phoneNumber": {
    ///      "description": "The phone number of the user requesting the onramp transaction in E.164 format. This phone number must  be verified by your app (via OTP) before being used with the Onramp API.\n\nPlease refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/apple-pay-onramp-api) for more details on phone number verification requirements and best practices.",
    ///      "examples": [
    ///        "+12055555555"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "phoneNumberVerifiedAt": {
    ///      "description": "Timestamp of when the user's phone number was verified via OTP. User phone number must be verified  every 60 days. If this timestamp is older than 60 days, an error will be returned.",
    ///      "examples": [
    ///        "2025-04-24T00:00:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "purchaseAmount": {
    ///      "description": "A string representing the amount of crypto the user wishes to purchase. When using this parameter the  returned quote will be exclusive of fees i.e. the user will receive this exact amount of the purchase  currency.",
    ///      "examples": [
    ///        "10.000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "purchaseCurrency": {
    ///      "description": "The ticker (e.g. `BTC`, `USDC`, `SOL`) or the Coinbase UUID (e.g. `d85dce9b-5b73-5c3c-8978-522ce1d1c1b4`)  of the crypto asset to be purchased.\n\nUse the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported purchase currencies for your user's location.",
    ///      "examples": [
    ///        "USDC"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateOnrampOrderBody {
        ///The timestamp of when the user acknowledged that by using Coinbase Onramp they are accepting the Coinbase Terms  (https://www.coinbase.com/legal/guest-checkout/us), User Agreement (https://www.coinbase.com/legal/user_agreement),  and Privacy Policy (https://www.coinbase.com/legal/privacy).
        #[serde(rename = "agreementAcceptedAt")]
        pub agreement_accepted_at: ::chrono::DateTime<::chrono::offset::Utc>,
        ///The IP address of the end user requesting the onramp transaction.
        #[serde(
            rename = "clientIp",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub client_ip: ::std::option::Option<::std::string::String>,
        ///The address the purchased crypto will be sent to.
        #[serde(rename = "destinationAddress")]
        pub destination_address: ::std::string::String,
        /**The name of the crypto network the purchased currency will be sent on.

        Use the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported networks for your user's location.*/
        #[serde(rename = "destinationNetwork")]
        pub destination_network: ::std::string::String,
        ///The domain that the Apple Pay button will be rendered on. Required when using the `GUEST_CHECKOUT_APPLE_PAY`  payment method and embedding the payment link in an iframe.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub domain: ::std::option::Option<::std::string::String>,
        ///The verified email address of the user requesting the onramp transaction. This email must be verified by your app (via OTP) before being used with the Onramp API.
        pub email: ::std::string::String,
        ///If true, this API will return a quote without creating any transaction.
        #[serde(rename = "isQuote", default)]
        pub is_quote: bool,
        ///Optional partner order reference ID.
        #[serde(
            rename = "partnerOrderRef",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub partner_order_ref: ::std::option::Option<::std::string::String>,
        /**A unique string that represents the user in your app. This can be used to link individual transactions  together so you can retrieve the transaction history for your users. Prefix this string with sandbox-  (e.g. "sandbox-user-1234") to perform a sandbox transaction which will allow you to test your integration  without any real transfer of funds.

        This value can be used with with [Onramp User Transactions API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-onramp-transactions-by-id) to retrieve all transactions created by the user.*/
        #[serde(rename = "partnerUserRef")]
        pub partner_user_ref: ::std::string::String,
        ///A string representing the amount of fiat the user wishes to pay in exchange for crypto. When using  this parameter, the returned quote will be inclusive of fees i.e. the user will pay this exact amount  of the payment currency.
        #[serde(
            rename = "paymentAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_amount: ::std::option::Option<::std::string::String>,
        ///The fiat currency to be converted to crypto.
        #[serde(rename = "paymentCurrency")]
        pub payment_currency: ::std::string::String,
        #[serde(rename = "paymentMethod")]
        pub payment_method: OnrampOrderPaymentMethodTypeId,
        /**The phone number of the user requesting the onramp transaction in E.164 format. This phone number must  be verified by your app (via OTP) before being used with the Onramp API.

        Please refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/apple-pay-onramp-api) for more details on phone number verification requirements and best practices.*/
        #[serde(rename = "phoneNumber")]
        pub phone_number: ::std::string::String,
        ///Timestamp of when the user's phone number was verified via OTP. User phone number must be verified  every 60 days. If this timestamp is older than 60 days, an error will be returned.
        #[serde(rename = "phoneNumberVerifiedAt")]
        pub phone_number_verified_at: ::chrono::DateTime<::chrono::offset::Utc>,
        ///A string representing the amount of crypto the user wishes to purchase. When using this parameter the  returned quote will be exclusive of fees i.e. the user will receive this exact amount of the purchase  currency.
        #[serde(
            rename = "purchaseAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub purchase_amount: ::std::option::Option<::std::string::String>,
        /**The ticker (e.g. `BTC`, `USDC`, `SOL`) or the Coinbase UUID (e.g. `d85dce9b-5b73-5c3c-8978-522ce1d1c1b4`)  of the crypto asset to be purchased.

        Use the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported purchase currencies for your user's location.*/
        #[serde(rename = "purchaseCurrency")]
        pub purchase_currency: ::std::string::String,
    }
    impl ::std::convert::From<&CreateOnrampOrderBody> for CreateOnrampOrderBody {
        fn from(value: &CreateOnrampOrderBody) -> Self {
            value.clone()
        }
    }
    impl CreateOnrampOrderBody {
        pub fn builder() -> builder::CreateOnrampOrderBody {
            Default::default()
        }
    }
    ///`CreateOnrampOrderResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "order"
    ///  ],
    ///  "properties": {
    ///    "order": {
    ///      "$ref": "#/components/schemas/OnrampOrder"
    ///    },
    ///    "paymentLink": {
    ///      "$ref": "#/components/schemas/OnrampPaymentLink"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateOnrampOrderResponse {
        pub order: OnrampOrder,
        #[serde(
            rename = "paymentLink",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_link: ::std::option::Option<OnrampPaymentLink>,
    }
    impl ::std::convert::From<&CreateOnrampOrderResponse> for CreateOnrampOrderResponse {
        fn from(value: &CreateOnrampOrderResponse) -> Self {
            value.clone()
        }
    }
    impl CreateOnrampOrderResponse {
        pub fn builder() -> builder::CreateOnrampOrderResponse {
            Default::default()
        }
    }
    ///`CreateOnrampSessionBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "destinationAddress",
    ///    "destinationNetwork",
    ///    "purchaseCurrency"
    ///  ],
    ///  "properties": {
    ///    "clientIp": {
    ///      "description": "The IP address of the end user requesting the onramp transaction.",
    ///      "examples": [
    ///        "127.0.0.1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "country": {
    ///      "description": "The ISO 3166-1 two letter country code (e.g. US).",
    ///      "examples": [
    ///        "US"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "destinationAddress": {
    ///      "description": "The address the purchased crypto will be sent to.",
    ///      "examples": [
    ///        "0x71C7656EC7ab88b098defB751B7401B5f6d8976F"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "destinationNetwork": {
    ///      "description": "The name of the crypto network the purchased currency will be sent on.\n\nUse the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported networks for your user's location.",
    ///      "examples": [
    ///        "base"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "partnerUserRef": {
    ///      "description": "A unique string that represents the user in your app. This can be used to link individual transactions together so you can retrieve the transaction history for your users. Prefix this string with sandbox-  (e.g. \"sandbox-user-1234\") to perform a sandbox transaction which will allow you to test your integration  without any real transfer of funds.\n\nThis value can be used with with [Onramp User Transactions API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-onramp-transactions-by-id) to retrieve all transactions created by the user.",
    ///      "examples": [
    ///        "user-1234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentAmount": {
    ///      "description": "A string representing the amount of fiat the user wishes to pay in exchange for crypto.",
    ///      "examples": [
    ///        "100.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentCurrency": {
    ///      "description": "The fiat currency to be converted to crypto.",
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentMethod": {
    ///      "$ref": "#/components/schemas/OnrampQuotePaymentMethodTypeId"
    ///    },
    ///    "purchaseCurrency": {
    ///      "description": "The ticker (e.g. `BTC`, `USDC`, `SOL`) or the Coinbase UUID (e.g. `d85dce9b-5b73-5c3c-8978-522ce1d1c1b4`)  of the crypto asset to be purchased.\n\nUse the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported purchase currencies for your user's location.",
    ///      "examples": [
    ///        "USDC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "redirectUrl": {
    ///      "description": "URI to redirect the user to when they successfully complete a transaction. This URI will be embedded in the returned onramp URI as a query parameter.",
    ///      "examples": [
    ///        "https://example.com/success"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Uri"
    ///        }
    ///      ]
    ///    },
    ///    "subdivision": {
    ///      "description": "The ISO 3166-2 two letter state code (e.g. NY). Only required for US.",
    ///      "examples": [
    ///        "NY"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateOnrampSessionBody {
        ///The IP address of the end user requesting the onramp transaction.
        #[serde(
            rename = "clientIp",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub client_ip: ::std::option::Option<::std::string::String>,
        ///The ISO 3166-1 two letter country code (e.g. US).
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub country: ::std::option::Option<::std::string::String>,
        ///The address the purchased crypto will be sent to.
        #[serde(rename = "destinationAddress")]
        pub destination_address: ::std::string::String,
        /**The name of the crypto network the purchased currency will be sent on.

        Use the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported networks for your user's location.*/
        #[serde(rename = "destinationNetwork")]
        pub destination_network: ::std::string::String,
        /**A unique string that represents the user in your app. This can be used to link individual transactions together so you can retrieve the transaction history for your users. Prefix this string with sandbox-  (e.g. "sandbox-user-1234") to perform a sandbox transaction which will allow you to test your integration  without any real transfer of funds.

        This value can be used with with [Onramp User Transactions API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-onramp-transactions-by-id) to retrieve all transactions created by the user.*/
        #[serde(
            rename = "partnerUserRef",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub partner_user_ref: ::std::option::Option<::std::string::String>,
        ///A string representing the amount of fiat the user wishes to pay in exchange for crypto.
        #[serde(
            rename = "paymentAmount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_amount: ::std::option::Option<::std::string::String>,
        ///The fiat currency to be converted to crypto.
        #[serde(
            rename = "paymentCurrency",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_currency: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "paymentMethod",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub payment_method: ::std::option::Option<OnrampQuotePaymentMethodTypeId>,
        /**The ticker (e.g. `BTC`, `USDC`, `SOL`) or the Coinbase UUID (e.g. `d85dce9b-5b73-5c3c-8978-522ce1d1c1b4`)  of the crypto asset to be purchased.

        Use the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported purchase currencies for your user's location.*/
        #[serde(rename = "purchaseCurrency")]
        pub purchase_currency: ::std::string::String,
        ///URI to redirect the user to when they successfully complete a transaction. This URI will be embedded in the returned onramp URI as a query parameter.
        #[serde(
            rename = "redirectUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub redirect_url: ::std::option::Option<Uri>,
        ///The ISO 3166-2 two letter state code (e.g. NY). Only required for US.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subdivision: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&CreateOnrampSessionBody> for CreateOnrampSessionBody {
        fn from(value: &CreateOnrampSessionBody) -> Self {
            value.clone()
        }
    }
    impl CreateOnrampSessionBody {
        pub fn builder() -> builder::CreateOnrampSessionBody {
            Default::default()
        }
    }
    ///`CreateOnrampSessionResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "session"
    ///  ],
    ///  "properties": {
    ///    "quote": {
    ///      "$ref": "#/components/schemas/OnrampQuote"
    ///    },
    ///    "session": {
    ///      "$ref": "#/components/schemas/OnrampSession"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateOnrampSessionResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub quote: ::std::option::Option<OnrampQuote>,
        pub session: OnrampSession,
    }
    impl ::std::convert::From<&CreateOnrampSessionResponse> for CreateOnrampSessionResponse {
        fn from(value: &CreateOnrampSessionResponse) -> Self {
            value.clone()
        }
    }
    impl CreateOnrampSessionResponse {
        pub fn builder() -> builder::CreateOnrampSessionResponse {
            Default::default()
        }
    }
    ///`CreatePolicyBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rules",
    ///    "scope"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "An optional human-readable description for the policy.\nPolicy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.",
    ///      "examples": [
    ///        "Default policy"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[A-Za-z0-9 ,.]{1,50}$"
    ///    },
    ///    "rules": {
    ///      "description": "A list of rules that comprise the policy. There is a limit of 10 rules per policy.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Rule"
    ///      }
    ///    },
    ///    "scope": {
    ///      "description": "The scope of the policy.",
    ///      "examples": [
    ///        "project"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "project",
    ///        "account"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreatePolicyBody {
        /**An optional human-readable description for the policy.
        Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<CreatePolicyBodyDescription>,
        ///A list of rules that comprise the policy. There is a limit of 10 rules per policy.
        pub rules: ::std::vec::Vec<Rule>,
        ///The scope of the policy.
        pub scope: CreatePolicyBodyScope,
    }
    impl ::std::convert::From<&CreatePolicyBody> for CreatePolicyBody {
        fn from(value: &CreatePolicyBody) -> Self {
            value.clone()
        }
    }
    impl CreatePolicyBody {
        pub fn builder() -> builder::CreatePolicyBody {
            Default::default()
        }
    }
    /**An optional human-readable description for the policy.
    Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An optional human-readable description for the policy.\nPolicy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.",
    ///  "examples": [
    ///    "Default policy"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[A-Za-z0-9 ,.]{1,50}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreatePolicyBodyDescription(::std::string::String);
    impl ::std::ops::Deref for CreatePolicyBodyDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreatePolicyBodyDescription> for ::std::string::String {
        fn from(value: CreatePolicyBodyDescription) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreatePolicyBodyDescription> for CreatePolicyBodyDescription {
        fn from(value: &CreatePolicyBodyDescription) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreatePolicyBodyDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[A-Za-z0-9 ,.]{1,50}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[A-Za-z0-9 ,.]{1,50}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreatePolicyBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreatePolicyBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreatePolicyBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreatePolicyBodyDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The scope of the policy.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The scope of the policy.",
    ///  "examples": [
    ///    "project"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "project",
    ///    "account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreatePolicyBodyScope {
        #[serde(rename = "project")]
        Project,
        #[serde(rename = "account")]
        Account,
    }
    impl ::std::convert::From<&Self> for CreatePolicyBodyScope {
        fn from(value: &CreatePolicyBodyScope) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for CreatePolicyBodyScope {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Project => f.write_str("project"),
                Self::Account => f.write_str("account"),
            }
        }
    }
    impl ::std::str::FromStr for CreatePolicyBodyScope {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "project" => Ok(Self::Project),
                "account" => Ok(Self::Account),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for CreatePolicyBodyScope {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreatePolicyBodyScope {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreatePolicyBodyScope {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`CreatePolicyXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreatePolicyXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for CreatePolicyXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreatePolicyXIdempotencyKey> for ::std::string::String {
        fn from(value: CreatePolicyXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreatePolicyXIdempotencyKey> for CreatePolicyXIdempotencyKey {
        fn from(value: &CreatePolicyXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreatePolicyXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreatePolicyXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreatePolicyXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreatePolicyXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreatePolicyXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateSolanaAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "accountPolicy": {
    ///      "description": "The ID of the account-level policy to apply to the account.",
    ///      "examples": [
    ///        "123e4567-e89b-12d3-a456-426614174000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
    ///      "x-audience": "public"
    ///    },
    ///    "name": {
    ///      "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all Solana accounts in the developer's CDP Project.",
    ///      "examples": [
    ///        "my-wallet"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateSolanaAccountBody {
        ///The ID of the account-level policy to apply to the account.
        #[serde(
            rename = "accountPolicy",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub account_policy: ::std::option::Option<CreateSolanaAccountBodyAccountPolicy>,
        /**An optional name for the account.
        Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
        Account names must be unique across all Solana accounts in the developer's CDP Project.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<CreateSolanaAccountBodyName>,
    }
    impl ::std::convert::From<&CreateSolanaAccountBody> for CreateSolanaAccountBody {
        fn from(value: &CreateSolanaAccountBody) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for CreateSolanaAccountBody {
        fn default() -> Self {
            Self {
                account_policy: Default::default(),
                name: Default::default(),
            }
        }
    }
    impl CreateSolanaAccountBody {
        pub fn builder() -> builder::CreateSolanaAccountBody {
            Default::default()
        }
    }
    ///The ID of the account-level policy to apply to the account.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The ID of the account-level policy to apply to the account.",
    ///  "examples": [
    ///    "123e4567-e89b-12d3-a456-426614174000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSolanaAccountBodyAccountPolicy(::std::string::String);
    impl ::std::ops::Deref for CreateSolanaAccountBodyAccountPolicy {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSolanaAccountBodyAccountPolicy> for ::std::string::String {
        fn from(value: CreateSolanaAccountBodyAccountPolicy) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSolanaAccountBodyAccountPolicy>
        for CreateSolanaAccountBodyAccountPolicy
    {
        fn from(value: &CreateSolanaAccountBodyAccountPolicy) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSolanaAccountBodyAccountPolicy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(
                || {
                    ::regress::Regex::new(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
                    )
                    .unwrap()
                },
            );
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSolanaAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSolanaAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSolanaAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSolanaAccountBodyAccountPolicy {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    /**An optional name for the account.
    Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
    Account names must be unique across all Solana accounts in the developer's CDP Project.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all Solana accounts in the developer's CDP Project.",
    ///  "examples": [
    ///    "my-wallet"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSolanaAccountBodyName(::std::string::String);
    impl ::std::ops::Deref for CreateSolanaAccountBodyName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSolanaAccountBodyName> for ::std::string::String {
        fn from(value: CreateSolanaAccountBodyName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSolanaAccountBodyName> for CreateSolanaAccountBodyName {
        fn from(value: &CreateSolanaAccountBodyName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSolanaAccountBodyName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSolanaAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSolanaAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSolanaAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSolanaAccountBodyName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateSolanaAccountXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSolanaAccountXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for CreateSolanaAccountXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSolanaAccountXIdempotencyKey> for ::std::string::String {
        fn from(value: CreateSolanaAccountXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSolanaAccountXIdempotencyKey>
        for CreateSolanaAccountXIdempotencyKey
    {
        fn from(value: &CreateSolanaAccountXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSolanaAccountXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSolanaAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSolanaAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSolanaAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSolanaAccountXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateSpendPermissionAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSpendPermissionAddress(::std::string::String);
    impl ::std::ops::Deref for CreateSpendPermissionAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSpendPermissionAddress> for ::std::string::String {
        fn from(value: CreateSpendPermissionAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSpendPermissionAddress> for CreateSpendPermissionAddress {
        fn from(value: &CreateSpendPermissionAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSpendPermissionAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSpendPermissionAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSpendPermissionAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSpendPermissionAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSpendPermissionAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///Request parameters for creating a Spend Permission.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request parameters for creating a Spend Permission.",
    ///  "type": "object",
    ///  "required": [
    ///    "allowance",
    ///    "end",
    ///    "network",
    ///    "period",
    ///    "spender",
    ///    "start",
    ///    "token"
    ///  ],
    ///  "properties": {
    ///    "allowance": {
    ///      "description": "Maximum allowed value to spend, in atomic units for the specified token, within each period.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "end": {
    ///      "description": "The expiration time for this spend permission, in Unix seconds.",
    ///      "examples": [
    ///        "281474976710655"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "extraData": {
    ///      "description": "Arbitrary data to include in the permission.",
    ///      "examples": [
    ///        "0x"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "network": {
    ///      "$ref": "#/components/schemas/SpendPermissionNetwork"
    ///    },
    ///    "paymasterUrl": {
    ///      "description": "The paymaster URL of the spend permission.",
    ///      "examples": [
    ///        "https://paymaster.cdp.coinbase.com"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Url"
    ///        }
    ///      ]
    ///    },
    ///    "period": {
    ///      "description": "Time duration for resetting used allowance on a recurring basis (seconds).",
    ///      "examples": [
    ///        "86400"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "salt": {
    ///      "description": "An arbitrary salt to differentiate unique spend permissions with otherwise identical data.",
    ///      "examples": [
    ///        "95959551014433038874972658238091428449162862973207257628575040053304171156143"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "spender": {
    ///      "description": "Entity that can spend account's tokens. Can be either a Smart Account or an EOA.",
    ///      "examples": [
    ///        "0x9Fb909eA400c2b8D99Be292DADf07e63B814527c"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    },
    ///    "start": {
    ///      "description": "The start time for this spend permission, in Unix seconds.",
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "token": {
    ///      "description": "ERC-7528 native token address (e.g. \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" for native ETH), or an  ERC-20 contract address.",
    ///      "examples": [
    ///        "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateSpendPermissionRequest {
        ///Maximum allowed value to spend, in atomic units for the specified token, within each period.
        pub allowance: ::std::string::String,
        ///The expiration time for this spend permission, in Unix seconds.
        pub end: ::std::string::String,
        ///Arbitrary data to include in the permission.
        #[serde(
            rename = "extraData",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub extra_data: ::std::option::Option<::std::string::String>,
        pub network: SpendPermissionNetwork,
        ///The paymaster URL of the spend permission.
        #[serde(
            rename = "paymasterUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paymaster_url: ::std::option::Option<Url>,
        ///Time duration for resetting used allowance on a recurring basis (seconds).
        pub period: ::std::string::String,
        ///An arbitrary salt to differentiate unique spend permissions with otherwise identical data.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub salt: ::std::option::Option<::std::string::String>,
        ///Entity that can spend account's tokens. Can be either a Smart Account or an EOA.
        pub spender: CreateSpendPermissionRequestSpender,
        ///The start time for this spend permission, in Unix seconds.
        pub start: ::std::string::String,
        ///ERC-7528 native token address (e.g. "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE" for native ETH), or an  ERC-20 contract address.
        pub token: CreateSpendPermissionRequestToken,
    }
    impl ::std::convert::From<&CreateSpendPermissionRequest> for CreateSpendPermissionRequest {
        fn from(value: &CreateSpendPermissionRequest) -> Self {
            value.clone()
        }
    }
    impl CreateSpendPermissionRequest {
        pub fn builder() -> builder::CreateSpendPermissionRequest {
            Default::default()
        }
    }
    ///Entity that can spend account's tokens. Can be either a Smart Account or an EOA.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Entity that can spend account's tokens. Can be either a Smart Account or an EOA.",
    ///  "examples": [
    ///    "0x9Fb909eA400c2b8D99Be292DADf07e63B814527c"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSpendPermissionRequestSpender(::std::string::String);
    impl ::std::ops::Deref for CreateSpendPermissionRequestSpender {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSpendPermissionRequestSpender> for ::std::string::String {
        fn from(value: CreateSpendPermissionRequestSpender) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSpendPermissionRequestSpender>
        for CreateSpendPermissionRequestSpender
    {
        fn from(value: &CreateSpendPermissionRequestSpender) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSpendPermissionRequestSpender {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSpendPermissionRequestSpender {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSpendPermissionRequestSpender {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSpendPermissionRequestSpender {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSpendPermissionRequestSpender {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///ERC-7528 native token address (e.g. "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE" for native ETH), or an  ERC-20 contract address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "ERC-7528 native token address (e.g. \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" for native ETH), or an  ERC-20 contract address.",
    ///  "examples": [
    ///    "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSpendPermissionRequestToken(::std::string::String);
    impl ::std::ops::Deref for CreateSpendPermissionRequestToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSpendPermissionRequestToken> for ::std::string::String {
        fn from(value: CreateSpendPermissionRequestToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSpendPermissionRequestToken>
        for CreateSpendPermissionRequestToken
    {
        fn from(value: &CreateSpendPermissionRequestToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSpendPermissionRequestToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSpendPermissionRequestToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSpendPermissionRequestToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSpendPermissionRequestToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSpendPermissionRequestToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateSpendPermissionXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSpendPermissionXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for CreateSpendPermissionXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSpendPermissionXIdempotencyKey> for ::std::string::String {
        fn from(value: CreateSpendPermissionXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSpendPermissionXIdempotencyKey>
        for CreateSpendPermissionXIdempotencyKey
    {
        fn from(value: &CreateSpendPermissionXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSpendPermissionXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSpendPermissionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSpendPermissionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSpendPermissionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSpendPermissionXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`CreateSwapQuoteResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "CreateSwapQuoteResponse",
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "permit2",
    ///        "transaction"
    ///      ],
    ///      "properties": {
    ///        "permit2": {
    ///          "description": "The approval object which contains the necessary fields to submit an approval for this transaction. Null if the `fromToken` is the native token or the transaction is a native token wrap / unwrap.",
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "required": [
    ///            "eip712",
    ///            "hash"
    ///          ],
    ///          "properties": {
    ///            "eip712": {
    ///              "$ref": "#/components/schemas/EIP712Message"
    ///            },
    ///            "hash": {
    ///              "description": "The hash for the approval according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). Computing the hash of the `eip712` field should match the value of this field.",
    ///              "examples": [
    ///                "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ///              ],
    ///              "type": "string",
    ///              "pattern": "^0x[a-fA-F0-9]{64}$"
    ///            }
    ///          }
    ///        },
    ///        "transaction": {
    ///          "description": "The details of the transaction to be signed and submitted to execute the swap.",
    ///          "type": "object",
    ///          "required": [
    ///            "data",
    ///            "gas",
    ///            "gasPrice",
    ///            "to",
    ///            "value"
    ///          ],
    ///          "properties": {
    ///            "data": {
    ///              "description": "The hex-encoded call data to send to the contract.",
    ///              "examples": [
    ///                "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "gas": {
    ///              "description": "The estimated gas limit that should be used to send the transaction to guarantee settlement.",
    ///              "examples": [
    ///                "100000"
    ///              ],
    ///              "type": "string",
    ///              "pattern": "^\\d+$"
    ///            },
    ///            "gasPrice": {
    ///              "description": "The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.",
    ///              "examples": [
    ///                "1000000000"
    ///              ],
    ///              "type": "string",
    ///              "pattern": "^\\d+$"
    ///            },
    ///            "to": {
    ///              "description": "The 0x-prefixed address of the contract to call.",
    ///              "examples": [
    ///                "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///              ],
    ///              "type": "string",
    ///              "pattern": "^0x[a-fA-F0-9]{40}$"
    ///            },
    ///            "value": {
    ///              "description": "The value of the transaction in Wei.",
    ///              "examples": [
    ///                "1000000000000000000"
    ///              ],
    ///              "type": "string",
    ///              "pattern": "^\\d+$"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CommonSwapResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateSwapQuoteResponse {
        ///The block number at which the liquidity conditions were examined.
        #[serde(rename = "blockNumber")]
        pub block_number: CreateSwapQuoteResponseBlockNumber,
        pub fees: CreateSwapQuoteResponseFees,
        ///The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
        #[serde(rename = "fromAmount")]
        pub from_amount: CreateSwapQuoteResponseFromAmount,
        ///The 0x-prefixed contract address of the token that will be sent.
        #[serde(rename = "fromToken")]
        pub from_token: CreateSwapQuoteResponseFromToken,
        pub issues: CreateSwapQuoteResponseIssues,
        ///Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
        #[serde(rename = "liquidityAvailable")]
        pub liquidity_available: bool,
        ///The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
        #[serde(rename = "minToAmount")]
        pub min_to_amount: CreateSwapQuoteResponseMinToAmount,
        ///The approval object which contains the necessary fields to submit an approval for this transaction. Null if the `fromToken` is the native token or the transaction is a native token wrap / unwrap.
        pub permit2: ::std::option::Option<CreateSwapQuoteResponsePermit2>,
        ///The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
        #[serde(rename = "toAmount")]
        pub to_amount: CreateSwapQuoteResponseToAmount,
        ///The 0x-prefixed contract address of the token that will be received.
        #[serde(rename = "toToken")]
        pub to_token: CreateSwapQuoteResponseToToken,
        pub transaction: CreateSwapQuoteResponseTransaction,
    }
    impl ::std::convert::From<&CreateSwapQuoteResponse> for CreateSwapQuoteResponse {
        fn from(value: &CreateSwapQuoteResponse) -> Self {
            value.clone()
        }
    }
    impl CreateSwapQuoteResponse {
        pub fn builder() -> builder::CreateSwapQuoteResponse {
            Default::default()
        }
    }
    ///The block number at which the liquidity conditions were examined.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The block number at which the liquidity conditions were examined.",
    ///  "examples": [
    ///    "17038723"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[1-9]\\d*$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseBlockNumber(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseBlockNumber {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseBlockNumber> for ::std::string::String {
        fn from(value: CreateSwapQuoteResponseBlockNumber) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseBlockNumber>
        for CreateSwapQuoteResponseBlockNumber
    {
        fn from(value: &CreateSwapQuoteResponseBlockNumber) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseBlockNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^[1-9]\\d*$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9]\\d*$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseBlockNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSwapQuoteResponseBlockNumber {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSwapQuoteResponseBlockNumber {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseBlockNumber {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The estimated fees for the swap.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The estimated fees for the swap.",
    ///  "examples": [
    ///    {
    ///      "gasFee": {
    ///        "amount": "1000000000000000000",
    ///        "token": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///      },
    ///      "protocolFee": {
    ///        "amount": "1000000000000000000",
    ///        "token": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "gasFee",
    ///    "protocolFee"
    ///  ],
    ///  "properties": {
    ///    "gasFee": {
    ///      "description": "The estimated gas fee for the swap.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/TokenFee"
    ///        }
    ///      ]
    ///    },
    ///    "protocolFee": {
    ///      "description": "The estimated protocol fee for the swap.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/TokenFee"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateSwapQuoteResponseFees {
        ///The estimated gas fee for the swap.
        #[serde(rename = "gasFee")]
        pub gas_fee: ::std::option::Option<TokenFee>,
        ///The estimated protocol fee for the swap.
        #[serde(rename = "protocolFee")]
        pub protocol_fee: ::std::option::Option<TokenFee>,
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseFees> for CreateSwapQuoteResponseFees {
        fn from(value: &CreateSwapQuoteResponseFees) -> Self {
            value.clone()
        }
    }
    impl CreateSwapQuoteResponseFees {
        pub fn builder() -> builder::CreateSwapQuoteResponseFees {
            Default::default()
        }
    }
    ///The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0|[1-9]\\d*)$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseFromAmount(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseFromAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseFromAmount> for ::std::string::String {
        fn from(value: CreateSwapQuoteResponseFromAmount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseFromAmount>
        for CreateSwapQuoteResponseFromAmount
    {
        fn from(value: &CreateSwapQuoteResponseFromAmount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseFromAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(0|[1-9]\\d*)$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^(0|[1-9]\\d*)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseFromAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSwapQuoteResponseFromAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSwapQuoteResponseFromAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseFromAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed contract address of the token that will be sent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed contract address of the token that will be sent.",
    ///  "examples": [
    ///    "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseFromToken(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseFromToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseFromToken> for ::std::string::String {
        fn from(value: CreateSwapQuoteResponseFromToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseFromToken> for CreateSwapQuoteResponseFromToken {
        fn from(value: &CreateSwapQuoteResponseFromToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseFromToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseFromToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSwapQuoteResponseFromToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSwapQuoteResponseFromToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseFromToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.",
    ///  "examples": [
    ///    {
    ///      "allowance": {
    ///        "currentAllowance": "1000000000",
    ///        "spender": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///      },
    ///      "balance": {
    ///        "currentBalance": "900000000000000000",
    ///        "requiredBalance": "1000000000000000000",
    ///        "token": "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///      },
    ///      "simulationIncomplete": false
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "allowance",
    ///    "balance",
    ///    "simulationIncomplete"
    ///  ],
    ///  "properties": {
    ///    "allowance": {
    ///      "description": "Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.",
    ///      "examples": [
    ///        {
    ///          "currentAllowance": "1000000000",
    ///          "spender": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///        }
    ///      ],
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "required": [
    ///        "currentAllowance",
    ///        "spender"
    ///      ],
    ///      "properties": {
    ///        "currentAllowance": {
    ///          "description": "The current allowance of the `fromToken` by the `taker`.",
    ///          "examples": [
    ///            "1000000000"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^\\d+$"
    ///        },
    ///        "spender": {
    ///          "description": "The 0x-prefixed address of to set the allowance on.",
    ///          "examples": [
    ///            "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^0x[a-fA-F0-9]{40}$"
    ///        }
    ///      }
    ///    },
    ///    "balance": {
    ///      "description": "Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.",
    ///      "examples": [
    ///        {
    ///          "currentBalance": "1000000000000000000",
    ///          "requiredBalance": "1000000000000000000",
    ///          "token": "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///        }
    ///      ],
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "required": [
    ///        "currentBalance",
    ///        "requiredBalance",
    ///        "token"
    ///      ],
    ///      "properties": {
    ///        "currentBalance": {
    ///          "description": "The current balance of the `fromToken` by the `taker`.",
    ///          "examples": [
    ///            "10000000"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^\\d+$"
    ///        },
    ///        "requiredBalance": {
    ///          "description": "The amount of the token that the `taker` must hold.",
    ///          "examples": [
    ///            "1000000000000000000"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^\\d+$"
    ///        },
    ///        "token": {
    ///          "description": "The 0x-prefixed contract address of the token.",
    ///          "type": "string",
    ///          "pattern": "^0x[a-fA-F0-9]{40}$"
    ///        }
    ///      }
    ///    },
    ///    "simulationIncomplete": {
    ///      "description": "This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateSwapQuoteResponseIssues {
        ///Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
        pub allowance: ::std::option::Option<CreateSwapQuoteResponseIssuesAllowance>,
        ///Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
        pub balance: ::std::option::Option<CreateSwapQuoteResponseIssuesBalance>,
        ///This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.
        #[serde(rename = "simulationIncomplete")]
        pub simulation_incomplete: bool,
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseIssues> for CreateSwapQuoteResponseIssues {
        fn from(value: &CreateSwapQuoteResponseIssues) -> Self {
            value.clone()
        }
    }
    impl CreateSwapQuoteResponseIssues {
        pub fn builder() -> builder::CreateSwapQuoteResponseIssues {
            Default::default()
        }
    }
    ///Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.",
    ///  "examples": [
    ///    {
    ///      "currentAllowance": "1000000000",
    ///      "spender": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "currentAllowance",
    ///    "spender"
    ///  ],
    ///  "properties": {
    ///    "currentAllowance": {
    ///      "description": "The current allowance of the `fromToken` by the `taker`.",
    ///      "examples": [
    ///        "1000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    },
    ///    "spender": {
    ///      "description": "The 0x-prefixed address of to set the allowance on.",
    ///      "examples": [
    ///        "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateSwapQuoteResponseIssuesAllowance {
        ///The current allowance of the `fromToken` by the `taker`.
        #[serde(rename = "currentAllowance")]
        pub current_allowance: CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance,
        ///The 0x-prefixed address of to set the allowance on.
        pub spender: CreateSwapQuoteResponseIssuesAllowanceSpender,
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseIssuesAllowance>
        for CreateSwapQuoteResponseIssuesAllowance
    {
        fn from(value: &CreateSwapQuoteResponseIssuesAllowance) -> Self {
            value.clone()
        }
    }
    impl CreateSwapQuoteResponseIssuesAllowance {
        pub fn builder() -> builder::CreateSwapQuoteResponseIssuesAllowance {
            Default::default()
        }
    }
    ///The current allowance of the `fromToken` by the `taker`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The current allowance of the `fromToken` by the `taker`.",
    ///  "examples": [
    ///    "1000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance>
        for ::std::string::String
    {
        fn from(value: CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance>
        for CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance
    {
        fn from(value: &CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed address of to set the allowance on.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed address of to set the allowance on.",
    ///  "examples": [
    ///    "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseIssuesAllowanceSpender(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseIssuesAllowanceSpender {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseIssuesAllowanceSpender> for ::std::string::String {
        fn from(value: CreateSwapQuoteResponseIssuesAllowanceSpender) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseIssuesAllowanceSpender>
        for CreateSwapQuoteResponseIssuesAllowanceSpender
    {
        fn from(value: &CreateSwapQuoteResponseIssuesAllowanceSpender) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseIssuesAllowanceSpender {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseIssuesAllowanceSpender {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateSwapQuoteResponseIssuesAllowanceSpender
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateSwapQuoteResponseIssuesAllowanceSpender
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseIssuesAllowanceSpender {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.",
    ///  "examples": [
    ///    {
    ///      "currentBalance": "1000000000000000000",
    ///      "requiredBalance": "1000000000000000000",
    ///      "token": "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "currentBalance",
    ///    "requiredBalance",
    ///    "token"
    ///  ],
    ///  "properties": {
    ///    "currentBalance": {
    ///      "description": "The current balance of the `fromToken` by the `taker`.",
    ///      "examples": [
    ///        "10000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    },
    ///    "requiredBalance": {
    ///      "description": "The amount of the token that the `taker` must hold.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    },
    ///    "token": {
    ///      "description": "The 0x-prefixed contract address of the token.",
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateSwapQuoteResponseIssuesBalance {
        ///The current balance of the `fromToken` by the `taker`.
        #[serde(rename = "currentBalance")]
        pub current_balance: CreateSwapQuoteResponseIssuesBalanceCurrentBalance,
        ///The amount of the token that the `taker` must hold.
        #[serde(rename = "requiredBalance")]
        pub required_balance: CreateSwapQuoteResponseIssuesBalanceRequiredBalance,
        ///The 0x-prefixed contract address of the token.
        pub token: CreateSwapQuoteResponseIssuesBalanceToken,
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseIssuesBalance>
        for CreateSwapQuoteResponseIssuesBalance
    {
        fn from(value: &CreateSwapQuoteResponseIssuesBalance) -> Self {
            value.clone()
        }
    }
    impl CreateSwapQuoteResponseIssuesBalance {
        pub fn builder() -> builder::CreateSwapQuoteResponseIssuesBalance {
            Default::default()
        }
    }
    ///The current balance of the `fromToken` by the `taker`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The current balance of the `fromToken` by the `taker`.",
    ///  "examples": [
    ///    "10000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseIssuesBalanceCurrentBalance(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseIssuesBalanceCurrentBalance {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseIssuesBalanceCurrentBalance>
        for ::std::string::String
    {
        fn from(value: CreateSwapQuoteResponseIssuesBalanceCurrentBalance) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseIssuesBalanceCurrentBalance>
        for CreateSwapQuoteResponseIssuesBalanceCurrentBalance
    {
        fn from(value: &CreateSwapQuoteResponseIssuesBalanceCurrentBalance) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseIssuesBalanceCurrentBalance {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseIssuesBalanceCurrentBalance {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateSwapQuoteResponseIssuesBalanceCurrentBalance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateSwapQuoteResponseIssuesBalanceCurrentBalance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseIssuesBalanceCurrentBalance {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The amount of the token that the `taker` must hold.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount of the token that the `taker` must hold.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseIssuesBalanceRequiredBalance(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseIssuesBalanceRequiredBalance {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseIssuesBalanceRequiredBalance>
        for ::std::string::String
    {
        fn from(value: CreateSwapQuoteResponseIssuesBalanceRequiredBalance) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseIssuesBalanceRequiredBalance>
        for CreateSwapQuoteResponseIssuesBalanceRequiredBalance
    {
        fn from(value: &CreateSwapQuoteResponseIssuesBalanceRequiredBalance) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseIssuesBalanceRequiredBalance {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseIssuesBalanceRequiredBalance {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateSwapQuoteResponseIssuesBalanceRequiredBalance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateSwapQuoteResponseIssuesBalanceRequiredBalance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseIssuesBalanceRequiredBalance {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed contract address of the token.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed contract address of the token.",
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseIssuesBalanceToken(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseIssuesBalanceToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseIssuesBalanceToken> for ::std::string::String {
        fn from(value: CreateSwapQuoteResponseIssuesBalanceToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseIssuesBalanceToken>
        for CreateSwapQuoteResponseIssuesBalanceToken
    {
        fn from(value: &CreateSwapQuoteResponseIssuesBalanceToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseIssuesBalanceToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseIssuesBalanceToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSwapQuoteResponseIssuesBalanceToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSwapQuoteResponseIssuesBalanceToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseIssuesBalanceToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.",
    ///  "examples": [
    ///    "900000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0|[1-9]\\d*)$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseMinToAmount(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseMinToAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseMinToAmount> for ::std::string::String {
        fn from(value: CreateSwapQuoteResponseMinToAmount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseMinToAmount>
        for CreateSwapQuoteResponseMinToAmount
    {
        fn from(value: &CreateSwapQuoteResponseMinToAmount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseMinToAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(0|[1-9]\\d*)$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^(0|[1-9]\\d*)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseMinToAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSwapQuoteResponseMinToAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSwapQuoteResponseMinToAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseMinToAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The approval object which contains the necessary fields to submit an approval for this transaction. Null if the `fromToken` is the native token or the transaction is a native token wrap / unwrap.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The approval object which contains the necessary fields to submit an approval for this transaction. Null if the `fromToken` is the native token or the transaction is a native token wrap / unwrap.",
    ///  "type": "object",
    ///  "required": [
    ///    "eip712",
    ///    "hash"
    ///  ],
    ///  "properties": {
    ///    "eip712": {
    ///      "$ref": "#/components/schemas/EIP712Message"
    ///    },
    ///    "hash": {
    ///      "description": "The hash for the approval according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). Computing the hash of the `eip712` field should match the value of this field.",
    ///      "examples": [
    ///        "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{64}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateSwapQuoteResponsePermit2 {
        pub eip712: Eip712Message,
        ///The hash for the approval according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). Computing the hash of the `eip712` field should match the value of this field.
        pub hash: CreateSwapQuoteResponsePermit2Hash,
    }
    impl ::std::convert::From<&CreateSwapQuoteResponsePermit2> for CreateSwapQuoteResponsePermit2 {
        fn from(value: &CreateSwapQuoteResponsePermit2) -> Self {
            value.clone()
        }
    }
    impl CreateSwapQuoteResponsePermit2 {
        pub fn builder() -> builder::CreateSwapQuoteResponsePermit2 {
            Default::default()
        }
    }
    ///The hash for the approval according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). Computing the hash of the `eip712` field should match the value of this field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The hash for the approval according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). Computing the hash of the `eip712` field should match the value of this field.",
    ///  "examples": [
    ///    "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{64}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponsePermit2Hash(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponsePermit2Hash {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponsePermit2Hash> for ::std::string::String {
        fn from(value: CreateSwapQuoteResponsePermit2Hash) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponsePermit2Hash>
        for CreateSwapQuoteResponsePermit2Hash
    {
        fn from(value: &CreateSwapQuoteResponsePermit2Hash) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponsePermit2Hash {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{64}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponsePermit2Hash {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSwapQuoteResponsePermit2Hash {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSwapQuoteResponsePermit2Hash {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponsePermit2Hash {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0|[1-9]\\d*)$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseToAmount(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseToAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseToAmount> for ::std::string::String {
        fn from(value: CreateSwapQuoteResponseToAmount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseToAmount> for CreateSwapQuoteResponseToAmount {
        fn from(value: &CreateSwapQuoteResponseToAmount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseToAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(0|[1-9]\\d*)$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^(0|[1-9]\\d*)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseToAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSwapQuoteResponseToAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSwapQuoteResponseToAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseToAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed contract address of the token that will be received.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed contract address of the token that will be received.",
    ///  "examples": [
    ///    "0x7F5c764cBc14f9669B88837ca1490cCa17c31607"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseToToken(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseToToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseToToken> for ::std::string::String {
        fn from(value: CreateSwapQuoteResponseToToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseToToken> for CreateSwapQuoteResponseToToken {
        fn from(value: &CreateSwapQuoteResponseToToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseToToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseToToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSwapQuoteResponseToToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSwapQuoteResponseToToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseToToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The details of the transaction to be signed and submitted to execute the swap.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The details of the transaction to be signed and submitted to execute the swap.",
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "gas",
    ///    "gasPrice",
    ///    "to",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "description": "The hex-encoded call data to send to the contract.",
    ///      "examples": [
    ///        "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "gas": {
    ///      "description": "The estimated gas limit that should be used to send the transaction to guarantee settlement.",
    ///      "examples": [
    ///        "100000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    },
    ///    "gasPrice": {
    ///      "description": "The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.",
    ///      "examples": [
    ///        "1000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    },
    ///    "to": {
    ///      "description": "The 0x-prefixed address of the contract to call.",
    ///      "examples": [
    ///        "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    },
    ///    "value": {
    ///      "description": "The value of the transaction in Wei.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateSwapQuoteResponseTransaction {
        ///The hex-encoded call data to send to the contract.
        pub data: ::std::string::String,
        ///The estimated gas limit that should be used to send the transaction to guarantee settlement.
        pub gas: CreateSwapQuoteResponseTransactionGas,
        ///The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.
        #[serde(rename = "gasPrice")]
        pub gas_price: CreateSwapQuoteResponseTransactionGasPrice,
        ///The 0x-prefixed address of the contract to call.
        pub to: CreateSwapQuoteResponseTransactionTo,
        ///The value of the transaction in Wei.
        pub value: CreateSwapQuoteResponseTransactionValue,
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseTransaction>
        for CreateSwapQuoteResponseTransaction
    {
        fn from(value: &CreateSwapQuoteResponseTransaction) -> Self {
            value.clone()
        }
    }
    impl CreateSwapQuoteResponseTransaction {
        pub fn builder() -> builder::CreateSwapQuoteResponseTransaction {
            Default::default()
        }
    }
    ///The estimated gas limit that should be used to send the transaction to guarantee settlement.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The estimated gas limit that should be used to send the transaction to guarantee settlement.",
    ///  "examples": [
    ///    "100000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseTransactionGas(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseTransactionGas {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseTransactionGas> for ::std::string::String {
        fn from(value: CreateSwapQuoteResponseTransactionGas) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseTransactionGas>
        for CreateSwapQuoteResponseTransactionGas
    {
        fn from(value: &CreateSwapQuoteResponseTransactionGas) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseTransactionGas {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseTransactionGas {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSwapQuoteResponseTransactionGas {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSwapQuoteResponseTransactionGas {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseTransactionGas {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.",
    ///  "examples": [
    ///    "1000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseTransactionGasPrice(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseTransactionGasPrice {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseTransactionGasPrice> for ::std::string::String {
        fn from(value: CreateSwapQuoteResponseTransactionGasPrice) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseTransactionGasPrice>
        for CreateSwapQuoteResponseTransactionGasPrice
    {
        fn from(value: &CreateSwapQuoteResponseTransactionGasPrice) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseTransactionGasPrice {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseTransactionGasPrice {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateSwapQuoteResponseTransactionGasPrice
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSwapQuoteResponseTransactionGasPrice {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseTransactionGasPrice {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed address of the contract to call.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed address of the contract to call.",
    ///  "examples": [
    ///    "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseTransactionTo(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseTransactionTo {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseTransactionTo> for ::std::string::String {
        fn from(value: CreateSwapQuoteResponseTransactionTo) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseTransactionTo>
        for CreateSwapQuoteResponseTransactionTo
    {
        fn from(value: &CreateSwapQuoteResponseTransactionTo) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseTransactionTo {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseTransactionTo {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSwapQuoteResponseTransactionTo {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSwapQuoteResponseTransactionTo {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseTransactionTo {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The value of the transaction in Wei.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The value of the transaction in Wei.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateSwapQuoteResponseTransactionValue(::std::string::String);
    impl ::std::ops::Deref for CreateSwapQuoteResponseTransactionValue {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponseTransactionValue> for ::std::string::String {
        fn from(value: CreateSwapQuoteResponseTransactionValue) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateSwapQuoteResponseTransactionValue>
        for CreateSwapQuoteResponseTransactionValue
    {
        fn from(value: &CreateSwapQuoteResponseTransactionValue) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateSwapQuoteResponseTransactionValue {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateSwapQuoteResponseTransactionValue {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateSwapQuoteResponseTransactionValue {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateSwapQuoteResponseTransactionValue {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateSwapQuoteResponseTransactionValue {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///A wrapper for the response of a swap quote operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A wrapper for the response of a swap quote operation.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/CreateSwapQuoteResponse"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SwapUnavailableResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum CreateSwapQuoteResponseWrapper {
        CreateSwapQuoteResponse(CreateSwapQuoteResponse),
        SwapUnavailableResponse(SwapUnavailableResponse),
    }
    impl ::std::convert::From<&Self> for CreateSwapQuoteResponseWrapper {
        fn from(value: &CreateSwapQuoteResponseWrapper) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<CreateSwapQuoteResponse> for CreateSwapQuoteResponseWrapper {
        fn from(value: CreateSwapQuoteResponse) -> Self {
            Self::CreateSwapQuoteResponse(value)
        }
    }
    impl ::std::convert::From<SwapUnavailableResponse> for CreateSwapQuoteResponseWrapper {
        fn from(value: SwapUnavailableResponse) -> Self {
            Self::SwapUnavailableResponse(value)
        }
    }
    ///`DeletePolicyPolicyId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct DeletePolicyPolicyId(::std::string::String);
    impl ::std::ops::Deref for DeletePolicyPolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<DeletePolicyPolicyId> for ::std::string::String {
        fn from(value: DeletePolicyPolicyId) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&DeletePolicyPolicyId> for DeletePolicyPolicyId {
        fn from(value: &DeletePolicyPolicyId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for DeletePolicyPolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(
                || {
                    ::regress::Regex::new(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
                    )
                    .unwrap()
                },
            );
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for DeletePolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for DeletePolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for DeletePolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeletePolicyPolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`DeletePolicyXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct DeletePolicyXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for DeletePolicyXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<DeletePolicyXIdempotencyKey> for ::std::string::String {
        fn from(value: DeletePolicyXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&DeletePolicyXIdempotencyKey> for DeletePolicyXIdempotencyKey {
        fn from(value: &DeletePolicyXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for DeletePolicyXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for DeletePolicyXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for DeletePolicyXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for DeletePolicyXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeletePolicyXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///Information about an end user who authenticates using a JWT issued by the developer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "DeveloperJWTAuthentication",
    ///  "description": "Information about an end user who authenticates using a JWT issued by the developer.",
    ///  "type": "object",
    ///  "required": [
    ///    "kid",
    ///    "sub",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "kid": {
    ///      "description": "The key ID of the JWK used to sign the JWT.",
    ///      "examples": [
    ///        "NjVBRjY5MDlCMUIwNzU4RTA2QzZFMDQ4QzQ2MDAyQjVDNjk1RTM2Qg"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "sub": {
    ///      "description": "The unique identifier for the end user that is captured in the `sub` claim of the JWT.",
    ///      "examples": [
    ///        "e051beeb-7163-4527-a5b6-35e301529ff2"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of authentication information.",
    ///      "examples": [
    ///        "jwt"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "jwt"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct DeveloperJwtAuthentication {
        ///The key ID of the JWK used to sign the JWT.
        pub kid: ::std::string::String,
        ///The unique identifier for the end user that is captured in the `sub` claim of the JWT.
        pub sub: ::std::string::String,
        ///The type of authentication information.
        #[serde(rename = "type")]
        pub type_: DeveloperJwtAuthenticationType,
    }
    impl ::std::convert::From<&DeveloperJwtAuthentication> for DeveloperJwtAuthentication {
        fn from(value: &DeveloperJwtAuthentication) -> Self {
            value.clone()
        }
    }
    impl DeveloperJwtAuthentication {
        pub fn builder() -> builder::DeveloperJwtAuthentication {
            Default::default()
        }
    }
    ///The type of authentication information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of authentication information.",
    ///  "examples": [
    ///    "jwt"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "jwt"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum DeveloperJwtAuthenticationType {
        #[serde(rename = "jwt")]
        Jwt,
    }
    impl ::std::convert::From<&Self> for DeveloperJwtAuthenticationType {
        fn from(value: &DeveloperJwtAuthenticationType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for DeveloperJwtAuthenticationType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Jwt => f.write_str("jwt"),
            }
        }
    }
    impl ::std::str::FromStr for DeveloperJwtAuthenticationType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "jwt" => Ok(Self::Jwt),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for DeveloperJwtAuthenticationType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for DeveloperJwtAuthenticationType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for DeveloperJwtAuthenticationType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The domain of the EIP-712 typed data.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The domain of the EIP-712 typed data.",
    ///  "examples": [
    ///    {
    ///      "chainId": 1,
    ///      "name": "Permit2",
    ///      "verifyingContract": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "chainId": {
    ///      "description": "The chain ID of the EVM network.",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "name": {
    ///      "description": "The name of the DApp or protocol.",
    ///      "examples": [
    ///        "Permit2"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "salt": {
    ///      "description": "The optional 32-byte 0x-prefixed hex salt for domain separation.",
    ///      "examples": [
    ///        "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{64}$"
    ///    },
    ///    "verifyingContract": {
    ///      "description": "The 0x-prefixed EVM address of the verifying smart contract.",
    ///      "examples": [
    ///        "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    },
    ///    "version": {
    ///      "description": "The version of the DApp or protocol.",
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct Eip712Domain {
        ///The chain ID of the EVM network.
        #[serde(
            rename = "chainId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub chain_id: ::std::option::Option<i64>,
        ///The name of the DApp or protocol.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The optional 32-byte 0x-prefixed hex salt for domain separation.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub salt: ::std::option::Option<Eip712DomainSalt>,
        ///The 0x-prefixed EVM address of the verifying smart contract.
        #[serde(
            rename = "verifyingContract",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub verifying_contract: ::std::option::Option<Eip712DomainVerifyingContract>,
        ///The version of the DApp or protocol.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub version: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&Eip712Domain> for Eip712Domain {
        fn from(value: &Eip712Domain) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for Eip712Domain {
        fn default() -> Self {
            Self {
                chain_id: Default::default(),
                name: Default::default(),
                salt: Default::default(),
                verifying_contract: Default::default(),
                version: Default::default(),
            }
        }
    }
    impl Eip712Domain {
        pub fn builder() -> builder::Eip712Domain {
            Default::default()
        }
    }
    ///The optional 32-byte 0x-prefixed hex salt for domain separation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The optional 32-byte 0x-prefixed hex salt for domain separation.",
    ///  "examples": [
    ///    "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{64}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct Eip712DomainSalt(::std::string::String);
    impl ::std::ops::Deref for Eip712DomainSalt {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<Eip712DomainSalt> for ::std::string::String {
        fn from(value: Eip712DomainSalt) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&Eip712DomainSalt> for Eip712DomainSalt {
        fn from(value: &Eip712DomainSalt) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for Eip712DomainSalt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{64}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for Eip712DomainSalt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for Eip712DomainSalt {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for Eip712DomainSalt {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for Eip712DomainSalt {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed EVM address of the verifying smart contract.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed EVM address of the verifying smart contract.",
    ///  "examples": [
    ///    "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct Eip712DomainVerifyingContract(::std::string::String);
    impl ::std::ops::Deref for Eip712DomainVerifyingContract {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<Eip712DomainVerifyingContract> for ::std::string::String {
        fn from(value: Eip712DomainVerifyingContract) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&Eip712DomainVerifyingContract> for Eip712DomainVerifyingContract {
        fn from(value: &Eip712DomainVerifyingContract) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for Eip712DomainVerifyingContract {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for Eip712DomainVerifyingContract {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for Eip712DomainVerifyingContract {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for Eip712DomainVerifyingContract {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for Eip712DomainVerifyingContract {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The message to sign using EIP-712.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The message to sign using EIP-712.",
    ///  "examples": [
    ///    {
    ///      "domain": {
    ///        "chainId": 1,
    ///        "name": "Permit2",
    ///        "verifyingContract": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///      },
    ///      "message": {
    ///        "deadline": "1717123200",
    ///        "nonce": "123456",
    ///        "permitted": {
    ///          "amount": "1000000",
    ///          "token": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    ///        },
    ///        "spender": "0xFfFfFfFFfFFfFFfFFfFFFFFffFFFffffFfFFFfFf"
    ///      },
    ///      "primaryType": "PermitTransferFrom",
    ///      "types": {
    ///        "EIP712Domain": [
    ///          {
    ///            "name": "name",
    ///            "type": "string"
    ///          },
    ///          {
    ///            "name": "chainId",
    ///            "type": "uint256"
    ///          },
    ///          {
    ///            "name": "verifyingContract",
    ///            "type": "address"
    ///          }
    ///        ],
    ///        "PermitTransferFrom": [
    ///          {
    ///            "name": "permitted",
    ///            "type": "TokenPermissions"
    ///          },
    ///          {
    ///            "name": "spender",
    ///            "type": "address"
    ///          },
    ///          {
    ///            "name": "nonce",
    ///            "type": "uint256"
    ///          },
    ///          {
    ///            "name": "deadline",
    ///            "type": "uint256"
    ///          }
    ///        ],
    ///        "TokenPermissions": [
    ///          {
    ///            "name": "token",
    ///            "type": "address"
    ///          },
    ///          {
    ///            "name": "amount",
    ///            "type": "uint256"
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "domain",
    ///    "message",
    ///    "primaryType",
    ///    "types"
    ///  ],
    ///  "properties": {
    ///    "domain": {
    ///      "$ref": "#/components/schemas/EIP712Domain"
    ///    },
    ///    "message": {
    ///      "description": "The message to sign. The structure of this message must match the `primaryType` struct in the `types` object.",
    ///      "examples": [
    ///        {
    ///          "deadline": "1716239020",
    ///          "nonce": "0",
    ///          "permitted": {
    ///            "amount": "1000000",
    ///            "token": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    ///          },
    ///          "spender": "0x1111111254EEB25477B68fb85Ed929f73A960582"
    ///        }
    ///      ],
    ///      "type": "object"
    ///    },
    ///    "primaryType": {
    ///      "description": "The primary type of the message. This is the name of the struct in the `types` object that is the root of the message.",
    ///      "examples": [
    ///        "PermitTransferFrom"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "types": {
    ///      "$ref": "#/components/schemas/EIP712Types"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct Eip712Message {
        pub domain: Eip712Domain,
        ///The message to sign. The structure of this message must match the `primaryType` struct in the `types` object.
        pub message: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        ///The primary type of the message. This is the name of the struct in the `types` object that is the root of the message.
        #[serde(rename = "primaryType")]
        pub primary_type: ::std::string::String,
        pub types: Eip712Types,
    }
    impl ::std::convert::From<&Eip712Message> for Eip712Message {
        fn from(value: &Eip712Message) -> Self {
            value.clone()
        }
    }
    impl Eip712Message {
        pub fn builder() -> builder::Eip712Message {
            Default::default()
        }
    }
    /**A mapping of struct names to an array of type objects (name + type).
    Each key corresponds to a type name (e.g., "`EIP712Domain`", "`PermitTransferFrom`").
    */
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A mapping of struct names to an array of type objects (name + type).\nEach key corresponds to a type name (e.g., \"`EIP712Domain`\", \"`PermitTransferFrom`\").\n",
    ///  "examples": [
    ///    {
    ///      "EIP712Domain": [
    ///        {
    ///          "name": "name",
    ///          "type": "string"
    ///        },
    ///        {
    ///          "name": "chainId",
    ///          "type": "uint256"
    ///        },
    ///        {
    ///          "name": "verifyingContract",
    ///          "type": "address"
    ///        }
    ///      ],
    ///      "PermitTransferFrom": [
    ///        {
    ///          "name": "permitted",
    ///          "type": "TokenPermissions"
    ///        },
    ///        {
    ///          "name": "spender",
    ///          "type": "address"
    ///        },
    ///        {
    ///          "name": "nonce",
    ///          "type": "uint256"
    ///        },
    ///        {
    ///          "name": "deadline",
    ///          "type": "uint256"
    ///        }
    ///      ],
    ///      "TokenPermissions": [
    ///        {
    ///          "name": "token",
    ///          "type": "address"
    ///        },
    ///        {
    ///          "name": "amount",
    ///          "type": "uint256"
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "type": "object"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct Eip712Types(pub ::serde_json::Map<::std::string::String, ::serde_json::Value>);
    impl ::std::ops::Deref for Eip712Types {
        type Target = ::serde_json::Map<::std::string::String, ::serde_json::Value>;
        fn deref(&self) -> &::serde_json::Map<::std::string::String, ::serde_json::Value> {
            &self.0
        }
    }
    impl ::std::convert::From<Eip712Types>
        for ::serde_json::Map<::std::string::String, ::serde_json::Value>
    {
        fn from(value: Eip712Types) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&Eip712Types> for Eip712Types {
        fn from(value: &Eip712Types) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::serde_json::Map<::std::string::String, ::serde_json::Value>>
        for Eip712Types
    {
        fn from(value: ::serde_json::Map<::std::string::String, ::serde_json::Value>) -> Self {
            Self(value)
        }
    }
    ///Information about an end user who authenticates using a one-time password sent to their email address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "EmailAuthentication",
    ///  "description": "Information about an end user who authenticates using a one-time password sent to their email address.",
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "description": "The email address of the end user.",
    ///      "examples": [
    ///        "user@example.com"
    ///      ],
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "type": {
    ///      "description": "The type of authentication information.",
    ///      "examples": [
    ///        "email"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "email"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EmailAuthentication {
        ///The email address of the end user.
        pub email: ::std::string::String,
        ///The type of authentication information.
        #[serde(rename = "type")]
        pub type_: EmailAuthenticationType,
    }
    impl ::std::convert::From<&EmailAuthentication> for EmailAuthentication {
        fn from(value: &EmailAuthentication) -> Self {
            value.clone()
        }
    }
    impl EmailAuthentication {
        pub fn builder() -> builder::EmailAuthentication {
            Default::default()
        }
    }
    ///The type of authentication information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of authentication information.",
    ///  "examples": [
    ///    "email"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "email"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EmailAuthenticationType {
        #[serde(rename = "email")]
        Email,
    }
    impl ::std::convert::From<&Self> for EmailAuthenticationType {
        fn from(value: &EmailAuthenticationType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EmailAuthenticationType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Email => f.write_str("email"),
            }
        }
    }
    impl ::std::str::FromStr for EmailAuthenticationType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "email" => Ok(Self::Email),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EmailAuthenticationType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EmailAuthenticationType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EmailAuthenticationType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Information about the end user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Information about the end user.",
    ///  "type": "object",
    ///  "required": [
    ///    "authenticationMethods",
    ///    "createdAt",
    ///    "evmAccountObjects",
    ///    "evmAccounts",
    ///    "evmSmartAccountObjects",
    ///    "evmSmartAccounts",
    ///    "solanaAccountObjects",
    ///    "solanaAccounts",
    ///    "userId"
    ///  ],
    ///  "properties": {
    ///    "authenticationMethods": {
    ///      "$ref": "#/components/schemas/AuthenticationMethods"
    ///    },
    ///    "createdAt": {
    ///      "description": "The date and time when the end user was created, in ISO 8601 format.",
    ///      "examples": [
    ///        "2025-01-15T10:30:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "evmAccountObjects": {
    ///      "description": "The list of EVM accounts associated with the end user. End users can have up to 10 EVM accounts.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "address": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///            "createdAt": "2025-01-15T10:30:00Z"
    ///          },
    ///          {
    ///            "address": "0x1234567890abcdef1234567890abcdef12345678",
    ///            "createdAt": "2025-01-15T11:00:00Z"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EndUserEvmAccount"
    ///      }
    ///    },
    ///    "evmAccounts": {
    ///      "description": "**DEPRECATED**: Use `evmAccountObjects` instead for richer account information. The list of EVM account addresses associated with the end user. End users can have up to 10 EVM accounts.",
    ///      "deprecated": true,
    ///      "examples": [
    ///        [
    ///          "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "The address of the EVM account associated with the end user.",
    ///        "examples": [
    ///          "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///        ],
    ///        "type": "string",
    ///        "pattern": "^0x[0-9a-fA-F]{40}$"
    ///      }
    ///    },
    ///    "evmSmartAccountObjects": {
    ///      "description": "The list of EVM smart accounts associated with the end user. Each EVM EOA can own one smart account.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "address": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///            "createdAt": "2025-01-15T12:00:00Z",
    ///            "ownerAddresses": [
    ///              "0x1234567890abcdef1234567890abcdef12345678",
    ///              "0xabcdefabcdefabcdefabcdefabcdefabcdefabcd"
    ///            ]
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EndUserEvmSmartAccount"
    ///      }
    ///    },
    ///    "evmSmartAccounts": {
    ///      "description": "**DEPRECATED**: Use `evmSmartAccountObjects` instead for richer account information including owner relationships. The list of EVM smart account addresses associated with the end user. Each EVM EOA can own one smart account.",
    ///      "deprecated": true,
    ///      "examples": [
    ///        [
    ///          "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "The address of the EVM smart account associated with the end user.",
    ///        "examples": [
    ///          "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///        ],
    ///        "type": "string",
    ///        "pattern": "^0x[0-9a-fA-F]{40}$"
    ///      }
    ///    },
    ///    "solanaAccountObjects": {
    ///      "description": "The list of Solana accounts associated with the end user. End users can have up to 10 Solana accounts.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "address": "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT",
    ///            "createdAt": "2025-01-15T10:30:00Z"
    ///          },
    ///          {
    ///            "address": "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin",
    ///            "createdAt": "2025-01-15T11:30:00Z"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EndUserSolanaAccount"
    ///      }
    ///    },
    ///    "solanaAccounts": {
    ///      "description": "**DEPRECATED**: Use `solanaAccountObjects` instead for richer account information. The list of Solana account addresses associated with the end user. End users can have up to 10 Solana accounts.",
    ///      "deprecated": true,
    ///      "examples": [
    ///        [
    ///          "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "The base58 encoded address of the Solana account associated with the end user.",
    ///        "examples": [
    ///          "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///        ],
    ///        "type": "string",
    ///        "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///      }
    ///    },
    ///    "userId": {
    ///      "description": "A stable, unique identifier for the end user. The `userId` must be unique across all end users in the developer's CDP Project. It must be between 1 and 100 characters long and can only contain alphanumeric characters and hyphens.",
    ///      "examples": [
    ///        "e051beeb-7163-4527-a5b6-35e301529ff2"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[a-zA-Z0-9-]{1,100}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EndUser {
        #[serde(rename = "authenticationMethods")]
        pub authentication_methods: AuthenticationMethods,
        ///The date and time when the end user was created, in ISO 8601 format.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        ///The list of EVM accounts associated with the end user. End users can have up to 10 EVM accounts.
        #[serde(rename = "evmAccountObjects")]
        pub evm_account_objects: ::std::vec::Vec<EndUserEvmAccount>,
        ///**DEPRECATED**: Use `evmAccountObjects` instead for richer account information. The list of EVM account addresses associated with the end user. End users can have up to 10 EVM accounts.
        #[serde(rename = "evmAccounts")]
        pub evm_accounts: ::std::vec::Vec<EndUserEvmAccountsItem>,
        ///The list of EVM smart accounts associated with the end user. Each EVM EOA can own one smart account.
        #[serde(rename = "evmSmartAccountObjects")]
        pub evm_smart_account_objects: ::std::vec::Vec<EndUserEvmSmartAccount>,
        ///**DEPRECATED**: Use `evmSmartAccountObjects` instead for richer account information including owner relationships. The list of EVM smart account addresses associated with the end user. Each EVM EOA can own one smart account.
        #[serde(rename = "evmSmartAccounts")]
        pub evm_smart_accounts: ::std::vec::Vec<EndUserEvmSmartAccountsItem>,
        ///The list of Solana accounts associated with the end user. End users can have up to 10 Solana accounts.
        #[serde(rename = "solanaAccountObjects")]
        pub solana_account_objects: ::std::vec::Vec<EndUserSolanaAccount>,
        ///**DEPRECATED**: Use `solanaAccountObjects` instead for richer account information. The list of Solana account addresses associated with the end user. End users can have up to 10 Solana accounts.
        #[serde(rename = "solanaAccounts")]
        pub solana_accounts: ::std::vec::Vec<EndUserSolanaAccountsItem>,
        ///A stable, unique identifier for the end user. The `userId` must be unique across all end users in the developer's CDP Project. It must be between 1 and 100 characters long and can only contain alphanumeric characters and hyphens.
        #[serde(rename = "userId")]
        pub user_id: EndUserUserId,
    }
    impl ::std::convert::From<&EndUser> for EndUser {
        fn from(value: &EndUser) -> Self {
            value.clone()
        }
    }
    impl EndUser {
        pub fn builder() -> builder::EndUser {
            Default::default()
        }
    }
    ///Information about an EVM account associated with an end user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Information about an EVM account associated with an end user.",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "createdAt"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The address of the EVM account.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]{40}$"
    ///    },
    ///    "createdAt": {
    ///      "description": "The date and time when the account was created, in ISO 8601 format.",
    ///      "examples": [
    ///        "2025-01-15T10:30:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EndUserEvmAccount {
        ///The address of the EVM account.
        pub address: EndUserEvmAccountAddress,
        ///The date and time when the account was created, in ISO 8601 format.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl ::std::convert::From<&EndUserEvmAccount> for EndUserEvmAccount {
        fn from(value: &EndUserEvmAccount) -> Self {
            value.clone()
        }
    }
    impl EndUserEvmAccount {
        pub fn builder() -> builder::EndUserEvmAccount {
            Default::default()
        }
    }
    ///The address of the EVM account.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The address of the EVM account.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EndUserEvmAccountAddress(::std::string::String);
    impl ::std::ops::Deref for EndUserEvmAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EndUserEvmAccountAddress> for ::std::string::String {
        fn from(value: EndUserEvmAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EndUserEvmAccountAddress> for EndUserEvmAccountAddress {
        fn from(value: &EndUserEvmAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EndUserEvmAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EndUserEvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EndUserEvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EndUserEvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EndUserEvmAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The address of the EVM account associated with the end user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The address of the EVM account associated with the end user.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EndUserEvmAccountsItem(::std::string::String);
    impl ::std::ops::Deref for EndUserEvmAccountsItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EndUserEvmAccountsItem> for ::std::string::String {
        fn from(value: EndUserEvmAccountsItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EndUserEvmAccountsItem> for EndUserEvmAccountsItem {
        fn from(value: &EndUserEvmAccountsItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EndUserEvmAccountsItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EndUserEvmAccountsItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EndUserEvmAccountsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EndUserEvmAccountsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EndUserEvmAccountsItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///Information about an EVM smart account associated with an end user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Information about an EVM smart account associated with an end user.",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "createdAt",
    ///    "ownerAddresses"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The address of the EVM smart account.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]{40}$"
    ///    },
    ///    "createdAt": {
    ///      "description": "The date and time when the account was created, in ISO 8601 format.",
    ///      "examples": [
    ///        "2025-01-15T10:30:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "ownerAddresses": {
    ///      "description": "The addresses of the EVM EOA accounts that own this smart account. Smart accounts can have multiple owners, such as when spend permissions are enabled.",
    ///      "examples": [
    ///        [
    ///          "0x1234567890abcdef1234567890abcdef12345678",
    ///          "0xabcdefabcdefabcdefabcdefabcdefabcdefabcd"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "The address of an EVM EOA account that owns this smart account.",
    ///        "examples": [
    ///          "0x1234567890abcdef1234567890abcdef12345678"
    ///        ],
    ///        "type": "string",
    ///        "pattern": "^0x[0-9a-fA-F]{40}$"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EndUserEvmSmartAccount {
        ///The address of the EVM smart account.
        pub address: EndUserEvmSmartAccountAddress,
        ///The date and time when the account was created, in ISO 8601 format.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        ///The addresses of the EVM EOA accounts that own this smart account. Smart accounts can have multiple owners, such as when spend permissions are enabled.
        #[serde(rename = "ownerAddresses")]
        pub owner_addresses: ::std::vec::Vec<EndUserEvmSmartAccountOwnerAddressesItem>,
    }
    impl ::std::convert::From<&EndUserEvmSmartAccount> for EndUserEvmSmartAccount {
        fn from(value: &EndUserEvmSmartAccount) -> Self {
            value.clone()
        }
    }
    impl EndUserEvmSmartAccount {
        pub fn builder() -> builder::EndUserEvmSmartAccount {
            Default::default()
        }
    }
    ///The address of the EVM smart account.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The address of the EVM smart account.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EndUserEvmSmartAccountAddress(::std::string::String);
    impl ::std::ops::Deref for EndUserEvmSmartAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EndUserEvmSmartAccountAddress> for ::std::string::String {
        fn from(value: EndUserEvmSmartAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EndUserEvmSmartAccountAddress> for EndUserEvmSmartAccountAddress {
        fn from(value: &EndUserEvmSmartAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EndUserEvmSmartAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EndUserEvmSmartAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EndUserEvmSmartAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EndUserEvmSmartAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EndUserEvmSmartAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The address of an EVM EOA account that owns this smart account.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The address of an EVM EOA account that owns this smart account.",
    ///  "examples": [
    ///    "0x1234567890abcdef1234567890abcdef12345678"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EndUserEvmSmartAccountOwnerAddressesItem(::std::string::String);
    impl ::std::ops::Deref for EndUserEvmSmartAccountOwnerAddressesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EndUserEvmSmartAccountOwnerAddressesItem> for ::std::string::String {
        fn from(value: EndUserEvmSmartAccountOwnerAddressesItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EndUserEvmSmartAccountOwnerAddressesItem>
        for EndUserEvmSmartAccountOwnerAddressesItem
    {
        fn from(value: &EndUserEvmSmartAccountOwnerAddressesItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EndUserEvmSmartAccountOwnerAddressesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EndUserEvmSmartAccountOwnerAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EndUserEvmSmartAccountOwnerAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EndUserEvmSmartAccountOwnerAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EndUserEvmSmartAccountOwnerAddressesItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The address of the EVM smart account associated with the end user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The address of the EVM smart account associated with the end user.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EndUserEvmSmartAccountsItem(::std::string::String);
    impl ::std::ops::Deref for EndUserEvmSmartAccountsItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EndUserEvmSmartAccountsItem> for ::std::string::String {
        fn from(value: EndUserEvmSmartAccountsItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EndUserEvmSmartAccountsItem> for EndUserEvmSmartAccountsItem {
        fn from(value: &EndUserEvmSmartAccountsItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EndUserEvmSmartAccountsItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EndUserEvmSmartAccountsItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EndUserEvmSmartAccountsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EndUserEvmSmartAccountsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EndUserEvmSmartAccountsItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///Information about a Solana account associated with an end user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Information about a Solana account associated with an end user.",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "createdAt"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The base58 encoded address of the Solana account.",
    ///      "examples": [
    ///        "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///    },
    ///    "createdAt": {
    ///      "description": "The date and time when the account was created, in ISO 8601 format.",
    ///      "examples": [
    ///        "2025-01-15T10:30:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EndUserSolanaAccount {
        ///The base58 encoded address of the Solana account.
        pub address: EndUserSolanaAccountAddress,
        ///The date and time when the account was created, in ISO 8601 format.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }
    impl ::std::convert::From<&EndUserSolanaAccount> for EndUserSolanaAccount {
        fn from(value: &EndUserSolanaAccount) -> Self {
            value.clone()
        }
    }
    impl EndUserSolanaAccount {
        pub fn builder() -> builder::EndUserSolanaAccount {
            Default::default()
        }
    }
    ///The base58 encoded address of the Solana account.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The base58 encoded address of the Solana account.",
    ///  "examples": [
    ///    "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EndUserSolanaAccountAddress(::std::string::String);
    impl ::std::ops::Deref for EndUserSolanaAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EndUserSolanaAccountAddress> for ::std::string::String {
        fn from(value: EndUserSolanaAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EndUserSolanaAccountAddress> for EndUserSolanaAccountAddress {
        fn from(value: &EndUserSolanaAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EndUserSolanaAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EndUserSolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EndUserSolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EndUserSolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EndUserSolanaAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The base58 encoded address of the Solana account associated with the end user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The base58 encoded address of the Solana account associated with the end user.",
    ///  "examples": [
    ///    "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EndUserSolanaAccountsItem(::std::string::String);
    impl ::std::ops::Deref for EndUserSolanaAccountsItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EndUserSolanaAccountsItem> for ::std::string::String {
        fn from(value: EndUserSolanaAccountsItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EndUserSolanaAccountsItem> for EndUserSolanaAccountsItem {
        fn from(value: &EndUserSolanaAccountsItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EndUserSolanaAccountsItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EndUserSolanaAccountsItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EndUserSolanaAccountsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EndUserSolanaAccountsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EndUserSolanaAccountsItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///A stable, unique identifier for the end user. The `userId` must be unique across all end users in the developer's CDP Project. It must be between 1 and 100 characters long and can only contain alphanumeric characters and hyphens.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A stable, unique identifier for the end user. The `userId` must be unique across all end users in the developer's CDP Project. It must be between 1 and 100 characters long and can only contain alphanumeric characters and hyphens.",
    ///  "examples": [
    ///    "e051beeb-7163-4527-a5b6-35e301529ff2"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[a-zA-Z0-9-]{1,100}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EndUserUserId(::std::string::String);
    impl ::std::ops::Deref for EndUserUserId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EndUserUserId> for ::std::string::String {
        fn from(value: EndUserUserId) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EndUserUserId> for EndUserUserId {
        fn from(value: &EndUserUserId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EndUserUserId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[a-zA-Z0-9-]{1,100}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[a-zA-Z0-9-]{1,100}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EndUserUserId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EndUserUserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EndUserUserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EndUserUserId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///An error response including the code for the type of error and a human-readable message describing the error.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An error response including the code for the type of error and a human-readable message describing the error.",
    ///  "examples": [
    ///    {
    ///      "correlationId": "41deb8d59a9dc9a7-IAD",
    ///      "errorLink": "https://docs.cdp.coinbase.com/api-reference/v2/errors#invalid-request",
    ///      "errorMessage": "Invalid request.",
    ///      "errorType": "invalid_request"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "errorMessage",
    ///    "errorType"
    ///  ],
    ///  "properties": {
    ///    "correlationId": {
    ///      "description": "A unique identifier for the request that generated the error. This can be used to help debug issues with the API.",
    ///      "examples": [
    ///        "41deb8d59a9dc9a7-IAD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "errorLink": {
    ///      "description": "A link to the corresponding error documentation.",
    ///      "examples": [
    ///        "https://docs.cdp.coinbase.com/api-reference/v2/errors#invalid-request"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Url"
    ///        }
    ///      ]
    ///    },
    ///    "errorMessage": {
    ///      "description": "The error message.",
    ///      "examples": [
    ///        "Unable to create EVM account"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "errorType": {
    ///      "$ref": "#/components/schemas/ErrorType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct Error {
        ///A unique identifier for the request that generated the error. This can be used to help debug issues with the API.
        #[serde(
            rename = "correlationId",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub correlation_id: ::std::option::Option<::std::string::String>,
        ///A link to the corresponding error documentation.
        #[serde(
            rename = "errorLink",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub error_link: ::std::option::Option<Url>,
        ///The error message.
        #[serde(rename = "errorMessage")]
        pub error_message: ::std::string::String,
        #[serde(rename = "errorType")]
        pub error_type: ErrorType,
    }
    impl ::std::convert::From<&Error> for Error {
        fn from(value: &Error) -> Self {
            value.clone()
        }
    }
    impl Error {
        pub fn builder() -> builder::Error {
            Default::default()
        }
    }
    ///The code that indicates the type of error that occurred. These error codes can be used to determine how to handle the error.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The code that indicates the type of error that occurred. These error codes can be used to determine how to handle the error.",
    ///  "examples": [
    ///    "invalid_request"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "already_exists",
    ///    "bad_gateway",
    ///    "faucet_limit_exceeded",
    ///    "forbidden",
    ///    "idempotency_error",
    ///    "internal_server_error",
    ///    "invalid_request",
    ///    "invalid_sql_query",
    ///    "invalid_signature",
    ///    "malformed_transaction",
    ///    "not_found",
    ///    "payment_method_required",
    ///    "rate_limit_exceeded",
    ///    "request_canceled",
    ///    "service_unavailable",
    ///    "timed_out",
    ///    "unauthorized",
    ///    "policy_violation",
    ///    "policy_in_use",
    ///    "account_limit_exceeded",
    ///    "network_not_tradable",
    ///    "guest_permission_denied",
    ///    "guest_region_forbidden",
    ///    "guest_transaction_limit",
    ///    "guest_transaction_count",
    ///    "phone_number_verification_expired",
    ///    "document_verification_failed",
    ///    "recipient_allowlist_violation",
    ///    "recipient_allowlist_pending",
    ///    "travel_rules_recipient_violation",
    ///    "transfer_amount_out_of_bounds",
    ///    "transfer_recipient_address_invalid",
    ///    "transfer_quote_expired",
    ///    "mfa_already_enrolled",
    ///    "mfa_invalid_code",
    ///    "mfa_flow_expired",
    ///    "mfa_required",
    ///    "mfa_not_enrolled"
    ///  ],
    ///  "x-error-instructions": {
    ///    "already_exists": "This error occurs when trying to create a resource that already exists.\n\n**Steps to resolve:**\n1. Check if the resource exists before creation\n2. Use GET endpoints to verify resource state\n3. Use unique identifiers/names for resources",
    ///    "bad_gateway": "This error occurs when the CDP API is unable to connect to the backend service.\n\n**Steps to resolve:**\n1. Retry your request after a short delay\n2. If persistent, contact CDP support with:\n   - The timestamp of the error\n   - Request details\n3. Consider implementing retry logic with an exponential backoff\n\n**Note:** These errors are automatically logged and monitored by CDP.",
    ///    "document_verification_failed": "This error occurs when the user has not verified their identity for their coinbase.com account.\n**Steps to resolve:**\n1. Verify your coinbase account identity with valid documents at https://www.coinbase.com/settings/account-levels.",
    ///    "faucet_limit_exceeded": "This error occurs when you've exceeded the faucet request limits.\n\n**Steps to resolve:**\n1. Wait for the time window to reset\n2. Use funds more efficiently in your testing\n\nFor more information on faucet limits, please visit the [EVM Faucet endpoint](https://docs.cdp.coinbase.com/api-reference/v2/rest-api/faucets/request-funds-on-evm-test-networks) or the [Solana Faucet endpoint](https://docs.cdp.coinbase.com/api-reference/v2/rest-api/faucets/request-funds-on-solana-devnet).",
    ///    "forbidden": "This error occurs when you don't have permission to access the resource.\n\n**Steps to resolve:**\n1. Verify your permissions to access the resource\n2. Ensure that you are the owner of the requested resource",
    ///    "guest_permission_denied": "This error occurs when the user is not allowed to complete onramp transactions as a guest.\n\n**Steps to resolve:**\n1. Redirect the user to create a Coinbase account to buy and send crypto.",
    ///    "guest_region_forbidden": "This error occurs when guest onramp transactions are not allowed in the user's region.\n\n**Steps to resolve:**\n1. Redirect the user to create a Coinbase account to buy and send crypto.",
    ///    "guest_transaction_count": "This error occurs when the user has reached the lifetime guest onramp transaction count limit.\n\n**Steps to resolve:**\n1. Redirect the user to create a Coinbase account to buy and send crypto.",
    ///    "guest_transaction_limit": "This error occurs when the user has reached the weekly guest onramp transaction limit.\n\n**Steps to resolve:**\n1. Inform the user they have reached their weekly limit and will have to wait until next week.",
    ///    "idempotency_error": "This error occurs when an idempotency key is reused with different parameters.\n\n**Steps to resolve:**\n1. Generate a new UUID v4 for each unique request\n2. Only reuse idempotency keys for exact request duplicates\n3. Track used keys within your application\n\n**Example idempotency key implementation:**\n```typescript lines wrap\nimport { v4 as uuidv4 } from 'uuid';\n\nfunction createIdempotencyKey() {\n  return uuidv4();\n}\n```",
    ///    "internal_server_error": "This indicates an unexpected error that occurred on the CDP servers.\n\n**Important**: If you encounter this error, please note that your operation's status should be treated as unknown by your application, as it could have been a success within the CDP back-end.\n\n**Steps to resolve:**\n1. Retry your request after a short delay\n2. If persistent, contact CDP support with:\n   - Your correlation ID\n   - Timestamp of the error\n   - Request details\n3. Consider implementing retry logic with an exponential backoff\n\n**Note:** These errors are automatically logged and monitored by CDP.",
    ///    "invalid_request": "This error occurs when the request is malformed or contains invalid data, including issues with the request body, query parameters, path parameters, or headers.\n\n**Steps to resolve:**\n1. Check all required fields and parameters are present\n2. Ensure request body (if applicable) follows the correct schema\n3. Verify all parameter formats match the API specification:\n   - Query parameters\n   - Path parameters\n   - Request headers\n4. Validate any addresses, IDs, or other formatted strings meet requirements\n\n**Common validation issues:**\n- Missing required parameters\n- Invalid parameter types or formats\n- Malformed JSON in request body\n- Invalid enum values",
    ///    "invalid_signature": "This error occurs when the signature provided for the given user operation is invalid.\n\n**Steps to resolve:**\n1. Verify the signature was generated by the correct owner account\n2. Ensure the signature corresponds to the exact user operation hash\n3. Check that the signature format matches the expected format\n4. Confirm you're using the correct network for the Smart Account\n\n**Common causes:**\n- Using wrong owner account to sign\n- Signing modified/incorrect user operation data\n- Malformed signature encoding\n- Network mismatch between signature and broadcast",
    ///    "invalid_sql_query": "This error occurs when the SQL query is invalid or not allowed.\n\n**Common causes:**\n- Using non-SELECT SQL statements (INSERT, UPDATE, DELETE, etc.)\n- Invalid table or column names\n- Syntax errors in SQL query\n- Query exceeds character limit\n- Too many JOIN operations",
    ///    "malformed_transaction": "This error occurs when the transaction data provided is not properly formatted or is invalid.\n\n**Steps to resolve:**\n1. Verify transaction encoding:\n   - **EVM networks**: Check RLP encoding is correct\n   - **Solana**: Validate base64 encoding\n2. Ensure all required transaction fields are present\n3. Validate transaction parameters are within acceptable ranges\n4. Check that the transaction type is supported on the target network (see our [Supported Networks](https://docs.cdp.coinbase.com/get-started/supported-networks) page for more details)\n\n**Common causes:**\n- Invalid hex encoding for EVM transactions\n- Missing required transaction fields\n- Incorrect parameter formats\n- Unsupported transaction types\n- Network-specific transaction format mismatches",
    ///    "mfa_already_enrolled": "This error occurs when attempting to enroll in an MFA method that the user has already enrolled in.\n\n**Steps to resolve:**\n1. Check if the user is already enrolled in the MFA method before initiating enrollment\n2. To update or reset MFA, remove the existing enrollment first (if supported)\n3. Use a different MFA method if multiple options are available",
    ///    "mfa_flow_expired": "This error occurs when the MFA enrollment or verification session has expired.\n\n**Steps to resolve:**\n1. Restart the MFA enrollment or verification flow\n2. Complete the flow within the allowed time window (typically 5 minutes)\n3. Ensure the user doesn't leave the flow idle for extended periods\n\n**Note:** MFA sessions expire automatically for security purposes.",
    ///    "mfa_invalid_code": "This error occurs when the MFA code provided is incorrect or has already been used.\n\n**Steps to resolve:**\n1. Verify the user entered the correct code from their authenticator app\n2. Ensure the code is current (TOTP codes expire after 30 seconds)\n3. Check that the device time is synchronized correctly\n4. Ask the user to generate a new code and try again\n\n**Common causes:**\n- Typing errors in the 6-digit code\n- Using an expired TOTP code\n- Device clock drift on user's authenticator app\n- Attempting to reuse a previously submitted code",
    ///    "mfa_not_enrolled": "This error occurs when attempting to verify MFA for a user who has not enrolled in any MFA method.\n\n**Steps to resolve:**\n1. Check if the user has enrolled in MFA before attempting verification\n2. Guide the user through MFA enrollment first using the `/mfa/enroll/{mfaMethod}/init` endpoint\n3. Complete enrollment before requiring MFA verification",
    ///    "mfa_required": "This error occurs when attempting to perform a sensitive operation that requires MFA verification, but the user has not completed MFA verification.\n\n**Steps to resolve:**\n1. Initiate the MFA verification flow using the `/mfa/verify/{mfaMethod}/init` endpoint\n2. Prompt the user to enter their MFA code\n3. Submit the verification using the `/mfa/verify/{mfaMethod}/submit` endpoint\n4. Use the returned access token with MFA claim for the sensitive operation\n5. Retry the original request with the new MFA-verified token\n\n**Operations requiring MFA:**\n- Transactions Sign/Send\n- Key export\n- Account management actions (when configured)",
    ///    "network_not_tradable": "This error occurs when the selected asset cannot be purchased on the selected network in the user's location.\n\n**Steps to resolve:**\n1. Verify the asset is tradable on the selected network\n2. Check the user's location to ensure it is allowed to purchase the asset on the selected network\n\n**Common causes:**\n- Users in NY are not allowed to purchase USDC on any network other than Ethereum",
    ///    "not_found": "This error occurs when the resource specified in your request doesn't exist or you don't have access to it.\n\n**Steps to resolve:**\n1. Verify the resource ID/address/account exists\n2. Check your permissions to access the resource\n3. Ensure you're using the correct network/environment\n4. Confirm the resource hasn't been deleted\n\n**Common causes:**\n- Mistyped addresses\n- Accessing resources from the wrong CDP project\n- Resource was deleted or hasn't been created yet",
    ///    "payment_method_required": "This error occurs when a payment method is required to complete the requested operation but none is configured or available.\n\n**Steps to resolve:**\n1. Add a valid payment method to your account using the [CDP Portal](https://portal.cdp.coinbase.com)\n2. Ensure your payment method is valid and not expired\n\n**Common causes:**\n- No payment method configured on the account\n- Payment method is expired",
    ///    "phone_number_verification_expired": "This error occurs when the user's phone number verification has expired. Use of guest Onramp requires the user's\nphone number to be verified every 60 days.\n\n**Steps to resolve:**\n1. Re-verify the user's phone number via OTP.\n2. Retry the request with the phoneNumberVerifiedAt field set to new verification timestamp.",
    ///    "policy_in_use": "This error occurs when trying to delete a Policy that is currently in use by at least one project or account.\n\n**Steps to resolve:**\n1. Update project or accounts to remove references to the Policy in question.\n2. Retry your delete request.",
    ///    "rate_limit_exceeded": "This error occurs when you've exceeded the API rate limits.\n\n**Steps to resolve:**\n1. Implement exponential backoff\n2. Cache responses where possible\n3. Wait for rate limit window to reset\n\n**Best practices:**\n```typescript lines wrap\nasync function withRetry(fn: () => Promise<any>) {\n  let delay = 1000;\n  while (true) {\n    try {\n      return await fn();\n    } catch (e) {\n      if (e.errorType === \"rate_limit_exceeded\") {\n        await sleep(delay);\n        delay *= 2;\n        continue;\n      }\n      throw e;\n    }\n  }\n}\n```",
    ///    "recipient_allowlist_pending": "This error occurs when the user is not allowed to receive funds at this address, because changes to their coinbase account allowlist are pending.\n**Steps to resolve:**\n1. Wait approximately 2 days for updates to take effect.",
    ///    "recipient_allowlist_violation": "This error occurs when the user is not allowed to receive funds at this address, according to their coinbase account allowlist.\n**Steps to resolve:**\n1. Either disable the allowlist or add the wallet address at https://www.coinbase.com/settings/allowlist\n2. Wait approximately 2 days for updates to take effect.",
    ///    "request_canceled": "This error occurs when the client cancels an in-progress request before it completes.\n\n**Steps to resolve:**\n1. Check client-side timeout configurations\n2. Review request cancellation logic in your code\n3. Consider increasing timeout thresholds for long-running operations\n4. Implement request tracking to identify premature cancellations\n\n**Best practices:**\n```typescript lines wrap\nasync function withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {\n  const timeout = new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(new Error(\"Operation timed out\"));\n    }, timeoutMs);\n  });\n\n  try {\n    return await Promise.race([promise, timeout]);\n  } catch (error) {\n    // Handle timeout or cancellation\n    throw error;\n  }\n}\n```",
    ///    "service_unavailable": "This error occurs when the CDP API is temporarily unable to handle requests due to maintenance or high load.\n\n**Steps to resolve:**\n1. Retry your request after a short delay\n2. If persistent, contact CDP support with:\n   - The timestamp of the error\n   - Request details\n3. Consider implementing retry logic with an exponential backoff\n\n**Note:** These errors are automatically logged and monitored by CDP.",
    ///    "timed_out": "This error occurs when a request exceeds the maximum allowed processing time.\n\n**Steps to resolve:**\n1. Break down large requests into smaller chunks (if applicable)\n2. Implement retry logic with exponential backoff\n3. Use streaming endpoints for large data sets\n\n**Example retry implementation:**\n```typescript lines wrap\nasync function withRetryAndTimeout<T>(\n  operation: () => Promise<T>,\n  maxRetries = 3,\n  timeout = 30000,\n): Promise<T> {\n  let attempts = 0;\n  while (attempts < maxRetries) {\n    try {\n      return await Promise.race([\n        operation(),\n        new Promise((_, reject) =>\n          setTimeout(() => reject(new Error(\"Timeout\")), timeout)\n        ),\n      ]);\n    } catch (error) {\n      attempts++;\n      if (attempts === maxRetries) throw error;\n      // Exponential backoff\n      await new Promise(resolve =>\n        setTimeout(resolve, Math.pow(2, attempts) * 1000)\n      );\n    }\n  }\n  throw new Error(\"Max retries exceeded\");\n}\n```",
    ///    "transfer_amount_out_of_bounds": "This error occurs when the transfer amount is less than $1 USD equivalent amount or greater than the maximum transfer amount for the account.\n\n**Steps to resolve:**\n1. Verify the transfer amount is greater than $1 USD equivalent amount.\n2. Confirm that the account has sufficient funds to cover the transfer amount.",
    ///    "transfer_quote_expired": "This error occurs when the transfer quote has expired.\n**Steps to resolve:**\n1. Create a new quoted transfer and retry the request.",
    ///    "transfer_recipient_address_invalid": "This error occurs when the recipient address is invalid for the specified network.\n**Steps to resolve:**\n1. Verify the network is supported for the transfer.\n2. Confirm that the recipient address is valid for the specified network.",
    ///    "travel_rules_recipient_violation": "This error occurs when the user is not allowed to receive funds at this address, because it violates travel rules.\n**Steps to resolve:**\n1. Ensure your desired transfer is not blocked by local travel regulations.",
    ///    "unauthorized": "This error occurs when authentication fails.\n\n**Steps to resolve:**\n1. Verify your CDP API credentials:\n   - Check that your API key is valid\n   - Check that your Wallet Secret is properly configured\n2. Validate JWT token:\n   - Not expired\n   - Properly signed\n   - Contains required claims\n3. Check request headers:\n   - Authorization header present\n   - X-Wallet-Auth header included when required\n\n**Security note:** Never share your Wallet Secret or API keys."
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ErrorType {
        #[serde(rename = "already_exists")]
        AlreadyExists,
        #[serde(rename = "bad_gateway")]
        BadGateway,
        #[serde(rename = "faucet_limit_exceeded")]
        FaucetLimitExceeded,
        #[serde(rename = "forbidden")]
        Forbidden,
        #[serde(rename = "idempotency_error")]
        IdempotencyError,
        #[serde(rename = "internal_server_error")]
        InternalServerError,
        #[serde(rename = "invalid_request")]
        InvalidRequest,
        #[serde(rename = "invalid_sql_query")]
        InvalidSqlQuery,
        #[serde(rename = "invalid_signature")]
        InvalidSignature,
        #[serde(rename = "malformed_transaction")]
        MalformedTransaction,
        #[serde(rename = "not_found")]
        NotFound,
        #[serde(rename = "payment_method_required")]
        PaymentMethodRequired,
        #[serde(rename = "rate_limit_exceeded")]
        RateLimitExceeded,
        #[serde(rename = "request_canceled")]
        RequestCanceled,
        #[serde(rename = "service_unavailable")]
        ServiceUnavailable,
        #[serde(rename = "timed_out")]
        TimedOut,
        #[serde(rename = "unauthorized")]
        Unauthorized,
        #[serde(rename = "policy_violation")]
        PolicyViolation,
        #[serde(rename = "policy_in_use")]
        PolicyInUse,
        #[serde(rename = "account_limit_exceeded")]
        AccountLimitExceeded,
        #[serde(rename = "network_not_tradable")]
        NetworkNotTradable,
        #[serde(rename = "guest_permission_denied")]
        GuestPermissionDenied,
        #[serde(rename = "guest_region_forbidden")]
        GuestRegionForbidden,
        #[serde(rename = "guest_transaction_limit")]
        GuestTransactionLimit,
        #[serde(rename = "guest_transaction_count")]
        GuestTransactionCount,
        #[serde(rename = "phone_number_verification_expired")]
        PhoneNumberVerificationExpired,
        #[serde(rename = "document_verification_failed")]
        DocumentVerificationFailed,
        #[serde(rename = "recipient_allowlist_violation")]
        RecipientAllowlistViolation,
        #[serde(rename = "recipient_allowlist_pending")]
        RecipientAllowlistPending,
        #[serde(rename = "travel_rules_recipient_violation")]
        TravelRulesRecipientViolation,
        #[serde(rename = "transfer_amount_out_of_bounds")]
        TransferAmountOutOfBounds,
        #[serde(rename = "transfer_recipient_address_invalid")]
        TransferRecipientAddressInvalid,
        #[serde(rename = "transfer_quote_expired")]
        TransferQuoteExpired,
        #[serde(rename = "mfa_already_enrolled")]
        MfaAlreadyEnrolled,
        #[serde(rename = "mfa_invalid_code")]
        MfaInvalidCode,
        #[serde(rename = "mfa_flow_expired")]
        MfaFlowExpired,
        #[serde(rename = "mfa_required")]
        MfaRequired,
        #[serde(rename = "mfa_not_enrolled")]
        MfaNotEnrolled,
    }
    impl ::std::convert::From<&Self> for ErrorType {
        fn from(value: &ErrorType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ErrorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AlreadyExists => f.write_str("already_exists"),
                Self::BadGateway => f.write_str("bad_gateway"),
                Self::FaucetLimitExceeded => f.write_str("faucet_limit_exceeded"),
                Self::Forbidden => f.write_str("forbidden"),
                Self::IdempotencyError => f.write_str("idempotency_error"),
                Self::InternalServerError => f.write_str("internal_server_error"),
                Self::InvalidRequest => f.write_str("invalid_request"),
                Self::InvalidSqlQuery => f.write_str("invalid_sql_query"),
                Self::InvalidSignature => f.write_str("invalid_signature"),
                Self::MalformedTransaction => f.write_str("malformed_transaction"),
                Self::NotFound => f.write_str("not_found"),
                Self::PaymentMethodRequired => f.write_str("payment_method_required"),
                Self::RateLimitExceeded => f.write_str("rate_limit_exceeded"),
                Self::RequestCanceled => f.write_str("request_canceled"),
                Self::ServiceUnavailable => f.write_str("service_unavailable"),
                Self::TimedOut => f.write_str("timed_out"),
                Self::Unauthorized => f.write_str("unauthorized"),
                Self::PolicyViolation => f.write_str("policy_violation"),
                Self::PolicyInUse => f.write_str("policy_in_use"),
                Self::AccountLimitExceeded => f.write_str("account_limit_exceeded"),
                Self::NetworkNotTradable => f.write_str("network_not_tradable"),
                Self::GuestPermissionDenied => f.write_str("guest_permission_denied"),
                Self::GuestRegionForbidden => f.write_str("guest_region_forbidden"),
                Self::GuestTransactionLimit => f.write_str("guest_transaction_limit"),
                Self::GuestTransactionCount => f.write_str("guest_transaction_count"),
                Self::PhoneNumberVerificationExpired => {
                    f.write_str("phone_number_verification_expired")
                }
                Self::DocumentVerificationFailed => f.write_str("document_verification_failed"),
                Self::RecipientAllowlistViolation => f.write_str("recipient_allowlist_violation"),
                Self::RecipientAllowlistPending => f.write_str("recipient_allowlist_pending"),
                Self::TravelRulesRecipientViolation => {
                    f.write_str("travel_rules_recipient_violation")
                }
                Self::TransferAmountOutOfBounds => f.write_str("transfer_amount_out_of_bounds"),
                Self::TransferRecipientAddressInvalid => {
                    f.write_str("transfer_recipient_address_invalid")
                }
                Self::TransferQuoteExpired => f.write_str("transfer_quote_expired"),
                Self::MfaAlreadyEnrolled => f.write_str("mfa_already_enrolled"),
                Self::MfaInvalidCode => f.write_str("mfa_invalid_code"),
                Self::MfaFlowExpired => f.write_str("mfa_flow_expired"),
                Self::MfaRequired => f.write_str("mfa_required"),
                Self::MfaNotEnrolled => f.write_str("mfa_not_enrolled"),
            }
        }
    }
    impl ::std::str::FromStr for ErrorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "already_exists" => Ok(Self::AlreadyExists),
                "bad_gateway" => Ok(Self::BadGateway),
                "faucet_limit_exceeded" => Ok(Self::FaucetLimitExceeded),
                "forbidden" => Ok(Self::Forbidden),
                "idempotency_error" => Ok(Self::IdempotencyError),
                "internal_server_error" => Ok(Self::InternalServerError),
                "invalid_request" => Ok(Self::InvalidRequest),
                "invalid_sql_query" => Ok(Self::InvalidSqlQuery),
                "invalid_signature" => Ok(Self::InvalidSignature),
                "malformed_transaction" => Ok(Self::MalformedTransaction),
                "not_found" => Ok(Self::NotFound),
                "payment_method_required" => Ok(Self::PaymentMethodRequired),
                "rate_limit_exceeded" => Ok(Self::RateLimitExceeded),
                "request_canceled" => Ok(Self::RequestCanceled),
                "service_unavailable" => Ok(Self::ServiceUnavailable),
                "timed_out" => Ok(Self::TimedOut),
                "unauthorized" => Ok(Self::Unauthorized),
                "policy_violation" => Ok(Self::PolicyViolation),
                "policy_in_use" => Ok(Self::PolicyInUse),
                "account_limit_exceeded" => Ok(Self::AccountLimitExceeded),
                "network_not_tradable" => Ok(Self::NetworkNotTradable),
                "guest_permission_denied" => Ok(Self::GuestPermissionDenied),
                "guest_region_forbidden" => Ok(Self::GuestRegionForbidden),
                "guest_transaction_limit" => Ok(Self::GuestTransactionLimit),
                "guest_transaction_count" => Ok(Self::GuestTransactionCount),
                "phone_number_verification_expired" => Ok(Self::PhoneNumberVerificationExpired),
                "document_verification_failed" => Ok(Self::DocumentVerificationFailed),
                "recipient_allowlist_violation" => Ok(Self::RecipientAllowlistViolation),
                "recipient_allowlist_pending" => Ok(Self::RecipientAllowlistPending),
                "travel_rules_recipient_violation" => Ok(Self::TravelRulesRecipientViolation),
                "transfer_amount_out_of_bounds" => Ok(Self::TransferAmountOutOfBounds),
                "transfer_recipient_address_invalid" => Ok(Self::TransferRecipientAddressInvalid),
                "transfer_quote_expired" => Ok(Self::TransferQuoteExpired),
                "mfa_already_enrolled" => Ok(Self::MfaAlreadyEnrolled),
                "mfa_invalid_code" => Ok(Self::MfaInvalidCode),
                "mfa_flow_expired" => Ok(Self::MfaFlowExpired),
                "mfa_required" => Ok(Self::MfaRequired),
                "mfa_not_enrolled" => Ok(Self::MfaNotEnrolled),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for ErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ErrorType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ErrorType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///A schema for specifying a criterion for the `value` field of an EVM transaction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "EthValueCriterion",
    ///  "description": "A schema for specifying a criterion for the `value` field of an EVM transaction.",
    ///  "type": "object",
    ///  "required": [
    ///    "ethValue",
    ///    "operator",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "ethValue": {
    ///      "description": "The amount of ETH, in wei, that the transaction's `value` field should be compared to.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[0-9]+$"
    ///    },
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. The transaction's `value` field will be on the left-hand side of the operator, and the `ethValue` field will be on the right-hand side.",
    ///      "examples": [
    ///        "<="
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "GreaterThan",
    ///        "GreaterThanOrEqual",
    ///        "LessThan",
    ///        "LessThanOrEqual",
    ///        "Equal"
    ///      ]
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `ethValue`.",
    ///      "examples": [
    ///        "ethValue"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "ethValue"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EthValueCriterion {
        ///The amount of ETH, in wei, that the transaction's `value` field should be compared to.
        #[serde(rename = "ethValue")]
        pub eth_value: EthValueCriterionEthValue,
        ///The operator to use for the comparison. The transaction's `value` field will be on the left-hand side of the operator, and the `ethValue` field will be on the right-hand side.
        pub operator: EthValueCriterionOperator,
        ///The type of criterion to use. This should be `ethValue`.
        #[serde(rename = "type")]
        pub type_: EthValueCriterionType,
    }
    impl ::std::convert::From<&EthValueCriterion> for EthValueCriterion {
        fn from(value: &EthValueCriterion) -> Self {
            value.clone()
        }
    }
    impl EthValueCriterion {
        pub fn builder() -> builder::EthValueCriterion {
            Default::default()
        }
    }
    ///The amount of ETH, in wei, that the transaction's `value` field should be compared to.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount of ETH, in wei, that the transaction's `value` field should be compared to.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[0-9]+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EthValueCriterionEthValue(::std::string::String);
    impl ::std::ops::Deref for EthValueCriterionEthValue {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EthValueCriterionEthValue> for ::std::string::String {
        fn from(value: EthValueCriterionEthValue) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EthValueCriterionEthValue> for EthValueCriterionEthValue {
        fn from(value: &EthValueCriterionEthValue) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EthValueCriterionEthValue {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^[0-9]+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[0-9]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EthValueCriterionEthValue {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthValueCriterionEthValue {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthValueCriterionEthValue {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EthValueCriterionEthValue {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The operator to use for the comparison. The transaction's `value` field will be on the left-hand side of the operator, and the `ethValue` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. The transaction's `value` field will be on the left-hand side of the operator, and the `ethValue` field will be on the right-hand side.",
    ///  "examples": [
    ///    "<="
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "GreaterThan",
    ///    "GreaterThanOrEqual",
    ///    "LessThan",
    ///    "LessThanOrEqual",
    ///    "Equal"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthValueCriterionOperator {
        GreaterThan,
        GreaterThanOrEqual,
        LessThan,
        LessThanOrEqual,
        Equal,
    }
    impl ::std::convert::From<&Self> for EthValueCriterionOperator {
        fn from(value: &EthValueCriterionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthValueCriterionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GreaterThan => f.write_str("GreaterThan"),
                Self::GreaterThanOrEqual => f.write_str("GreaterThanOrEqual"),
                Self::LessThan => f.write_str("LessThan"),
                Self::LessThanOrEqual => f.write_str("LessThanOrEqual"),
                Self::Equal => f.write_str("Equal"),
            }
        }
    }
    impl ::std::str::FromStr for EthValueCriterionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "GreaterThan" => Ok(Self::GreaterThan),
                "GreaterThanOrEqual" => Ok(Self::GreaterThanOrEqual),
                "LessThan" => Ok(Self::LessThan),
                "LessThanOrEqual" => Ok(Self::LessThanOrEqual),
                "Equal" => Ok(Self::Equal),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthValueCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthValueCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthValueCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The type of criterion to use. This should be `ethValue`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `ethValue`.",
    ///  "examples": [
    ///    "ethValue"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "ethValue"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthValueCriterionType {
        #[serde(rename = "ethValue")]
        EthValue,
    }
    impl ::std::convert::From<&Self> for EthValueCriterionType {
        fn from(value: &EthValueCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthValueCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthValue => f.write_str("ethValue"),
            }
        }
    }
    impl ::std::str::FromStr for EthValueCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethValue" => Ok(Self::EthValue),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthValueCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthValueCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthValueCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`EvmAccount`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The 0x-prefixed, checksum EVM address.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]{40}$"
    ///    },
    ///    "createdAt": {
    ///      "description": "The UTC ISO 8601 timestamp at which the account was created.",
    ///      "examples": [
    ///        "2025-03-25T12:00:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "name": {
    ///      "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names are guaranteed to be unique across all EVM accounts in the developer's CDP Project.",
    ///      "examples": [
    ///        "my-account"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///    },
    ///    "policies": {
    ///      "description": "The list of policy IDs that apply to the account. This will include both the project-level policy and the account-level policy, if one exists.",
    ///      "examples": [
    ///        [
    ///          "123e4567-e89b-12d3-a456-426614174000"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
    ///      },
    ///      "x-audience": "public"
    ///    },
    ///    "updatedAt": {
    ///      "description": "The UTC ISO 8601 timestamp at which the account was last updated.",
    ///      "examples": [
    ///        "2025-03-26T12:00:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EvmAccount {
        ///The 0x-prefixed, checksum EVM address.
        pub address: EvmAccountAddress,
        ///The UTC ISO 8601 timestamp at which the account was created.
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        /**An optional name for the account.
        Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
        Account names are guaranteed to be unique across all EVM accounts in the developer's CDP Project.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<EvmAccountName>,
        ///The list of policy IDs that apply to the account. This will include both the project-level policy and the account-level policy, if one exists.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub policies: ::std::vec::Vec<EvmAccountPoliciesItem>,
        ///The UTC ISO 8601 timestamp at which the account was last updated.
        #[serde(
            rename = "updatedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub updated_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    }
    impl ::std::convert::From<&EvmAccount> for EvmAccount {
        fn from(value: &EvmAccount) -> Self {
            value.clone()
        }
    }
    impl EvmAccount {
        pub fn builder() -> builder::EvmAccount {
            Default::default()
        }
    }
    ///The 0x-prefixed, checksum EVM address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed, checksum EVM address.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EvmAccountAddress(::std::string::String);
    impl ::std::ops::Deref for EvmAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EvmAccountAddress> for ::std::string::String {
        fn from(value: EvmAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EvmAccountAddress> for EvmAccountAddress {
        fn from(value: &EvmAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EvmAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EvmAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    /**An optional name for the account.
    Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
    Account names are guaranteed to be unique across all EVM accounts in the developer's CDP Project.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names are guaranteed to be unique across all EVM accounts in the developer's CDP Project.",
    ///  "examples": [
    ///    "my-account"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EvmAccountName(::std::string::String);
    impl ::std::ops::Deref for EvmAccountName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EvmAccountName> for ::std::string::String {
        fn from(value: EvmAccountName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EvmAccountName> for EvmAccountName {
        fn from(value: &EvmAccountName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EvmAccountName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmAccountName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmAccountName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmAccountName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EvmAccountName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`EvmAccountPoliciesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EvmAccountPoliciesItem(::std::string::String);
    impl ::std::ops::Deref for EvmAccountPoliciesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EvmAccountPoliciesItem> for ::std::string::String {
        fn from(value: EvmAccountPoliciesItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EvmAccountPoliciesItem> for EvmAccountPoliciesItem {
        fn from(value: &EvmAccountPoliciesItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EvmAccountPoliciesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(
                || {
                    ::regress::Regex::new(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
                    )
                    .unwrap()
                },
            );
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmAccountPoliciesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmAccountPoliciesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmAccountPoliciesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EvmAccountPoliciesItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///A schema for specifying a criterion for the `to` field of an EVM transaction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "EvmAddressCriterion",
    ///  "description": "A schema for specifying a criterion for the `to` field of an EVM transaction.",
    ///  "type": "object",
    ///  "required": [
    ///    "addresses",
    ///    "operator",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "addresses": {
    ///      "description": "A list of 0x-prefixed EVM addresses that the transaction's `to` field should be compared to. There is a limit of 300 addresses per criterion.",
    ///      "examples": [
    ///        [
    ///          "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///          "0x1234567890123456789012345678901234567890"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "The 0x-prefixed EVM address that the transaction's `to` field should be compared to.",
    ///        "type": "string",
    ///        "pattern": "^0x[0-9a-fA-F]{40}$"
    ///      }
    ///    },
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. The transaction's `to` field will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.",
    ///      "examples": [
    ///        "in"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "in",
    ///        "not in"
    ///      ]
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `evmAddress`.",
    ///      "examples": [
    ///        "evmAddress"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "evmAddress"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EvmAddressCriterion {
        ///A list of 0x-prefixed EVM addresses that the transaction's `to` field should be compared to. There is a limit of 300 addresses per criterion.
        pub addresses: ::std::vec::Vec<EvmAddressCriterionAddressesItem>,
        ///The operator to use for the comparison. The transaction's `to` field will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
        pub operator: EvmAddressCriterionOperator,
        ///The type of criterion to use. This should be `evmAddress`.
        #[serde(rename = "type")]
        pub type_: EvmAddressCriterionType,
    }
    impl ::std::convert::From<&EvmAddressCriterion> for EvmAddressCriterion {
        fn from(value: &EvmAddressCriterion) -> Self {
            value.clone()
        }
    }
    impl EvmAddressCriterion {
        pub fn builder() -> builder::EvmAddressCriterion {
            Default::default()
        }
    }
    ///The 0x-prefixed EVM address that the transaction's `to` field should be compared to.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed EVM address that the transaction's `to` field should be compared to.",
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EvmAddressCriterionAddressesItem(::std::string::String);
    impl ::std::ops::Deref for EvmAddressCriterionAddressesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EvmAddressCriterionAddressesItem> for ::std::string::String {
        fn from(value: EvmAddressCriterionAddressesItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EvmAddressCriterionAddressesItem> for EvmAddressCriterionAddressesItem {
        fn from(value: &EvmAddressCriterionAddressesItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EvmAddressCriterionAddressesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmAddressCriterionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmAddressCriterionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmAddressCriterionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EvmAddressCriterionAddressesItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The operator to use for the comparison. The transaction's `to` field will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. The transaction's `to` field will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.",
    ///  "examples": [
    ///    "in"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "in",
    ///    "not in"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EvmAddressCriterionOperator {
        #[serde(rename = "in")]
        In,
        #[serde(rename = "not in")]
        NotIn,
    }
    impl ::std::convert::From<&Self> for EvmAddressCriterionOperator {
        fn from(value: &EvmAddressCriterionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EvmAddressCriterionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::In => f.write_str("in"),
                Self::NotIn => f.write_str("not in"),
            }
        }
    }
    impl ::std::str::FromStr for EvmAddressCriterionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "in" => Ok(Self::In),
                "not in" => Ok(Self::NotIn),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmAddressCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmAddressCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmAddressCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The type of criterion to use. This should be `evmAddress`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `evmAddress`.",
    ///  "examples": [
    ///    "evmAddress"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "evmAddress"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EvmAddressCriterionType {
        #[serde(rename = "evmAddress")]
        EvmAddress,
    }
    impl ::std::convert::From<&Self> for EvmAddressCriterionType {
        fn from(value: &EvmAddressCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EvmAddressCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EvmAddress => f.write_str("evmAddress"),
            }
        }
    }
    impl ::std::str::FromStr for EvmAddressCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "evmAddress" => Ok(Self::EvmAddress),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmAddressCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmAddressCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmAddressCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`EvmCall`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "to",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "description": "The call data to send. This is the hex-encoded data of the function call consisting of the method selector and the function arguments.",
    ///      "examples": [
    ///        "0xa9059cbb000000000000000000000000fc807d1be4997e5c7b33e4d8d57e60c5b0f02b1a0000000000000000000000000000000000000000000000000000000000000064"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]*$"
    ///    },
    ///    "overrideGasLimit": {
    ///      "description": "The override gas limit to use for the call instead of the bundler's estimated gas limit.",
    ///      "examples": [
    ///        "100000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "to": {
    ///      "description": "The address the call is directed to.",
    ///      "examples": [
    ///        "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]{40}$"
    ///    },
    ///    "value": {
    ///      "description": "The amount of ETH to send with the call, in wei.",
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EvmCall {
        ///The call data to send. This is the hex-encoded data of the function call consisting of the method selector and the function arguments.
        pub data: EvmCallData,
        ///The override gas limit to use for the call instead of the bundler's estimated gas limit.
        #[serde(
            rename = "overrideGasLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub override_gas_limit: ::std::option::Option<::std::string::String>,
        ///The address the call is directed to.
        pub to: EvmCallTo,
        ///The amount of ETH to send with the call, in wei.
        pub value: ::std::string::String,
    }
    impl ::std::convert::From<&EvmCall> for EvmCall {
        fn from(value: &EvmCall) -> Self {
            value.clone()
        }
    }
    impl EvmCall {
        pub fn builder() -> builder::EvmCall {
            Default::default()
        }
    }
    ///The call data to send. This is the hex-encoded data of the function call consisting of the method selector and the function arguments.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The call data to send. This is the hex-encoded data of the function call consisting of the method selector and the function arguments.",
    ///  "examples": [
    ///    "0xa9059cbb000000000000000000000000fc807d1be4997e5c7b33e4d8d57e60c5b0f02b1a0000000000000000000000000000000000000000000000000000000000000064"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]*$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EvmCallData(::std::string::String);
    impl ::std::ops::Deref for EvmCallData {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EvmCallData> for ::std::string::String {
        fn from(value: EvmCallData) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EvmCallData> for EvmCallData {
        fn from(value: &EvmCallData) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EvmCallData {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^0x[0-9a-fA-F]*$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]*$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmCallData {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmCallData {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmCallData {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EvmCallData {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The address the call is directed to.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The address the call is directed to.",
    ///  "examples": [
    ///    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EvmCallTo(::std::string::String);
    impl ::std::ops::Deref for EvmCallTo {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EvmCallTo> for ::std::string::String {
        fn from(value: EvmCallTo) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EvmCallTo> for EvmCallTo {
        fn from(value: &EvmCallTo) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EvmCallTo {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmCallTo {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmCallTo {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmCallTo {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EvmCallTo {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///A single condition to apply against the function and encoded arguments in the transaction's `data` field. Each `parameter` configuration must be successfully evaluated against the corresponding function argument in order for a policy to be accepted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single condition to apply against the function and encoded arguments in the transaction's `data` field. Each `parameter` configuration must be successfully evaluated against the corresponding function argument in order for a policy to be accepted.",
    ///  "examples": [
    ///    {
    ///      "function": "transfer",
    ///      "params": [
    ///        {
    ///          "name": "value",
    ///          "operator": "<=",
    ///          "value": "10000"
    ///        },
    ///        {
    ///          "name": "to",
    ///          "operator": "in",
    ///          "values": [
    ///            "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "function"
    ///  ],
    ///  "properties": {
    ///    "function": {
    ///      "description": "The name of a smart contract function being called.",
    ///      "examples": [
    ///        "transfer"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "params": {
    ///      "description": "An optional list of parameter conditions to apply against encoded arguments in the transaction's `data` field.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "name": "value",
    ///            "operator": "<=",
    ///            "value": "10000"
    ///          },
    ///          {
    ///            "name": "to",
    ///            "operator": "in",
    ///            "values": [
    ///              "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///            ]
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "A list of parameter conditions to apply against encoded arguments in the transaction's `data` field.",
    ///        "oneOf": [
    ///          {
    ///            "$ref": "#/components/schemas/EvmDataParameterCondition"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/EvmDataParameterConditionList"
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EvmDataCondition {
        ///The name of a smart contract function being called.
        pub function: ::std::string::String,
        ///An optional list of parameter conditions to apply against encoded arguments in the transaction's `data` field.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub params: ::std::vec::Vec<EvmDataConditionParamsItem>,
    }
    impl ::std::convert::From<&EvmDataCondition> for EvmDataCondition {
        fn from(value: &EvmDataCondition) -> Self {
            value.clone()
        }
    }
    impl EvmDataCondition {
        pub fn builder() -> builder::EvmDataCondition {
            Default::default()
        }
    }
    ///A list of parameter conditions to apply against encoded arguments in the transaction's `data` field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A list of parameter conditions to apply against encoded arguments in the transaction's `data` field.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/EvmDataParameterCondition"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EvmDataParameterConditionList"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EvmDataConditionParamsItem {
        Variant0(EvmDataParameterCondition),
        Variant1(EvmDataParameterConditionList),
    }
    impl ::std::convert::From<&Self> for EvmDataConditionParamsItem {
        fn from(value: &EvmDataConditionParamsItem) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<EvmDataParameterCondition> for EvmDataConditionParamsItem {
        fn from(value: EvmDataParameterCondition) -> Self {
            Self::Variant0(value)
        }
    }
    impl ::std::convert::From<EvmDataParameterConditionList> for EvmDataConditionParamsItem {
        fn from(value: EvmDataParameterConditionList) -> Self {
            Self::Variant1(value)
        }
    }
    ///A schema for specifying a criterion for the `data` field of an EVM transaction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "EvmDataCriterion",
    ///  "description": "A schema for specifying a criterion for the `data` field of an EVM transaction.",
    ///  "type": "object",
    ///  "required": [
    ///    "abi",
    ///    "conditions",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "abi": {
    ///      "description": "The ABI of the smart contract being called. This can be a partial structure with only specific functions.",
    ///      "examples": [
    ///        "erc20"
    ///      ],
    ///      "oneOf": [
    ///        {
    ///          "$ref": "#/components/schemas/KnownAbiType"
    ///        },
    ///        {
    ///          "$ref": "#/components/schemas/Abi"
    ///        }
    ///      ]
    ///    },
    ///    "conditions": {
    ///      "description": "A list of conditions to apply against the function and encoded arguments in the transaction's `data` field. Each condition must be met in order for this policy to be accepted or rejected.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "function": "approve"
    ///          },
    ///          {
    ///            "function": "transfer",
    ///            "params": [
    ///              {
    ///                "name": "value",
    ///                "operator": "<=",
    ///                "value": "10000"
    ///              },
    ///              {
    ///                "name": "to",
    ///                "operator": "in",
    ///                "values": [
    ///                  "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///                ]
    ///              }
    ///            ]
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EvmDataCondition"
    ///      }
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `evmData`.",
    ///      "examples": [
    ///        "evmData"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "evmData"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EvmDataCriterion {
        ///The ABI of the smart contract being called. This can be a partial structure with only specific functions.
        pub abi: EvmDataCriterionAbi,
        ///A list of conditions to apply against the function and encoded arguments in the transaction's `data` field. Each condition must be met in order for this policy to be accepted or rejected.
        pub conditions: ::std::vec::Vec<EvmDataCondition>,
        ///The type of criterion to use. This should be `evmData`.
        #[serde(rename = "type")]
        pub type_: EvmDataCriterionType,
    }
    impl ::std::convert::From<&EvmDataCriterion> for EvmDataCriterion {
        fn from(value: &EvmDataCriterion) -> Self {
            value.clone()
        }
    }
    impl EvmDataCriterion {
        pub fn builder() -> builder::EvmDataCriterion {
            Default::default()
        }
    }
    ///The ABI of the smart contract being called. This can be a partial structure with only specific functions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The ABI of the smart contract being called. This can be a partial structure with only specific functions.",
    ///  "examples": [
    ///    "erc20"
    ///  ],
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/KnownAbiType"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/Abi"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EvmDataCriterionAbi {
        KnownAbiType(KnownAbiType),
        Abi(Abi),
    }
    impl ::std::convert::From<&Self> for EvmDataCriterionAbi {
        fn from(value: &EvmDataCriterionAbi) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<KnownAbiType> for EvmDataCriterionAbi {
        fn from(value: KnownAbiType) -> Self {
            Self::KnownAbiType(value)
        }
    }
    impl ::std::convert::From<Abi> for EvmDataCriterionAbi {
        fn from(value: Abi) -> Self {
            Self::Abi(value)
        }
    }
    ///The type of criterion to use. This should be `evmData`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `evmData`.",
    ///  "examples": [
    ///    "evmData"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "evmData"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EvmDataCriterionType {
        #[serde(rename = "evmData")]
        EvmData,
    }
    impl ::std::convert::From<&Self> for EvmDataCriterionType {
        fn from(value: &EvmDataCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EvmDataCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EvmData => f.write_str("evmData"),
            }
        }
    }
    impl ::std::str::FromStr for EvmDataCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "evmData" => Ok(Self::EvmData),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmDataCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmDataCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmDataCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`EvmDataParameterCondition`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "EvmDataParameterCondition",
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "operator",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "description": "The name of the parameter to check against a transaction's calldata. If name is unknown, or is not named, you may supply an array index, e.g., `0` for first parameter.",
    ///      "examples": [
    ///        "to"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.",
    ///      "examples": [
    ///        "=="
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "GreaterThan",
    ///        "GreaterThanOrEqual",
    ///        "LessThan",
    ///        "LessThanOrEqual",
    ///        "Equal"
    ///      ]
    ///    },
    ///    "value": {
    ///      "description": "A single value to compare the value resolved at `name` to. All values are encoded as strings. Refer to the table in the documentation for how values should be encoded, and which operators are supported for each type.",
    ///      "examples": [
    ///        "100000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EvmDataParameterCondition {
        ///The name of the parameter to check against a transaction's calldata. If name is unknown, or is not named, you may supply an array index, e.g., `0` for first parameter.
        pub name: ::std::string::String,
        ///The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
        pub operator: EvmDataParameterConditionOperator,
        ///A single value to compare the value resolved at `name` to. All values are encoded as strings. Refer to the table in the documentation for how values should be encoded, and which operators are supported for each type.
        pub value: ::std::string::String,
    }
    impl ::std::convert::From<&EvmDataParameterCondition> for EvmDataParameterCondition {
        fn from(value: &EvmDataParameterCondition) -> Self {
            value.clone()
        }
    }
    impl EvmDataParameterCondition {
        pub fn builder() -> builder::EvmDataParameterCondition {
            Default::default()
        }
    }
    ///`EvmDataParameterConditionList`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "EvmDataParameterConditionList",
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "operator",
    ///    "values"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "description": "The name of the parameter to check against a transaction's calldata. If name is unknown, or is not named, you may supply an array index, e.g., `0` for first parameter.",
    ///      "examples": [
    ///        "to"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `values` field will be on the right-hand side.",
    ///      "examples": [
    ///        "in"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "in",
    ///        "not in"
    ///      ]
    ///    },
    ///    "values": {
    ///      "description": "Values to compare against the resolved `name` value. All values are encoded as strings. Refer to the table in the documentation for how values should be encoded, and which operators are supported for each type.",
    ///      "examples": [
    ///        [
    ///          "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "A single potential value to compare against the resolved `name` value. All values are encoded as strings. Refer to the table in the documentation for how values should be encoded, and which operators are supported for each type.",
    ///        "examples": [
    ///          "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///        ],
    ///        "type": "string"
    ///      }
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EvmDataParameterConditionList {
        ///The name of the parameter to check against a transaction's calldata. If name is unknown, or is not named, you may supply an array index, e.g., `0` for first parameter.
        pub name: ::std::string::String,
        ///The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `values` field will be on the right-hand side.
        pub operator: EvmDataParameterConditionListOperator,
        ///Values to compare against the resolved `name` value. All values are encoded as strings. Refer to the table in the documentation for how values should be encoded, and which operators are supported for each type.
        pub values: ::std::vec::Vec<::std::string::String>,
    }
    impl ::std::convert::From<&EvmDataParameterConditionList> for EvmDataParameterConditionList {
        fn from(value: &EvmDataParameterConditionList) -> Self {
            value.clone()
        }
    }
    impl EvmDataParameterConditionList {
        pub fn builder() -> builder::EvmDataParameterConditionList {
            Default::default()
        }
    }
    ///The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `values` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `values` field will be on the right-hand side.",
    ///  "examples": [
    ///    "in"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "in",
    ///    "not in"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EvmDataParameterConditionListOperator {
        #[serde(rename = "in")]
        In,
        #[serde(rename = "not in")]
        NotIn,
    }
    impl ::std::convert::From<&Self> for EvmDataParameterConditionListOperator {
        fn from(value: &EvmDataParameterConditionListOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EvmDataParameterConditionListOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::In => f.write_str("in"),
                Self::NotIn => f.write_str("not in"),
            }
        }
    }
    impl ::std::str::FromStr for EvmDataParameterConditionListOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "in" => Ok(Self::In),
                "not in" => Ok(Self::NotIn),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmDataParameterConditionListOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmDataParameterConditionListOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmDataParameterConditionListOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.",
    ///  "examples": [
    ///    "=="
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "GreaterThan",
    ///    "GreaterThanOrEqual",
    ///    "LessThan",
    ///    "LessThanOrEqual",
    ///    "Equal"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EvmDataParameterConditionOperator {
        GreaterThan,
        GreaterThanOrEqual,
        LessThan,
        LessThanOrEqual,
        Equal,
    }
    impl ::std::convert::From<&Self> for EvmDataParameterConditionOperator {
        fn from(value: &EvmDataParameterConditionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EvmDataParameterConditionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GreaterThan => f.write_str("GreaterThan"),
                Self::GreaterThanOrEqual => f.write_str("GreaterThanOrEqual"),
                Self::LessThan => f.write_str("LessThan"),
                Self::LessThanOrEqual => f.write_str("LessThanOrEqual"),
                Self::Equal => f.write_str("Equal"),
            }
        }
    }
    impl ::std::str::FromStr for EvmDataParameterConditionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "GreaterThan" => Ok(Self::GreaterThan),
                "GreaterThanOrEqual" => Ok(Self::GreaterThanOrEqual),
                "LessThan" => Ok(Self::LessThan),
                "LessThanOrEqual" => Ok(Self::LessThanOrEqual),
                "Equal" => Ok(Self::Equal),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmDataParameterConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmDataParameterConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmDataParameterConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///A schema for specifying a criterion for the message being signed.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "EvmMessageCriterion",
    ///  "description": "A schema for specifying a criterion for the message being signed.",
    ///  "type": "object",
    ///  "required": [
    ///    "match",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "match": {
    ///      "description": "A regular expression the message is matched against. Accepts valid regular expression syntax described by [RE2](https://github.com/google/re2/wiki/Syntax).",
    ///      "examples": [
    ///        "^hello ([a-z]+)$"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `evmMessage`.",
    ///      "examples": [
    ///        "evmMessage"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "evmMessage"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EvmMessageCriterion {
        ///A regular expression the message is matched against. Accepts valid regular expression syntax described by [RE2](https://github.com/google/re2/wiki/Syntax).
        #[serde(rename = "match")]
        pub match_: ::std::string::String,
        ///The type of criterion to use. This should be `evmMessage`.
        #[serde(rename = "type")]
        pub type_: EvmMessageCriterionType,
    }
    impl ::std::convert::From<&EvmMessageCriterion> for EvmMessageCriterion {
        fn from(value: &EvmMessageCriterion) -> Self {
            value.clone()
        }
    }
    impl EvmMessageCriterion {
        pub fn builder() -> builder::EvmMessageCriterion {
            Default::default()
        }
    }
    ///The type of criterion to use. This should be `evmMessage`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `evmMessage`.",
    ///  "examples": [
    ///    "evmMessage"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "evmMessage"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EvmMessageCriterionType {
        #[serde(rename = "evmMessage")]
        EvmMessage,
    }
    impl ::std::convert::From<&Self> for EvmMessageCriterionType {
        fn from(value: &EvmMessageCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EvmMessageCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EvmMessage => f.write_str("evmMessage"),
            }
        }
    }
    impl ::std::str::FromStr for EvmMessageCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "evmMessage" => Ok(Self::EvmMessage),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmMessageCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmMessageCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmMessageCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///A schema for specifying a criterion for the intended `network` of an EVM transaction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "EvmNetworkCriterion",
    ///  "description": "A schema for specifying a criterion for the intended `network` of an EVM transaction.",
    ///  "type": "object",
    ///  "required": [
    ///    "networks",
    ///    "operator",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "networks": {
    ///      "description": "A list of EVM network identifiers that the transaction's intended `network` should be compared to.",
    ///      "examples": [
    ///        [
    ///          "base",
    ///          "ethereum"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "The network the transaction is for.",
    ///        "examples": [
    ///          "base-sepolia"
    ///        ],
    ///        "type": "string",
    ///        "enum": [
    ///          "base-sepolia",
    ///          "base",
    ///          "ethereum",
    ///          "ethereum-sepolia",
    ///          "avalanche",
    ///          "polygon",
    ///          "optimism",
    ///          "arbitrum",
    ///          "zora",
    ///          "bnb"
    ///        ]
    ///      }
    ///    },
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. The transaction's intended `network` will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.",
    ///      "examples": [
    ///        "in"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "in",
    ///        "not in"
    ///      ]
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `evmNetwork`.",
    ///      "examples": [
    ///        "evmNetwork"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "evmNetwork"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EvmNetworkCriterion {
        ///A list of EVM network identifiers that the transaction's intended `network` should be compared to.
        pub networks: ::std::vec::Vec<EvmNetworkCriterionNetworksItem>,
        ///The operator to use for the comparison. The transaction's intended `network` will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.
        pub operator: EvmNetworkCriterionOperator,
        ///The type of criterion to use. This should be `evmNetwork`.
        #[serde(rename = "type")]
        pub type_: EvmNetworkCriterionType,
    }
    impl ::std::convert::From<&EvmNetworkCriterion> for EvmNetworkCriterion {
        fn from(value: &EvmNetworkCriterion) -> Self {
            value.clone()
        }
    }
    impl EvmNetworkCriterion {
        pub fn builder() -> builder::EvmNetworkCriterion {
            Default::default()
        }
    }
    ///The network the transaction is for.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The network the transaction is for.",
    ///  "examples": [
    ///    "base-sepolia"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "base-sepolia",
    ///    "base",
    ///    "ethereum",
    ///    "ethereum-sepolia",
    ///    "avalanche",
    ///    "polygon",
    ///    "optimism",
    ///    "arbitrum",
    ///    "zora",
    ///    "bnb"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EvmNetworkCriterionNetworksItem {
        #[serde(rename = "base-sepolia")]
        BaseSepolia,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "ethereum-sepolia")]
        EthereumSepolia,
        #[serde(rename = "avalanche")]
        Avalanche,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "optimism")]
        Optimism,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "zora")]
        Zora,
        #[serde(rename = "bnb")]
        Bnb,
    }
    impl ::std::convert::From<&Self> for EvmNetworkCriterionNetworksItem {
        fn from(value: &EvmNetworkCriterionNetworksItem) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EvmNetworkCriterionNetworksItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BaseSepolia => f.write_str("base-sepolia"),
                Self::Base => f.write_str("base"),
                Self::Ethereum => f.write_str("ethereum"),
                Self::EthereumSepolia => f.write_str("ethereum-sepolia"),
                Self::Avalanche => f.write_str("avalanche"),
                Self::Polygon => f.write_str("polygon"),
                Self::Optimism => f.write_str("optimism"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Zora => f.write_str("zora"),
                Self::Bnb => f.write_str("bnb"),
            }
        }
    }
    impl ::std::str::FromStr for EvmNetworkCriterionNetworksItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base-sepolia" => Ok(Self::BaseSepolia),
                "base" => Ok(Self::Base),
                "ethereum" => Ok(Self::Ethereum),
                "ethereum-sepolia" => Ok(Self::EthereumSepolia),
                "avalanche" => Ok(Self::Avalanche),
                "polygon" => Ok(Self::Polygon),
                "optimism" => Ok(Self::Optimism),
                "arbitrum" => Ok(Self::Arbitrum),
                "zora" => Ok(Self::Zora),
                "bnb" => Ok(Self::Bnb),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmNetworkCriterionNetworksItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmNetworkCriterionNetworksItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmNetworkCriterionNetworksItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The operator to use for the comparison. The transaction's intended `network` will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. The transaction's intended `network` will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.",
    ///  "examples": [
    ///    "in"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "in",
    ///    "not in"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EvmNetworkCriterionOperator {
        #[serde(rename = "in")]
        In,
        #[serde(rename = "not in")]
        NotIn,
    }
    impl ::std::convert::From<&Self> for EvmNetworkCriterionOperator {
        fn from(value: &EvmNetworkCriterionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EvmNetworkCriterionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::In => f.write_str("in"),
                Self::NotIn => f.write_str("not in"),
            }
        }
    }
    impl ::std::str::FromStr for EvmNetworkCriterionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "in" => Ok(Self::In),
                "not in" => Ok(Self::NotIn),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmNetworkCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmNetworkCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmNetworkCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The type of criterion to use. This should be `evmNetwork`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `evmNetwork`.",
    ///  "examples": [
    ///    "evmNetwork"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "evmNetwork"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EvmNetworkCriterionType {
        #[serde(rename = "evmNetwork")]
        EvmNetwork,
    }
    impl ::std::convert::From<&Self> for EvmNetworkCriterionType {
        fn from(value: &EvmNetworkCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EvmNetworkCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EvmNetwork => f.write_str("evmNetwork"),
            }
        }
    }
    impl ::std::str::FromStr for EvmNetworkCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "evmNetwork" => Ok(Self::EvmNetwork),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmNetworkCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmNetworkCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmNetworkCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`EvmSmartAccount`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "owners"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The 0x-prefixed, checksum address of the Smart Account.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]{40}$"
    ///    },
    ///    "createdAt": {
    ///      "description": "The UTC ISO 8601 timestamp at which the account was created.",
    ///      "examples": [
    ///        "2025-03-25T12:00:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "name": {
    ///      "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names are guaranteed to be unique across all Smart Accounts in the developer's CDP Project.",
    ///      "examples": [
    ///        "my-smart-account"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///    },
    ///    "owners": {
    ///      "description": "Today, only a single owner can be set for a Smart Account, but this is an array to allow having multiple owners in the future. The address is a 0x-prefixed, checksum address.",
    ///      "examples": [
    ///        [
    ///          "0xfc807D1bE4997e5C7B33E4d8D57e60c5b0f02B1a"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "pattern": "^0x[0-9a-fA-F]{40}$"
    ///      }
    ///    },
    ///    "policies": {
    ///      "description": "The list of policy IDs that apply to the smart account. This will include both the project-level policy and the account-level policy, if one exists.",
    ///      "examples": [
    ///        [
    ///          "123e4567-e89b-12d3-a456-426614174000"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
    ///      },
    ///      "x-audience": "public"
    ///    },
    ///    "updatedAt": {
    ///      "description": "The UTC ISO 8601 timestamp at which the account was last updated.",
    ///      "examples": [
    ///        "2025-03-26T12:00:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EvmSmartAccount {
        ///The 0x-prefixed, checksum address of the Smart Account.
        pub address: EvmSmartAccountAddress,
        ///The UTC ISO 8601 timestamp at which the account was created.
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        /**An optional name for the account.
        Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
        Account names are guaranteed to be unique across all Smart Accounts in the developer's CDP Project.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<EvmSmartAccountName>,
        ///Today, only a single owner can be set for a Smart Account, but this is an array to allow having multiple owners in the future. The address is a 0x-prefixed, checksum address.
        pub owners: ::std::vec::Vec<EvmSmartAccountOwnersItem>,
        ///The list of policy IDs that apply to the smart account. This will include both the project-level policy and the account-level policy, if one exists.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub policies: ::std::vec::Vec<EvmSmartAccountPoliciesItem>,
        ///The UTC ISO 8601 timestamp at which the account was last updated.
        #[serde(
            rename = "updatedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub updated_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    }
    impl ::std::convert::From<&EvmSmartAccount> for EvmSmartAccount {
        fn from(value: &EvmSmartAccount) -> Self {
            value.clone()
        }
    }
    impl EvmSmartAccount {
        pub fn builder() -> builder::EvmSmartAccount {
            Default::default()
        }
    }
    ///The 0x-prefixed, checksum address of the Smart Account.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed, checksum address of the Smart Account.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EvmSmartAccountAddress(::std::string::String);
    impl ::std::ops::Deref for EvmSmartAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EvmSmartAccountAddress> for ::std::string::String {
        fn from(value: EvmSmartAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EvmSmartAccountAddress> for EvmSmartAccountAddress {
        fn from(value: &EvmSmartAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EvmSmartAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmSmartAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmSmartAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmSmartAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EvmSmartAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    /**An optional name for the account.
    Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
    Account names are guaranteed to be unique across all Smart Accounts in the developer's CDP Project.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names are guaranteed to be unique across all Smart Accounts in the developer's CDP Project.",
    ///  "examples": [
    ///    "my-smart-account"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EvmSmartAccountName(::std::string::String);
    impl ::std::ops::Deref for EvmSmartAccountName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EvmSmartAccountName> for ::std::string::String {
        fn from(value: EvmSmartAccountName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EvmSmartAccountName> for EvmSmartAccountName {
        fn from(value: &EvmSmartAccountName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EvmSmartAccountName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmSmartAccountName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmSmartAccountName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmSmartAccountName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EvmSmartAccountName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`EvmSmartAccountOwnersItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EvmSmartAccountOwnersItem(::std::string::String);
    impl ::std::ops::Deref for EvmSmartAccountOwnersItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EvmSmartAccountOwnersItem> for ::std::string::String {
        fn from(value: EvmSmartAccountOwnersItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EvmSmartAccountOwnersItem> for EvmSmartAccountOwnersItem {
        fn from(value: &EvmSmartAccountOwnersItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EvmSmartAccountOwnersItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmSmartAccountOwnersItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmSmartAccountOwnersItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmSmartAccountOwnersItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EvmSmartAccountOwnersItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`EvmSmartAccountPoliciesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EvmSmartAccountPoliciesItem(::std::string::String);
    impl ::std::ops::Deref for EvmSmartAccountPoliciesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EvmSmartAccountPoliciesItem> for ::std::string::String {
        fn from(value: EvmSmartAccountPoliciesItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EvmSmartAccountPoliciesItem> for EvmSmartAccountPoliciesItem {
        fn from(value: &EvmSmartAccountPoliciesItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EvmSmartAccountPoliciesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(
                || {
                    ::regress::Regex::new(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
                    )
                    .unwrap()
                },
            );
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmSmartAccountPoliciesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmSmartAccountPoliciesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmSmartAccountPoliciesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EvmSmartAccountPoliciesItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The network on which to perform the swap.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The network on which to perform the swap.",
    ///  "examples": [
    ///    "base"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "base",
    ///    "ethereum",
    ///    "arbitrum",
    ///    "optimism"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EvmSwapsNetwork {
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "optimism")]
        Optimism,
    }
    impl ::std::convert::From<&Self> for EvmSwapsNetwork {
        fn from(value: &EvmSwapsNetwork) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EvmSwapsNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base => f.write_str("base"),
                Self::Ethereum => f.write_str("ethereum"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Optimism => f.write_str("optimism"),
            }
        }
    }
    impl ::std::str::FromStr for EvmSwapsNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base" => Ok(Self::Base),
                "ethereum" => Ok(Self::Ethereum),
                "arbitrum" => Ok(Self::Arbitrum),
                "optimism" => Ok(Self::Optimism),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmSwapsNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmSwapsNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmSwapsNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///A schema for specifying criterion for an address field of an EVM typed message. The address can be deeply nested within the typed data's message.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "EvmTypedAddressCondition",
    ///  "description": "A schema for specifying criterion for an address field of an EVM typed message. The address can be deeply nested within the typed data's message.",
    ///  "type": "object",
    ///  "required": [
    ///    "addresses",
    ///    "operator",
    ///    "path"
    ///  ],
    ///  "properties": {
    ///    "addresses": {
    ///      "description": "A list of 0x-prefixed EVM addresses that the value located at the message's path should be compared to. There is a limit of 300 addresses per criterion.",
    ///      "examples": [
    ///        [
    ///          "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///          "0x1234567890123456789012345678901234567890"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "The 0x-prefixed EVM address that the value located at the message's path should be compared to.",
    ///        "type": "string",
    ///        "pattern": "^0x[0-9a-fA-F]{40}$"
    ///      }
    ///    },
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.",
    ///      "examples": [
    ///        "in"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "in",
    ///        "not in"
    ///      ]
    ///    },
    ///    "path": {
    ///      "description": "The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected.",
    ///      "examples": [
    ///        "targets[0].address"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EvmTypedAddressCondition {
        ///A list of 0x-prefixed EVM addresses that the value located at the message's path should be compared to. There is a limit of 300 addresses per criterion.
        pub addresses: ::std::vec::Vec<EvmTypedAddressConditionAddressesItem>,
        ///The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
        pub operator: EvmTypedAddressConditionOperator,
        ///The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected.
        pub path: ::std::string::String,
    }
    impl ::std::convert::From<&EvmTypedAddressCondition> for EvmTypedAddressCondition {
        fn from(value: &EvmTypedAddressCondition) -> Self {
            value.clone()
        }
    }
    impl EvmTypedAddressCondition {
        pub fn builder() -> builder::EvmTypedAddressCondition {
            Default::default()
        }
    }
    ///The 0x-prefixed EVM address that the value located at the message's path should be compared to.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed EVM address that the value located at the message's path should be compared to.",
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EvmTypedAddressConditionAddressesItem(::std::string::String);
    impl ::std::ops::Deref for EvmTypedAddressConditionAddressesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EvmTypedAddressConditionAddressesItem> for ::std::string::String {
        fn from(value: EvmTypedAddressConditionAddressesItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EvmTypedAddressConditionAddressesItem>
        for EvmTypedAddressConditionAddressesItem
    {
        fn from(value: &EvmTypedAddressConditionAddressesItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EvmTypedAddressConditionAddressesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmTypedAddressConditionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmTypedAddressConditionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmTypedAddressConditionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EvmTypedAddressConditionAddressesItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.",
    ///  "examples": [
    ///    "in"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "in",
    ///    "not in"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EvmTypedAddressConditionOperator {
        #[serde(rename = "in")]
        In,
        #[serde(rename = "not in")]
        NotIn,
    }
    impl ::std::convert::From<&Self> for EvmTypedAddressConditionOperator {
        fn from(value: &EvmTypedAddressConditionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EvmTypedAddressConditionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::In => f.write_str("in"),
                Self::NotIn => f.write_str("not in"),
            }
        }
    }
    impl ::std::str::FromStr for EvmTypedAddressConditionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "in" => Ok(Self::In),
                "not in" => Ok(Self::NotIn),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmTypedAddressConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmTypedAddressConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmTypedAddressConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///A schema for specifying criterion for a numerical field of an EVM typed message. The value can be deeply nested within the typed data's message.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "EvmTypedNumericalCondition",
    ///  "description": "A schema for specifying criterion for a numerical field of an EVM typed message. The value can be deeply nested within the typed data's message.",
    ///  "type": "object",
    ///  "required": [
    ///    "operator",
    ///    "path",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.",
    ///      "examples": [
    ///        "<="
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "GreaterThan",
    ///        "GreaterThanOrEqual",
    ///        "LessThan",
    ///        "LessThanOrEqual",
    ///        "Equal"
    ///      ]
    ///    },
    ///    "path": {
    ///      "description": "The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected.",
    ///      "examples": [
    ///        "targets[0].amount"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "value": {
    ///      "description": "The amount that the value located at the message's path should be compared to.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[0-9]+$"
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EvmTypedNumericalCondition {
        ///The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
        pub operator: EvmTypedNumericalConditionOperator,
        ///The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected.
        pub path: ::std::string::String,
        ///The amount that the value located at the message's path should be compared to.
        pub value: EvmTypedNumericalConditionValue,
    }
    impl ::std::convert::From<&EvmTypedNumericalCondition> for EvmTypedNumericalCondition {
        fn from(value: &EvmTypedNumericalCondition) -> Self {
            value.clone()
        }
    }
    impl EvmTypedNumericalCondition {
        pub fn builder() -> builder::EvmTypedNumericalCondition {
            Default::default()
        }
    }
    ///The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.",
    ///  "examples": [
    ///    "<="
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "GreaterThan",
    ///    "GreaterThanOrEqual",
    ///    "LessThan",
    ///    "LessThanOrEqual",
    ///    "Equal"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EvmTypedNumericalConditionOperator {
        GreaterThan,
        GreaterThanOrEqual,
        LessThan,
        LessThanOrEqual,
        Equal,
    }
    impl ::std::convert::From<&Self> for EvmTypedNumericalConditionOperator {
        fn from(value: &EvmTypedNumericalConditionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EvmTypedNumericalConditionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GreaterThan => f.write_str("GreaterThan"),
                Self::GreaterThanOrEqual => f.write_str("GreaterThanOrEqual"),
                Self::LessThan => f.write_str("LessThan"),
                Self::LessThanOrEqual => f.write_str("LessThanOrEqual"),
                Self::Equal => f.write_str("Equal"),
            }
        }
    }
    impl ::std::str::FromStr for EvmTypedNumericalConditionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "GreaterThan" => Ok(Self::GreaterThan),
                "GreaterThanOrEqual" => Ok(Self::GreaterThanOrEqual),
                "LessThan" => Ok(Self::LessThan),
                "LessThanOrEqual" => Ok(Self::LessThanOrEqual),
                "Equal" => Ok(Self::Equal),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmTypedNumericalConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmTypedNumericalConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmTypedNumericalConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The amount that the value located at the message's path should be compared to.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount that the value located at the message's path should be compared to.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[0-9]+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EvmTypedNumericalConditionValue(::std::string::String);
    impl ::std::ops::Deref for EvmTypedNumericalConditionValue {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EvmTypedNumericalConditionValue> for ::std::string::String {
        fn from(value: EvmTypedNumericalConditionValue) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EvmTypedNumericalConditionValue> for EvmTypedNumericalConditionValue {
        fn from(value: &EvmTypedNumericalConditionValue) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EvmTypedNumericalConditionValue {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^[0-9]+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[0-9]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmTypedNumericalConditionValue {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmTypedNumericalConditionValue {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmTypedNumericalConditionValue {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EvmTypedNumericalConditionValue {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///A schema for specifying criterion for a string field of an EVM typed message. The value can be deeply nested within the typed data's message.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "EvmTypedStringCondition",
    ///  "description": "A schema for specifying criterion for a string field of an EVM typed message. The value can be deeply nested within the typed data's message.",
    ///  "type": "object",
    ///  "required": [
    ///    "match",
    ///    "path"
    ///  ],
    ///  "properties": {
    ///    "match": {
    ///      "description": "A regular expression the field is matched against.",
    ///      "examples": [
    ///        "^hello ([a-z]+)$"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "path": {
    ///      "description": "The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected.",
    ///      "examples": [
    ///        "targets[0].message"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EvmTypedStringCondition {
        ///A regular expression the field is matched against.
        #[serde(rename = "match")]
        pub match_: ::std::string::String,
        ///The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected.
        pub path: ::std::string::String,
    }
    impl ::std::convert::From<&EvmTypedStringCondition> for EvmTypedStringCondition {
        fn from(value: &EvmTypedStringCondition) -> Self {
            value.clone()
        }
    }
    impl EvmTypedStringCondition {
        pub fn builder() -> builder::EvmTypedStringCondition {
            Default::default()
        }
    }
    ///`EvmUserOperation`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "calls",
    ///    "network",
    ///    "status",
    ///    "userOpHash"
    ///  ],
    ///  "properties": {
    ///    "calls": {
    ///      "description": "The list of calls in the user operation.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "data": "0xa9059cbb000000000000000000000000fc807d1be4997e5c7b33e4d8d57e60c5b0f02b1a0000000000000000000000000000000000000000000000000000000000000064",
    ///            "to": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    ///            "value": "0"
    ///          },
    ///          {
    ///            "data": "0x",
    ///            "to": "0xdac17f958d2ee523a2206206994597c13d831ec7",
    ///            "value": "1000000000000000"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EvmCall"
    ///      }
    ///    },
    ///    "network": {
    ///      "$ref": "#/components/schemas/EvmUserOperationNetwork"
    ///    },
    ///    "receipts": {
    ///      "description": "The list of receipts associated with the user operation.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "blockHash": "0x386544b58930c0ec9e8f3ed09fb4cdb76b9ae0a1a37ddcacebe3925b57978e65",
    ///            "blockNumber": 29338819,
    ///            "gasUsed": "100000",
    ///            "revert": {
    ///              "data": "0x123",
    ///              "message": "reason for failure"
    ///            }
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UserOperationReceipt"
    ///      }
    ///    },
    ///    "status": {
    ///      "description": "The status of the user operation.",
    ///      "examples": [
    ///        "pending"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "pending",
    ///        "signed",
    ///        "broadcast",
    ///        "complete",
    ///        "dropped",
    ///        "failed"
    ///      ]
    ///    },
    ///    "transactionHash": {
    ///      "description": "The hash of the transaction that included this particular user operation. This gets set after the user operation is broadcasted and the transaction is included in a block.",
    ///      "examples": [
    ///        "0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]{64}$|^$"
    ///    },
    ///    "userOpHash": {
    ///      "description": "The hash of the user operation. This is not the transaction hash, as a transaction consists of multiple user operations. The user operation hash is the hash of this particular user operation which gets signed by the owner of the Smart Account.",
    ///      "examples": [
    ///        "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]{64}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EvmUserOperation {
        ///The list of calls in the user operation.
        pub calls: ::std::vec::Vec<EvmCall>,
        pub network: EvmUserOperationNetwork,
        ///The list of receipts associated with the user operation.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub receipts: ::std::vec::Vec<UserOperationReceipt>,
        ///The status of the user operation.
        pub status: EvmUserOperationStatus,
        ///The hash of the transaction that included this particular user operation. This gets set after the user operation is broadcasted and the transaction is included in a block.
        #[serde(
            rename = "transactionHash",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub transaction_hash: ::std::option::Option<EvmUserOperationTransactionHash>,
        ///The hash of the user operation. This is not the transaction hash, as a transaction consists of multiple user operations. The user operation hash is the hash of this particular user operation which gets signed by the owner of the Smart Account.
        #[serde(rename = "userOpHash")]
        pub user_op_hash: EvmUserOperationUserOpHash,
    }
    impl ::std::convert::From<&EvmUserOperation> for EvmUserOperation {
        fn from(value: &EvmUserOperation) -> Self {
            value.clone()
        }
    }
    impl EvmUserOperation {
        pub fn builder() -> builder::EvmUserOperation {
            Default::default()
        }
    }
    ///The network the user operation is for.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The network the user operation is for.",
    ///  "examples": [
    ///    "base"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "base-sepolia",
    ///    "base",
    ///    "arbitrum",
    ///    "optimism",
    ///    "zora",
    ///    "polygon",
    ///    "bnb",
    ///    "avalanche",
    ///    "ethereum",
    ///    "ethereum-sepolia"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EvmUserOperationNetwork {
        #[serde(rename = "base-sepolia")]
        BaseSepolia,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "optimism")]
        Optimism,
        #[serde(rename = "zora")]
        Zora,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "bnb")]
        Bnb,
        #[serde(rename = "avalanche")]
        Avalanche,
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "ethereum-sepolia")]
        EthereumSepolia,
    }
    impl ::std::convert::From<&Self> for EvmUserOperationNetwork {
        fn from(value: &EvmUserOperationNetwork) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EvmUserOperationNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BaseSepolia => f.write_str("base-sepolia"),
                Self::Base => f.write_str("base"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Optimism => f.write_str("optimism"),
                Self::Zora => f.write_str("zora"),
                Self::Polygon => f.write_str("polygon"),
                Self::Bnb => f.write_str("bnb"),
                Self::Avalanche => f.write_str("avalanche"),
                Self::Ethereum => f.write_str("ethereum"),
                Self::EthereumSepolia => f.write_str("ethereum-sepolia"),
            }
        }
    }
    impl ::std::str::FromStr for EvmUserOperationNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base-sepolia" => Ok(Self::BaseSepolia),
                "base" => Ok(Self::Base),
                "arbitrum" => Ok(Self::Arbitrum),
                "optimism" => Ok(Self::Optimism),
                "zora" => Ok(Self::Zora),
                "polygon" => Ok(Self::Polygon),
                "bnb" => Ok(Self::Bnb),
                "avalanche" => Ok(Self::Avalanche),
                "ethereum" => Ok(Self::Ethereum),
                "ethereum-sepolia" => Ok(Self::EthereumSepolia),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmUserOperationNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmUserOperationNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmUserOperationNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The status of the user operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of the user operation.",
    ///  "examples": [
    ///    "pending"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "pending",
    ///    "signed",
    ///    "broadcast",
    ///    "complete",
    ///    "dropped",
    ///    "failed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EvmUserOperationStatus {
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "signed")]
        Signed,
        #[serde(rename = "broadcast")]
        Broadcast,
        #[serde(rename = "complete")]
        Complete,
        #[serde(rename = "dropped")]
        Dropped,
        #[serde(rename = "failed")]
        Failed,
    }
    impl ::std::convert::From<&Self> for EvmUserOperationStatus {
        fn from(value: &EvmUserOperationStatus) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EvmUserOperationStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pending => f.write_str("pending"),
                Self::Signed => f.write_str("signed"),
                Self::Broadcast => f.write_str("broadcast"),
                Self::Complete => f.write_str("complete"),
                Self::Dropped => f.write_str("dropped"),
                Self::Failed => f.write_str("failed"),
            }
        }
    }
    impl ::std::str::FromStr for EvmUserOperationStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "pending" => Ok(Self::Pending),
                "signed" => Ok(Self::Signed),
                "broadcast" => Ok(Self::Broadcast),
                "complete" => Ok(Self::Complete),
                "dropped" => Ok(Self::Dropped),
                "failed" => Ok(Self::Failed),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmUserOperationStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmUserOperationStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmUserOperationStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The hash of the transaction that included this particular user operation. This gets set after the user operation is broadcasted and the transaction is included in a block.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The hash of the transaction that included this particular user operation. This gets set after the user operation is broadcasted and the transaction is included in a block.",
    ///  "examples": [
    ///    "0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{64}$|^$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EvmUserOperationTransactionHash(::std::string::String);
    impl ::std::ops::Deref for EvmUserOperationTransactionHash {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EvmUserOperationTransactionHash> for ::std::string::String {
        fn from(value: EvmUserOperationTransactionHash) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EvmUserOperationTransactionHash> for EvmUserOperationTransactionHash {
        fn from(value: &EvmUserOperationTransactionHash) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EvmUserOperationTransactionHash {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{64}$|^$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{64}$|^$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmUserOperationTransactionHash {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmUserOperationTransactionHash {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmUserOperationTransactionHash {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EvmUserOperationTransactionHash {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The hash of the user operation. This is not the transaction hash, as a transaction consists of multiple user operations. The user operation hash is the hash of this particular user operation which gets signed by the owner of the Smart Account.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The hash of the user operation. This is not the transaction hash, as a transaction consists of multiple user operations. The user operation hash is the hash of this particular user operation which gets signed by the owner of the Smart Account.",
    ///  "examples": [
    ///    "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{64}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EvmUserOperationUserOpHash(::std::string::String);
    impl ::std::ops::Deref for EvmUserOperationUserOpHash {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EvmUserOperationUserOpHash> for ::std::string::String {
        fn from(value: EvmUserOperationUserOpHash) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EvmUserOperationUserOpHash> for EvmUserOperationUserOpHash {
        fn from(value: &EvmUserOperationUserOpHash) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EvmUserOperationUserOpHash {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{64}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{64}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EvmUserOperationUserOpHash {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EvmUserOperationUserOpHash {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EvmUserOperationUserOpHash {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EvmUserOperationUserOpHash {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`ExportEvmAccountAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ExportEvmAccountAddress(::std::string::String);
    impl ::std::ops::Deref for ExportEvmAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ExportEvmAccountAddress> for ::std::string::String {
        fn from(value: ExportEvmAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ExportEvmAccountAddress> for ExportEvmAccountAddress {
        fn from(value: &ExportEvmAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ExportEvmAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ExportEvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ExportEvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ExportEvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ExportEvmAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`ExportEvmAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "exportEncryptionKey"
    ///  ],
    ///  "properties": {
    ///    "exportEncryptionKey": {
    ///      "description": "The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.",
    ///      "examples": [
    ///        "U2FsdGVkX1+vupppZksvRf5X5YgHq4+da+Q4qf51+Q4="
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ExportEvmAccountBody {
        ///The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
        #[serde(rename = "exportEncryptionKey")]
        pub export_encryption_key: ::std::string::String,
    }
    impl ::std::convert::From<&ExportEvmAccountBody> for ExportEvmAccountBody {
        fn from(value: &ExportEvmAccountBody) -> Self {
            value.clone()
        }
    }
    impl ExportEvmAccountBody {
        pub fn builder() -> builder::ExportEvmAccountBody {
            Default::default()
        }
    }
    ///`ExportEvmAccountByNameBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "exportEncryptionKey"
    ///  ],
    ///  "properties": {
    ///    "exportEncryptionKey": {
    ///      "description": "The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.",
    ///      "examples": [
    ///        "U2FsdGVkX1+vupppZksvRf5X5YgHq4+da+Q4qf51+Q4="
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ExportEvmAccountByNameBody {
        ///The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
        #[serde(rename = "exportEncryptionKey")]
        pub export_encryption_key: ::std::string::String,
    }
    impl ::std::convert::From<&ExportEvmAccountByNameBody> for ExportEvmAccountByNameBody {
        fn from(value: &ExportEvmAccountByNameBody) -> Self {
            value.clone()
        }
    }
    impl ExportEvmAccountByNameBody {
        pub fn builder() -> builder::ExportEvmAccountByNameBody {
            Default::default()
        }
    }
    ///`ExportEvmAccountByNameResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encryptedPrivateKey"
    ///  ],
    ///  "properties": {
    ///    "encryptedPrivateKey": {
    ///      "description": "The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.",
    ///      "examples": [
    ///        "U2FsdGVkX1+vupppZksvRf5X5YgHq4+da+Q4qf51+Q4="
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ExportEvmAccountByNameResponse {
        ///The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
        #[serde(rename = "encryptedPrivateKey")]
        pub encrypted_private_key: ::std::string::String,
    }
    impl ::std::convert::From<&ExportEvmAccountByNameResponse> for ExportEvmAccountByNameResponse {
        fn from(value: &ExportEvmAccountByNameResponse) -> Self {
            value.clone()
        }
    }
    impl ExportEvmAccountByNameResponse {
        pub fn builder() -> builder::ExportEvmAccountByNameResponse {
            Default::default()
        }
    }
    ///`ExportEvmAccountByNameXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ExportEvmAccountByNameXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for ExportEvmAccountByNameXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ExportEvmAccountByNameXIdempotencyKey> for ::std::string::String {
        fn from(value: ExportEvmAccountByNameXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ExportEvmAccountByNameXIdempotencyKey>
        for ExportEvmAccountByNameXIdempotencyKey
    {
        fn from(value: &ExportEvmAccountByNameXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ExportEvmAccountByNameXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ExportEvmAccountByNameXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ExportEvmAccountByNameXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ExportEvmAccountByNameXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ExportEvmAccountByNameXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`ExportEvmAccountResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encryptedPrivateKey"
    ///  ],
    ///  "properties": {
    ///    "encryptedPrivateKey": {
    ///      "description": "The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.",
    ///      "examples": [
    ///        "U2FsdGVkX1+vupppZksvRf5X5YgHq4+da+Q4qf51+Q4="
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ExportEvmAccountResponse {
        ///The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
        #[serde(rename = "encryptedPrivateKey")]
        pub encrypted_private_key: ::std::string::String,
    }
    impl ::std::convert::From<&ExportEvmAccountResponse> for ExportEvmAccountResponse {
        fn from(value: &ExportEvmAccountResponse) -> Self {
            value.clone()
        }
    }
    impl ExportEvmAccountResponse {
        pub fn builder() -> builder::ExportEvmAccountResponse {
            Default::default()
        }
    }
    ///`ExportEvmAccountXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ExportEvmAccountXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for ExportEvmAccountXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ExportEvmAccountXIdempotencyKey> for ::std::string::String {
        fn from(value: ExportEvmAccountXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ExportEvmAccountXIdempotencyKey> for ExportEvmAccountXIdempotencyKey {
        fn from(value: &ExportEvmAccountXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ExportEvmAccountXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ExportEvmAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ExportEvmAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ExportEvmAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ExportEvmAccountXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`ExportSolanaAccountAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ExportSolanaAccountAddress(::std::string::String);
    impl ::std::ops::Deref for ExportSolanaAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ExportSolanaAccountAddress> for ::std::string::String {
        fn from(value: ExportSolanaAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ExportSolanaAccountAddress> for ExportSolanaAccountAddress {
        fn from(value: &ExportSolanaAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ExportSolanaAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ExportSolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ExportSolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ExportSolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ExportSolanaAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`ExportSolanaAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "exportEncryptionKey"
    ///  ],
    ///  "properties": {
    ///    "exportEncryptionKey": {
    ///      "description": "The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.",
    ///      "examples": [
    ///        "U2FsdGVkX1+vupppZksvRf5X5YgHq4+da+Q4qf51+Q4="
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ExportSolanaAccountBody {
        ///The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
        #[serde(rename = "exportEncryptionKey")]
        pub export_encryption_key: ::std::string::String,
    }
    impl ::std::convert::From<&ExportSolanaAccountBody> for ExportSolanaAccountBody {
        fn from(value: &ExportSolanaAccountBody) -> Self {
            value.clone()
        }
    }
    impl ExportSolanaAccountBody {
        pub fn builder() -> builder::ExportSolanaAccountBody {
            Default::default()
        }
    }
    ///`ExportSolanaAccountByNameBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "exportEncryptionKey"
    ///  ],
    ///  "properties": {
    ///    "exportEncryptionKey": {
    ///      "description": "The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.",
    ///      "examples": [
    ///        "U2FsdGVkX1+vupppZksvRf5X5YgHq4+da+Q4qf51+Q4="
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ExportSolanaAccountByNameBody {
        ///The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
        #[serde(rename = "exportEncryptionKey")]
        pub export_encryption_key: ::std::string::String,
    }
    impl ::std::convert::From<&ExportSolanaAccountByNameBody> for ExportSolanaAccountByNameBody {
        fn from(value: &ExportSolanaAccountByNameBody) -> Self {
            value.clone()
        }
    }
    impl ExportSolanaAccountByNameBody {
        pub fn builder() -> builder::ExportSolanaAccountByNameBody {
            Default::default()
        }
    }
    ///`ExportSolanaAccountByNameResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encryptedPrivateKey"
    ///  ],
    ///  "properties": {
    ///    "encryptedPrivateKey": {
    ///      "description": "The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.",
    ///      "examples": [
    ///        "U2FsdGVkX1+vupppZksvRf5X5YgHq4+da+Q4qf51+Q4="
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ExportSolanaAccountByNameResponse {
        ///The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
        #[serde(rename = "encryptedPrivateKey")]
        pub encrypted_private_key: ::std::string::String,
    }
    impl ::std::convert::From<&ExportSolanaAccountByNameResponse>
        for ExportSolanaAccountByNameResponse
    {
        fn from(value: &ExportSolanaAccountByNameResponse) -> Self {
            value.clone()
        }
    }
    impl ExportSolanaAccountByNameResponse {
        pub fn builder() -> builder::ExportSolanaAccountByNameResponse {
            Default::default()
        }
    }
    ///`ExportSolanaAccountByNameXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ExportSolanaAccountByNameXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for ExportSolanaAccountByNameXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ExportSolanaAccountByNameXIdempotencyKey> for ::std::string::String {
        fn from(value: ExportSolanaAccountByNameXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ExportSolanaAccountByNameXIdempotencyKey>
        for ExportSolanaAccountByNameXIdempotencyKey
    {
        fn from(value: &ExportSolanaAccountByNameXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ExportSolanaAccountByNameXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ExportSolanaAccountByNameXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ExportSolanaAccountByNameXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ExportSolanaAccountByNameXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ExportSolanaAccountByNameXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`ExportSolanaAccountResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encryptedPrivateKey"
    ///  ],
    ///  "properties": {
    ///    "encryptedPrivateKey": {
    ///      "description": "The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.",
    ///      "examples": [
    ///        "U2FsdGVkX1+vupppZksvRf5X5YgHq4+da+Q4qf51+Q4="
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ExportSolanaAccountResponse {
        ///The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
        #[serde(rename = "encryptedPrivateKey")]
        pub encrypted_private_key: ::std::string::String,
    }
    impl ::std::convert::From<&ExportSolanaAccountResponse> for ExportSolanaAccountResponse {
        fn from(value: &ExportSolanaAccountResponse) -> Self {
            value.clone()
        }
    }
    impl ExportSolanaAccountResponse {
        pub fn builder() -> builder::ExportSolanaAccountResponse {
            Default::default()
        }
    }
    ///`ExportSolanaAccountXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ExportSolanaAccountXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for ExportSolanaAccountXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ExportSolanaAccountXIdempotencyKey> for ::std::string::String {
        fn from(value: ExportSolanaAccountXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ExportSolanaAccountXIdempotencyKey>
        for ExportSolanaAccountXIdempotencyKey
    {
        fn from(value: &ExportSolanaAccountXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ExportSolanaAccountXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ExportSolanaAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ExportSolanaAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ExportSolanaAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ExportSolanaAccountXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The amount of the `fromToken` to send in atomic units of the token. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount of the `fromToken` to send in atomic units of the token. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct FromAmount(::std::string::String);
    impl ::std::ops::Deref for FromAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<FromAmount> for ::std::string::String {
        fn from(value: FromAmount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&FromAmount> for FromAmount {
        fn from(value: &FromAmount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for FromAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for FromAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for FromAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for FromAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FromAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed contract address of the token to send.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed contract address of the token to send.",
    ///  "examples": [
    ///    "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct FromToken(::std::string::String);
    impl ::std::ops::Deref for FromToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<FromToken> for ::std::string::String {
        fn from(value: FromToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&FromToken> for FromToken {
        fn from(value: &FromToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for FromToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for FromToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for FromToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for FromToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FromToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The target gas price for the swap transaction, in Wei. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. If not provided, the API will use an estimate based on the current network conditions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The target gas price for the swap transaction, in Wei. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. If not provided, the API will use an estimate based on the current network conditions.",
    ///  "examples": [
    ///    "1000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GasPrice(::std::string::String);
    impl ::std::ops::Deref for GasPrice {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GasPrice> for ::std::string::String {
        fn from(value: GasPrice) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GasPrice> for GasPrice {
        fn from(value: &GasPrice) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GasPrice {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GasPrice {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GasPrice {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GasPrice {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GasPrice {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`GetEndUserUserId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[a-zA-Z0-9-]{1,100}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetEndUserUserId(::std::string::String);
    impl ::std::ops::Deref for GetEndUserUserId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetEndUserUserId> for ::std::string::String {
        fn from(value: GetEndUserUserId) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetEndUserUserId> for GetEndUserUserId {
        fn from(value: &GetEndUserUserId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetEndUserUserId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[a-zA-Z0-9-]{1,100}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[a-zA-Z0-9-]{1,100}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetEndUserUserId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetEndUserUserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetEndUserUserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetEndUserUserId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`GetEvmAccountAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetEvmAccountAddress(::std::string::String);
    impl ::std::ops::Deref for GetEvmAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetEvmAccountAddress> for ::std::string::String {
        fn from(value: GetEvmAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetEvmAccountAddress> for GetEvmAccountAddress {
        fn from(value: &GetEvmAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetEvmAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetEvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetEvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetEvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetEvmAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`GetEvmSmartAccountAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetEvmSmartAccountAddress(::std::string::String);
    impl ::std::ops::Deref for GetEvmSmartAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetEvmSmartAccountAddress> for ::std::string::String {
        fn from(value: GetEvmSmartAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetEvmSmartAccountAddress> for GetEvmSmartAccountAddress {
        fn from(value: &GetEvmSmartAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetEvmSmartAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetEvmSmartAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetEvmSmartAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetEvmSmartAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetEvmSmartAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`GetOnrampOrderByIdResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "order"
    ///  ],
    ///  "properties": {
    ///    "order": {
    ///      "$ref": "#/components/schemas/OnrampOrder"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct GetOnrampOrderByIdResponse {
        pub order: OnrampOrder,
    }
    impl ::std::convert::From<&GetOnrampOrderByIdResponse> for GetOnrampOrderByIdResponse {
        fn from(value: &GetOnrampOrderByIdResponse) -> Self {
            value.clone()
        }
    }
    impl GetOnrampOrderByIdResponse {
        pub fn builder() -> builder::GetOnrampOrderByIdResponse {
            Default::default()
        }
    }
    ///`GetPolicyByIdPolicyId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetPolicyByIdPolicyId(::std::string::String);
    impl ::std::ops::Deref for GetPolicyByIdPolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetPolicyByIdPolicyId> for ::std::string::String {
        fn from(value: GetPolicyByIdPolicyId) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetPolicyByIdPolicyId> for GetPolicyByIdPolicyId {
        fn from(value: &GetPolicyByIdPolicyId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetPolicyByIdPolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(
                || {
                    ::regress::Regex::new(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
                    )
                    .unwrap()
                },
            );
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetPolicyByIdPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetPolicyByIdPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetPolicyByIdPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetPolicyByIdPolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`GetSolanaAccountAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetSolanaAccountAddress(::std::string::String);
    impl ::std::ops::Deref for GetSolanaAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetSolanaAccountAddress> for ::std::string::String {
        fn from(value: GetSolanaAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetSolanaAccountAddress> for GetSolanaAccountAddress {
        fn from(value: &GetSolanaAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSolanaAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetSolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetSolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSolanaAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`GetSwapPriceResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "GetSwapPriceResponse",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/CommonSwapResponse"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "gas",
    ///        "gasPrice"
    ///      ],
    ///      "properties": {
    ///        "gas": {
    ///          "description": "The estimated gas limit that should be used to send the transaction to guarantee settlement.",
    ///          "examples": [
    ///            "100000"
    ///          ],
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "pattern": "^\\d+$"
    ///        },
    ///        "gasPrice": {
    ///          "description": "The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.",
    ///          "examples": [
    ///            "1000000000"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^\\d+$"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct GetSwapPriceResponse {
        ///The block number at which the liquidity conditions were examined.
        #[serde(rename = "blockNumber")]
        pub block_number: GetSwapPriceResponseBlockNumber,
        pub fees: GetSwapPriceResponseFees,
        ///The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
        #[serde(rename = "fromAmount")]
        pub from_amount: GetSwapPriceResponseFromAmount,
        ///The 0x-prefixed contract address of the token that will be sent.
        #[serde(rename = "fromToken")]
        pub from_token: GetSwapPriceResponseFromToken,
        ///The estimated gas limit that should be used to send the transaction to guarantee settlement.
        pub gas: ::std::option::Option<GetSwapPriceResponseGas>,
        ///The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.
        #[serde(rename = "gasPrice")]
        pub gas_price: GetSwapPriceResponseGasPrice,
        pub issues: GetSwapPriceResponseIssues,
        ///Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
        #[serde(rename = "liquidityAvailable")]
        pub liquidity_available: bool,
        ///The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
        #[serde(rename = "minToAmount")]
        pub min_to_amount: GetSwapPriceResponseMinToAmount,
        ///The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
        #[serde(rename = "toAmount")]
        pub to_amount: GetSwapPriceResponseToAmount,
        ///The 0x-prefixed contract address of the token that will be received.
        #[serde(rename = "toToken")]
        pub to_token: GetSwapPriceResponseToToken,
    }
    impl ::std::convert::From<&GetSwapPriceResponse> for GetSwapPriceResponse {
        fn from(value: &GetSwapPriceResponse) -> Self {
            value.clone()
        }
    }
    impl GetSwapPriceResponse {
        pub fn builder() -> builder::GetSwapPriceResponse {
            Default::default()
        }
    }
    ///The block number at which the liquidity conditions were examined.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The block number at which the liquidity conditions were examined.",
    ///  "examples": [
    ///    "17038723"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[1-9]\\d*$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetSwapPriceResponseBlockNumber(::std::string::String);
    impl ::std::ops::Deref for GetSwapPriceResponseBlockNumber {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetSwapPriceResponseBlockNumber> for ::std::string::String {
        fn from(value: GetSwapPriceResponseBlockNumber) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetSwapPriceResponseBlockNumber> for GetSwapPriceResponseBlockNumber {
        fn from(value: &GetSwapPriceResponseBlockNumber) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSwapPriceResponseBlockNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^[1-9]\\d*$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9]\\d*$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSwapPriceResponseBlockNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetSwapPriceResponseBlockNumber {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetSwapPriceResponseBlockNumber {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSwapPriceResponseBlockNumber {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The estimated fees for the swap.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The estimated fees for the swap.",
    ///  "examples": [
    ///    {
    ///      "gasFee": {
    ///        "amount": "1000000000000000000",
    ///        "token": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///      },
    ///      "protocolFee": {
    ///        "amount": "1000000000000000000",
    ///        "token": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "gasFee",
    ///    "protocolFee"
    ///  ],
    ///  "properties": {
    ///    "gasFee": {
    ///      "description": "The estimated gas fee for the swap.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/TokenFee"
    ///        }
    ///      ]
    ///    },
    ///    "protocolFee": {
    ///      "description": "The estimated protocol fee for the swap.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/TokenFee"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct GetSwapPriceResponseFees {
        ///The estimated gas fee for the swap.
        #[serde(rename = "gasFee")]
        pub gas_fee: ::std::option::Option<TokenFee>,
        ///The estimated protocol fee for the swap.
        #[serde(rename = "protocolFee")]
        pub protocol_fee: ::std::option::Option<TokenFee>,
    }
    impl ::std::convert::From<&GetSwapPriceResponseFees> for GetSwapPriceResponseFees {
        fn from(value: &GetSwapPriceResponseFees) -> Self {
            value.clone()
        }
    }
    impl GetSwapPriceResponseFees {
        pub fn builder() -> builder::GetSwapPriceResponseFees {
            Default::default()
        }
    }
    ///The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0|[1-9]\\d*)$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetSwapPriceResponseFromAmount(::std::string::String);
    impl ::std::ops::Deref for GetSwapPriceResponseFromAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetSwapPriceResponseFromAmount> for ::std::string::String {
        fn from(value: GetSwapPriceResponseFromAmount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetSwapPriceResponseFromAmount> for GetSwapPriceResponseFromAmount {
        fn from(value: &GetSwapPriceResponseFromAmount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSwapPriceResponseFromAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(0|[1-9]\\d*)$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^(0|[1-9]\\d*)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSwapPriceResponseFromAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetSwapPriceResponseFromAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetSwapPriceResponseFromAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSwapPriceResponseFromAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed contract address of the token that will be sent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed contract address of the token that will be sent.",
    ///  "examples": [
    ///    "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetSwapPriceResponseFromToken(::std::string::String);
    impl ::std::ops::Deref for GetSwapPriceResponseFromToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetSwapPriceResponseFromToken> for ::std::string::String {
        fn from(value: GetSwapPriceResponseFromToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetSwapPriceResponseFromToken> for GetSwapPriceResponseFromToken {
        fn from(value: &GetSwapPriceResponseFromToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSwapPriceResponseFromToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSwapPriceResponseFromToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetSwapPriceResponseFromToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetSwapPriceResponseFromToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSwapPriceResponseFromToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The estimated gas limit that should be used to send the transaction to guarantee settlement.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The estimated gas limit that should be used to send the transaction to guarantee settlement.",
    ///  "examples": [
    ///    "100000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetSwapPriceResponseGas(::std::string::String);
    impl ::std::ops::Deref for GetSwapPriceResponseGas {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetSwapPriceResponseGas> for ::std::string::String {
        fn from(value: GetSwapPriceResponseGas) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetSwapPriceResponseGas> for GetSwapPriceResponseGas {
        fn from(value: &GetSwapPriceResponseGas) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSwapPriceResponseGas {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSwapPriceResponseGas {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetSwapPriceResponseGas {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetSwapPriceResponseGas {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSwapPriceResponseGas {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.",
    ///  "examples": [
    ///    "1000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetSwapPriceResponseGasPrice(::std::string::String);
    impl ::std::ops::Deref for GetSwapPriceResponseGasPrice {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetSwapPriceResponseGasPrice> for ::std::string::String {
        fn from(value: GetSwapPriceResponseGasPrice) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetSwapPriceResponseGasPrice> for GetSwapPriceResponseGasPrice {
        fn from(value: &GetSwapPriceResponseGasPrice) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSwapPriceResponseGasPrice {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSwapPriceResponseGasPrice {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetSwapPriceResponseGasPrice {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetSwapPriceResponseGasPrice {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSwapPriceResponseGasPrice {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.",
    ///  "examples": [
    ///    {
    ///      "allowance": {
    ///        "currentAllowance": "1000000000",
    ///        "spender": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///      },
    ///      "balance": {
    ///        "currentBalance": "900000000000000000",
    ///        "requiredBalance": "1000000000000000000",
    ///        "token": "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///      },
    ///      "simulationIncomplete": false
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "allowance",
    ///    "balance",
    ///    "simulationIncomplete"
    ///  ],
    ///  "properties": {
    ///    "allowance": {
    ///      "description": "Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.",
    ///      "examples": [
    ///        {
    ///          "currentAllowance": "1000000000",
    ///          "spender": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///        }
    ///      ],
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "required": [
    ///        "currentAllowance",
    ///        "spender"
    ///      ],
    ///      "properties": {
    ///        "currentAllowance": {
    ///          "description": "The current allowance of the `fromToken` by the `taker`.",
    ///          "examples": [
    ///            "1000000000"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^\\d+$"
    ///        },
    ///        "spender": {
    ///          "description": "The 0x-prefixed address of to set the allowance on.",
    ///          "examples": [
    ///            "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^0x[a-fA-F0-9]{40}$"
    ///        }
    ///      }
    ///    },
    ///    "balance": {
    ///      "description": "Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.",
    ///      "examples": [
    ///        {
    ///          "currentBalance": "1000000000000000000",
    ///          "requiredBalance": "1000000000000000000",
    ///          "token": "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///        }
    ///      ],
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "required": [
    ///        "currentBalance",
    ///        "requiredBalance",
    ///        "token"
    ///      ],
    ///      "properties": {
    ///        "currentBalance": {
    ///          "description": "The current balance of the `fromToken` by the `taker`.",
    ///          "examples": [
    ///            "10000000"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^\\d+$"
    ///        },
    ///        "requiredBalance": {
    ///          "description": "The amount of the token that the `taker` must hold.",
    ///          "examples": [
    ///            "1000000000000000000"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^\\d+$"
    ///        },
    ///        "token": {
    ///          "description": "The 0x-prefixed contract address of the token.",
    ///          "type": "string",
    ///          "pattern": "^0x[a-fA-F0-9]{40}$"
    ///        }
    ///      }
    ///    },
    ///    "simulationIncomplete": {
    ///      "description": "This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct GetSwapPriceResponseIssues {
        ///Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
        pub allowance: ::std::option::Option<GetSwapPriceResponseIssuesAllowance>,
        ///Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
        pub balance: ::std::option::Option<GetSwapPriceResponseIssuesBalance>,
        ///This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.
        #[serde(rename = "simulationIncomplete")]
        pub simulation_incomplete: bool,
    }
    impl ::std::convert::From<&GetSwapPriceResponseIssues> for GetSwapPriceResponseIssues {
        fn from(value: &GetSwapPriceResponseIssues) -> Self {
            value.clone()
        }
    }
    impl GetSwapPriceResponseIssues {
        pub fn builder() -> builder::GetSwapPriceResponseIssues {
            Default::default()
        }
    }
    ///Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.",
    ///  "examples": [
    ///    {
    ///      "currentAllowance": "1000000000",
    ///      "spender": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "currentAllowance",
    ///    "spender"
    ///  ],
    ///  "properties": {
    ///    "currentAllowance": {
    ///      "description": "The current allowance of the `fromToken` by the `taker`.",
    ///      "examples": [
    ///        "1000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    },
    ///    "spender": {
    ///      "description": "The 0x-prefixed address of to set the allowance on.",
    ///      "examples": [
    ///        "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct GetSwapPriceResponseIssuesAllowance {
        ///The current allowance of the `fromToken` by the `taker`.
        #[serde(rename = "currentAllowance")]
        pub current_allowance: GetSwapPriceResponseIssuesAllowanceCurrentAllowance,
        ///The 0x-prefixed address of to set the allowance on.
        pub spender: GetSwapPriceResponseIssuesAllowanceSpender,
    }
    impl ::std::convert::From<&GetSwapPriceResponseIssuesAllowance>
        for GetSwapPriceResponseIssuesAllowance
    {
        fn from(value: &GetSwapPriceResponseIssuesAllowance) -> Self {
            value.clone()
        }
    }
    impl GetSwapPriceResponseIssuesAllowance {
        pub fn builder() -> builder::GetSwapPriceResponseIssuesAllowance {
            Default::default()
        }
    }
    ///The current allowance of the `fromToken` by the `taker`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The current allowance of the `fromToken` by the `taker`.",
    ///  "examples": [
    ///    "1000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetSwapPriceResponseIssuesAllowanceCurrentAllowance(::std::string::String);
    impl ::std::ops::Deref for GetSwapPriceResponseIssuesAllowanceCurrentAllowance {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetSwapPriceResponseIssuesAllowanceCurrentAllowance>
        for ::std::string::String
    {
        fn from(value: GetSwapPriceResponseIssuesAllowanceCurrentAllowance) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetSwapPriceResponseIssuesAllowanceCurrentAllowance>
        for GetSwapPriceResponseIssuesAllowanceCurrentAllowance
    {
        fn from(value: &GetSwapPriceResponseIssuesAllowanceCurrentAllowance) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSwapPriceResponseIssuesAllowanceCurrentAllowance {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSwapPriceResponseIssuesAllowanceCurrentAllowance {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for GetSwapPriceResponseIssuesAllowanceCurrentAllowance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for GetSwapPriceResponseIssuesAllowanceCurrentAllowance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSwapPriceResponseIssuesAllowanceCurrentAllowance {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed address of to set the allowance on.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed address of to set the allowance on.",
    ///  "examples": [
    ///    "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetSwapPriceResponseIssuesAllowanceSpender(::std::string::String);
    impl ::std::ops::Deref for GetSwapPriceResponseIssuesAllowanceSpender {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetSwapPriceResponseIssuesAllowanceSpender> for ::std::string::String {
        fn from(value: GetSwapPriceResponseIssuesAllowanceSpender) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetSwapPriceResponseIssuesAllowanceSpender>
        for GetSwapPriceResponseIssuesAllowanceSpender
    {
        fn from(value: &GetSwapPriceResponseIssuesAllowanceSpender) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSwapPriceResponseIssuesAllowanceSpender {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSwapPriceResponseIssuesAllowanceSpender {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for GetSwapPriceResponseIssuesAllowanceSpender
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetSwapPriceResponseIssuesAllowanceSpender {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSwapPriceResponseIssuesAllowanceSpender {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.",
    ///  "examples": [
    ///    {
    ///      "currentBalance": "1000000000000000000",
    ///      "requiredBalance": "1000000000000000000",
    ///      "token": "0x6B175474E89094C44Da98b954EedeAC495271d0F"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "currentBalance",
    ///    "requiredBalance",
    ///    "token"
    ///  ],
    ///  "properties": {
    ///    "currentBalance": {
    ///      "description": "The current balance of the `fromToken` by the `taker`.",
    ///      "examples": [
    ///        "10000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    },
    ///    "requiredBalance": {
    ///      "description": "The amount of the token that the `taker` must hold.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    },
    ///    "token": {
    ///      "description": "The 0x-prefixed contract address of the token.",
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct GetSwapPriceResponseIssuesBalance {
        ///The current balance of the `fromToken` by the `taker`.
        #[serde(rename = "currentBalance")]
        pub current_balance: GetSwapPriceResponseIssuesBalanceCurrentBalance,
        ///The amount of the token that the `taker` must hold.
        #[serde(rename = "requiredBalance")]
        pub required_balance: GetSwapPriceResponseIssuesBalanceRequiredBalance,
        ///The 0x-prefixed contract address of the token.
        pub token: GetSwapPriceResponseIssuesBalanceToken,
    }
    impl ::std::convert::From<&GetSwapPriceResponseIssuesBalance>
        for GetSwapPriceResponseIssuesBalance
    {
        fn from(value: &GetSwapPriceResponseIssuesBalance) -> Self {
            value.clone()
        }
    }
    impl GetSwapPriceResponseIssuesBalance {
        pub fn builder() -> builder::GetSwapPriceResponseIssuesBalance {
            Default::default()
        }
    }
    ///The current balance of the `fromToken` by the `taker`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The current balance of the `fromToken` by the `taker`.",
    ///  "examples": [
    ///    "10000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetSwapPriceResponseIssuesBalanceCurrentBalance(::std::string::String);
    impl ::std::ops::Deref for GetSwapPriceResponseIssuesBalanceCurrentBalance {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetSwapPriceResponseIssuesBalanceCurrentBalance>
        for ::std::string::String
    {
        fn from(value: GetSwapPriceResponseIssuesBalanceCurrentBalance) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetSwapPriceResponseIssuesBalanceCurrentBalance>
        for GetSwapPriceResponseIssuesBalanceCurrentBalance
    {
        fn from(value: &GetSwapPriceResponseIssuesBalanceCurrentBalance) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSwapPriceResponseIssuesBalanceCurrentBalance {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSwapPriceResponseIssuesBalanceCurrentBalance {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for GetSwapPriceResponseIssuesBalanceCurrentBalance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for GetSwapPriceResponseIssuesBalanceCurrentBalance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSwapPriceResponseIssuesBalanceCurrentBalance {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The amount of the token that the `taker` must hold.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount of the token that the `taker` must hold.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetSwapPriceResponseIssuesBalanceRequiredBalance(::std::string::String);
    impl ::std::ops::Deref for GetSwapPriceResponseIssuesBalanceRequiredBalance {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetSwapPriceResponseIssuesBalanceRequiredBalance>
        for ::std::string::String
    {
        fn from(value: GetSwapPriceResponseIssuesBalanceRequiredBalance) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetSwapPriceResponseIssuesBalanceRequiredBalance>
        for GetSwapPriceResponseIssuesBalanceRequiredBalance
    {
        fn from(value: &GetSwapPriceResponseIssuesBalanceRequiredBalance) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSwapPriceResponseIssuesBalanceRequiredBalance {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSwapPriceResponseIssuesBalanceRequiredBalance {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for GetSwapPriceResponseIssuesBalanceRequiredBalance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for GetSwapPriceResponseIssuesBalanceRequiredBalance
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSwapPriceResponseIssuesBalanceRequiredBalance {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed contract address of the token.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed contract address of the token.",
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetSwapPriceResponseIssuesBalanceToken(::std::string::String);
    impl ::std::ops::Deref for GetSwapPriceResponseIssuesBalanceToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetSwapPriceResponseIssuesBalanceToken> for ::std::string::String {
        fn from(value: GetSwapPriceResponseIssuesBalanceToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetSwapPriceResponseIssuesBalanceToken>
        for GetSwapPriceResponseIssuesBalanceToken
    {
        fn from(value: &GetSwapPriceResponseIssuesBalanceToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSwapPriceResponseIssuesBalanceToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSwapPriceResponseIssuesBalanceToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetSwapPriceResponseIssuesBalanceToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetSwapPriceResponseIssuesBalanceToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSwapPriceResponseIssuesBalanceToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.",
    ///  "examples": [
    ///    "900000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0|[1-9]\\d*)$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetSwapPriceResponseMinToAmount(::std::string::String);
    impl ::std::ops::Deref for GetSwapPriceResponseMinToAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetSwapPriceResponseMinToAmount> for ::std::string::String {
        fn from(value: GetSwapPriceResponseMinToAmount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetSwapPriceResponseMinToAmount> for GetSwapPriceResponseMinToAmount {
        fn from(value: &GetSwapPriceResponseMinToAmount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSwapPriceResponseMinToAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(0|[1-9]\\d*)$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^(0|[1-9]\\d*)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSwapPriceResponseMinToAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetSwapPriceResponseMinToAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetSwapPriceResponseMinToAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSwapPriceResponseMinToAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0|[1-9]\\d*)$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetSwapPriceResponseToAmount(::std::string::String);
    impl ::std::ops::Deref for GetSwapPriceResponseToAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetSwapPriceResponseToAmount> for ::std::string::String {
        fn from(value: GetSwapPriceResponseToAmount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetSwapPriceResponseToAmount> for GetSwapPriceResponseToAmount {
        fn from(value: &GetSwapPriceResponseToAmount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSwapPriceResponseToAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(0|[1-9]\\d*)$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^(0|[1-9]\\d*)$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSwapPriceResponseToAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetSwapPriceResponseToAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetSwapPriceResponseToAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSwapPriceResponseToAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed contract address of the token that will be received.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed contract address of the token that will be received.",
    ///  "examples": [
    ///    "0x7F5c764cBc14f9669B88837ca1490cCa17c31607"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetSwapPriceResponseToToken(::std::string::String);
    impl ::std::ops::Deref for GetSwapPriceResponseToToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetSwapPriceResponseToToken> for ::std::string::String {
        fn from(value: GetSwapPriceResponseToToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetSwapPriceResponseToToken> for GetSwapPriceResponseToToken {
        fn from(value: &GetSwapPriceResponseToToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSwapPriceResponseToToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSwapPriceResponseToToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetSwapPriceResponseToToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetSwapPriceResponseToToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSwapPriceResponseToToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///A wrapper for the response of a swap price operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A wrapper for the response of a swap price operation.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GetSwapPriceResponse"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SwapUnavailableResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GetSwapPriceResponseWrapper {
        GetSwapPriceResponse(GetSwapPriceResponse),
        SwapUnavailableResponse(SwapUnavailableResponse),
    }
    impl ::std::convert::From<&Self> for GetSwapPriceResponseWrapper {
        fn from(value: &GetSwapPriceResponseWrapper) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<GetSwapPriceResponse> for GetSwapPriceResponseWrapper {
        fn from(value: GetSwapPriceResponse) -> Self {
            Self::GetSwapPriceResponse(value)
        }
    }
    impl ::std::convert::From<SwapUnavailableResponse> for GetSwapPriceResponseWrapper {
        fn from(value: SwapUnavailableResponse) -> Self {
            Self::SwapUnavailableResponse(value)
        }
    }
    ///`GetUserOperationAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetUserOperationAddress(::std::string::String);
    impl ::std::ops::Deref for GetUserOperationAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetUserOperationAddress> for ::std::string::String {
        fn from(value: GetUserOperationAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetUserOperationAddress> for GetUserOperationAddress {
        fn from(value: &GetUserOperationAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetUserOperationAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetUserOperationAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetUserOperationAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetUserOperationAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetUserOperationAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`GetUserOperationUserOpHash`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{64}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetUserOperationUserOpHash(::std::string::String);
    impl ::std::ops::Deref for GetUserOperationUserOpHash {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetUserOperationUserOpHash> for ::std::string::String {
        fn from(value: GetUserOperationUserOpHash) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetUserOperationUserOpHash> for GetUserOperationUserOpHash {
        fn from(value: &GetUserOperationUserOpHash) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetUserOperationUserOpHash {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{64}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{64}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetUserOperationUserOpHash {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetUserOperationUserOpHash {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetUserOperationUserOpHash {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetUserOperationUserOpHash {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///IDL Specification following Anchor's IDL format v0.30+.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "IDL Specification following Anchor's IDL format v0.30+.",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "instructions"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The program address.",
    ///      "examples": [
    ///        "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "instructions": {
    ///      "description": "List of program instructions.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "accounts": [
    ///              {
    ///                "name": "mint",
    ///                "writable": true
    ///              },
    ///              {
    ///                "name": "rent"
    ///              }
    ///            ],
    ///            "args": [
    ///              {
    ///                "name": "amount",
    ///                "type": "u64"
    ///              },
    ///              {
    ///                "name": "decimals",
    ///                "type": "u8"
    ///              }
    ///            ],
    ///            "discriminator": [
    ///              119,
    ///              250,
    ///              202,
    ///              24,
    ///              253,
    ///              135,
    ///              244,
    ///              121
    ///            ],
    ///            "name": "transfer_checked"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "args",
    ///          "discriminator",
    ///          "name"
    ///        ],
    ///        "properties": {
    ///          "accounts": {
    ///            "description": "Optional list of accounts required by the instruction.",
    ///            "type": "array",
    ///            "items": {
    ///              "type": "object",
    ///              "required": [
    ///                "name"
    ///              ],
    ///              "properties": {
    ///                "name": {
    ///                  "description": "The account name.",
    ///                  "examples": [
    ///                    "mint"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "signer": {
    ///                  "description": "Whether the account must be a signer.",
    ///                  "examples": [
    ///                    false
    ///                  ],
    ///                  "type": "boolean"
    ///                },
    ///                "writable": {
    ///                  "description": "Whether the account is writable.",
    ///                  "examples": [
    ///                    true
    ///                  ],
    ///                  "type": "boolean"
    ///                }
    ///              }
    ///            }
    ///          },
    ///          "args": {
    ///            "description": "List of instruction arguments.",
    ///            "type": "array",
    ///            "items": {
    ///              "type": "object",
    ///              "required": [
    ///                "name",
    ///                "type"
    ///              ],
    ///              "properties": {
    ///                "name": {
    ///                  "description": "The argument name.",
    ///                  "examples": [
    ///                    "amount"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "type": {
    ///                  "description": "The argument type.",
    ///                  "examples": [
    ///                    "u64"
    ///                  ],
    ///                  "type": "string"
    ///                }
    ///              }
    ///            }
    ///          },
    ///          "discriminator": {
    ///            "description": "Array of 8 numbers representing the instruction discriminator.",
    ///            "examples": [
    ///              [
    ///                119,
    ///                250,
    ///                202,
    ///                24,
    ///                253,
    ///                135,
    ///                244,
    ///                121
    ///              ]
    ///            ],
    ///            "type": "array",
    ///            "items": {
    ///              "type": "integer",
    ///              "maximum": 255.0,
    ///              "minimum": 0.0
    ///            },
    ///            "maxItems": 8,
    ///            "minItems": 8
    ///          },
    ///          "name": {
    ///            "description": "The instruction name.",
    ///            "examples": [
    ///              "transfer_checked"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "metadata": {
    ///      "description": "Optional metadata about the IDL.",
    ///      "examples": [
    ///        {
    ///          "name": "system_program",
    ///          "spec": "0.1.0",
    ///          "version": "0.1.0"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "name": {
    ///          "description": "The program name.",
    ///          "examples": [
    ///            "system_program"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "spec": {
    ///          "description": "The IDL specification version.",
    ///          "examples": [
    ///            "0.1.0"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "version": {
    ///          "description": "The program version.",
    ///          "examples": [
    ///            "0.1.0"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "types": {
    ///      "description": "Optional type definitions for custom data structures used in the program.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "fields": [
    ///              {
    ///                "name": "id",
    ///                "type": "u64"
    ///              },
    ///              {
    ///                "name": "owner",
    ///                "type": "pubkey"
    ///              }
    ///            ],
    ///            "name": "MyStruct",
    ///            "type": "struct"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object"
    ///      }
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct Idl {
        ///The program address.
        pub address: ::std::string::String,
        ///List of program instructions.
        pub instructions: ::std::vec::Vec<IdlInstructionsItem>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<IdlMetadata>,
        ///Optional type definitions for custom data structures used in the program.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub types: ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
    }
    impl ::std::convert::From<&Idl> for Idl {
        fn from(value: &Idl) -> Self {
            value.clone()
        }
    }
    impl Idl {
        pub fn builder() -> builder::Idl {
            Default::default()
        }
    }
    ///`IdlInstructionsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "args",
    ///    "discriminator",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "accounts": {
    ///      "description": "Optional list of accounts required by the instruction.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "name"
    ///        ],
    ///        "properties": {
    ///          "name": {
    ///            "description": "The account name.",
    ///            "examples": [
    ///              "mint"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "signer": {
    ///            "description": "Whether the account must be a signer.",
    ///            "examples": [
    ///              false
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "writable": {
    ///            "description": "Whether the account is writable.",
    ///            "examples": [
    ///              true
    ///            ],
    ///            "type": "boolean"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "args": {
    ///      "description": "List of instruction arguments.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "name",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "name": {
    ///            "description": "The argument name.",
    ///            "examples": [
    ///              "amount"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "type": {
    ///            "description": "The argument type.",
    ///            "examples": [
    ///              "u64"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "discriminator": {
    ///      "description": "Array of 8 numbers representing the instruction discriminator.",
    ///      "examples": [
    ///        [
    ///          119,
    ///          250,
    ///          202,
    ///          24,
    ///          253,
    ///          135,
    ///          244,
    ///          121
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "maximum": 255.0,
    ///        "minimum": 0.0
    ///      },
    ///      "maxItems": 8,
    ///      "minItems": 8
    ///    },
    ///    "name": {
    ///      "description": "The instruction name.",
    ///      "examples": [
    ///        "transfer_checked"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct IdlInstructionsItem {
        ///Optional list of accounts required by the instruction.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub accounts: ::std::vec::Vec<IdlInstructionsItemAccountsItem>,
        ///List of instruction arguments.
        pub args: ::std::vec::Vec<IdlInstructionsItemArgsItem>,
        ///Array of 8 numbers representing the instruction discriminator.
        pub discriminator: [u8; 8usize],
        ///The instruction name.
        pub name: ::std::string::String,
    }
    impl ::std::convert::From<&IdlInstructionsItem> for IdlInstructionsItem {
        fn from(value: &IdlInstructionsItem) -> Self {
            value.clone()
        }
    }
    impl IdlInstructionsItem {
        pub fn builder() -> builder::IdlInstructionsItem {
            Default::default()
        }
    }
    ///`IdlInstructionsItemAccountsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "description": "The account name.",
    ///      "examples": [
    ///        "mint"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "signer": {
    ///      "description": "Whether the account must be a signer.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "writable": {
    ///      "description": "Whether the account is writable.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct IdlInstructionsItemAccountsItem {
        ///The account name.
        pub name: ::std::string::String,
        ///Whether the account must be a signer.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub signer: ::std::option::Option<bool>,
        ///Whether the account is writable.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub writable: ::std::option::Option<bool>,
    }
    impl ::std::convert::From<&IdlInstructionsItemAccountsItem> for IdlInstructionsItemAccountsItem {
        fn from(value: &IdlInstructionsItemAccountsItem) -> Self {
            value.clone()
        }
    }
    impl IdlInstructionsItemAccountsItem {
        pub fn builder() -> builder::IdlInstructionsItemAccountsItem {
            Default::default()
        }
    }
    ///`IdlInstructionsItemArgsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "description": "The argument name.",
    ///      "examples": [
    ///        "amount"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The argument type.",
    ///      "examples": [
    ///        "u64"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct IdlInstructionsItemArgsItem {
        ///The argument name.
        pub name: ::std::string::String,
        ///The argument type.
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }
    impl ::std::convert::From<&IdlInstructionsItemArgsItem> for IdlInstructionsItemArgsItem {
        fn from(value: &IdlInstructionsItemArgsItem) -> Self {
            value.clone()
        }
    }
    impl IdlInstructionsItemArgsItem {
        pub fn builder() -> builder::IdlInstructionsItemArgsItem {
            Default::default()
        }
    }
    ///Optional metadata about the IDL.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Optional metadata about the IDL.",
    ///  "examples": [
    ///    {
    ///      "name": "system_program",
    ///      "spec": "0.1.0",
    ///      "version": "0.1.0"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "name": {
    ///      "description": "The program name.",
    ///      "examples": [
    ///        "system_program"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "spec": {
    ///      "description": "The IDL specification version.",
    ///      "examples": [
    ///        "0.1.0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "version": {
    ///      "description": "The program version.",
    ///      "examples": [
    ///        "0.1.0"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct IdlMetadata {
        ///The program name.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The IDL specification version.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub spec: ::std::option::Option<::std::string::String>,
        ///The program version.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub version: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&IdlMetadata> for IdlMetadata {
        fn from(value: &IdlMetadata) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for IdlMetadata {
        fn default() -> Self {
            Self {
                name: Default::default(),
                spec: Default::default(),
                version: Default::default(),
            }
        }
    }
    impl IdlMetadata {
        pub fn builder() -> builder::IdlMetadata {
            Default::default()
        }
    }
    ///`ImportEvmAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encryptedPrivateKey"
    ///  ],
    ///  "properties": {
    ///    "accountPolicy": {
    ///      "description": "The ID of the account-level policy to apply to the account.",
    ///      "examples": [
    ///        "123e4567-e89b-12d3-a456-426614174000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
    ///      "x-audience": "public"
    ///    },
    ///    "encryptedPrivateKey": {
    ///      "description": "The base64-encoded, encrypted private key of the EVM account. The private key must be encrypted using the CDP SDK's encryption scheme.",
    ///      "examples": [
    ///        "U2FsdGVkX1+vupppZksvRf5X5YgHq4+da+Q4qf51+Q4="
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.",
    ///      "examples": [
    ///        "my-wallet"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ImportEvmAccountBody {
        ///The ID of the account-level policy to apply to the account.
        #[serde(
            rename = "accountPolicy",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub account_policy: ::std::option::Option<ImportEvmAccountBodyAccountPolicy>,
        ///The base64-encoded, encrypted private key of the EVM account. The private key must be encrypted using the CDP SDK's encryption scheme.
        #[serde(rename = "encryptedPrivateKey")]
        pub encrypted_private_key: ::std::string::String,
        /**An optional name for the account.
        Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
        Account names must be unique across all EVM accounts in the developer's CDP Project.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<ImportEvmAccountBodyName>,
    }
    impl ::std::convert::From<&ImportEvmAccountBody> for ImportEvmAccountBody {
        fn from(value: &ImportEvmAccountBody) -> Self {
            value.clone()
        }
    }
    impl ImportEvmAccountBody {
        pub fn builder() -> builder::ImportEvmAccountBody {
            Default::default()
        }
    }
    ///The ID of the account-level policy to apply to the account.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The ID of the account-level policy to apply to the account.",
    ///  "examples": [
    ///    "123e4567-e89b-12d3-a456-426614174000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ImportEvmAccountBodyAccountPolicy(::std::string::String);
    impl ::std::ops::Deref for ImportEvmAccountBodyAccountPolicy {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ImportEvmAccountBodyAccountPolicy> for ::std::string::String {
        fn from(value: ImportEvmAccountBodyAccountPolicy) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ImportEvmAccountBodyAccountPolicy>
        for ImportEvmAccountBodyAccountPolicy
    {
        fn from(value: &ImportEvmAccountBodyAccountPolicy) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ImportEvmAccountBodyAccountPolicy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(
                || {
                    ::regress::Regex::new(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
                    )
                    .unwrap()
                },
            );
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ImportEvmAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ImportEvmAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ImportEvmAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ImportEvmAccountBodyAccountPolicy {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    /**An optional name for the account.
    Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
    Account names must be unique across all EVM accounts in the developer's CDP Project.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.",
    ///  "examples": [
    ///    "my-wallet"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ImportEvmAccountBodyName(::std::string::String);
    impl ::std::ops::Deref for ImportEvmAccountBodyName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ImportEvmAccountBodyName> for ::std::string::String {
        fn from(value: ImportEvmAccountBodyName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ImportEvmAccountBodyName> for ImportEvmAccountBodyName {
        fn from(value: &ImportEvmAccountBodyName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ImportEvmAccountBodyName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ImportEvmAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ImportEvmAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ImportEvmAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ImportEvmAccountBodyName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`ImportEvmAccountXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ImportEvmAccountXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for ImportEvmAccountXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ImportEvmAccountXIdempotencyKey> for ::std::string::String {
        fn from(value: ImportEvmAccountXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ImportEvmAccountXIdempotencyKey> for ImportEvmAccountXIdempotencyKey {
        fn from(value: &ImportEvmAccountXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ImportEvmAccountXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ImportEvmAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ImportEvmAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ImportEvmAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ImportEvmAccountXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`ImportSolanaAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encryptedPrivateKey"
    ///  ],
    ///  "properties": {
    ///    "encryptedPrivateKey": {
    ///      "description": "The base64-encoded, encrypted 32-byte private key of the Solana account. The private key must be encrypted using the CDP SDK's encryption scheme.",
    ///      "examples": [
    ///        "U2FsdGVkX1+vupppZksvRf5X5YgHq4+da+Q4qf51+Q4="
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.",
    ///      "examples": [
    ///        "my-solana-wallet"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ImportSolanaAccountBody {
        ///The base64-encoded, encrypted 32-byte private key of the Solana account. The private key must be encrypted using the CDP SDK's encryption scheme.
        #[serde(rename = "encryptedPrivateKey")]
        pub encrypted_private_key: ::std::string::String,
        /**An optional name for the account.
        Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
        Account names must be unique across all EVM accounts in the developer's CDP Project.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<ImportSolanaAccountBodyName>,
    }
    impl ::std::convert::From<&ImportSolanaAccountBody> for ImportSolanaAccountBody {
        fn from(value: &ImportSolanaAccountBody) -> Self {
            value.clone()
        }
    }
    impl ImportSolanaAccountBody {
        pub fn builder() -> builder::ImportSolanaAccountBody {
            Default::default()
        }
    }
    /**An optional name for the account.
    Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
    Account names must be unique across all EVM accounts in the developer's CDP Project.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.",
    ///  "examples": [
    ///    "my-solana-wallet"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ImportSolanaAccountBodyName(::std::string::String);
    impl ::std::ops::Deref for ImportSolanaAccountBodyName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ImportSolanaAccountBodyName> for ::std::string::String {
        fn from(value: ImportSolanaAccountBodyName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ImportSolanaAccountBodyName> for ImportSolanaAccountBodyName {
        fn from(value: &ImportSolanaAccountBodyName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ImportSolanaAccountBodyName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ImportSolanaAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ImportSolanaAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ImportSolanaAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ImportSolanaAccountBodyName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`ImportSolanaAccountXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ImportSolanaAccountXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for ImportSolanaAccountXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ImportSolanaAccountXIdempotencyKey> for ::std::string::String {
        fn from(value: ImportSolanaAccountXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ImportSolanaAccountXIdempotencyKey>
        for ImportSolanaAccountXIdempotencyKey
    {
        fn from(value: &ImportSolanaAccountXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ImportSolanaAccountXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ImportSolanaAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ImportSolanaAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ImportSolanaAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ImportSolanaAccountXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    /**A reference to an established EIP standard. When referencing a `KnownAbiType` within a policy rule configuring an `EvmDataCriterion`, criteria will only decode function data officially documented in the standard. For more information on supported token standards, see the links below.
    - [erc20 - Token Standard](https://eips.ethereum.org/EIPS/eip-20).
    - [erc721 - Non-Fungible Token Standard](https://eips.ethereum.org/EIPS/eip-721).
    - [erc1155 - Multi Token Standard](https://eips.ethereum.org/EIPS/eip-1155).*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "KnownAbiType",
    ///  "description": "A reference to an established EIP standard. When referencing a `KnownAbiType` within a policy rule configuring an `EvmDataCriterion`, criteria will only decode function data officially documented in the standard. For more information on supported token standards, see the links below.\n  - [erc20 - Token Standard](https://eips.ethereum.org/EIPS/eip-20).\n  - [erc721 - Non-Fungible Token Standard](https://eips.ethereum.org/EIPS/eip-721).\n  - [erc1155 - Multi Token Standard](https://eips.ethereum.org/EIPS/eip-1155).",
    ///  "type": "string",
    ///  "enum": [
    ///    "erc20",
    ///    "erc721",
    ///    "erc1155"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum KnownAbiType {
        #[serde(rename = "erc20")]
        Erc20,
        #[serde(rename = "erc721")]
        Erc721,
        #[serde(rename = "erc1155")]
        Erc1155,
    }
    impl ::std::convert::From<&Self> for KnownAbiType {
        fn from(value: &KnownAbiType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for KnownAbiType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Erc20 => f.write_str("erc20"),
                Self::Erc721 => f.write_str("erc721"),
                Self::Erc1155 => f.write_str("erc1155"),
            }
        }
    }
    impl ::std::str::FromStr for KnownAbiType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "erc20" => Ok(Self::Erc20),
                "erc721" => Ok(Self::Erc721),
                "erc1155" => Ok(Self::Erc1155),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for KnownAbiType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for KnownAbiType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for KnownAbiType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    /**A reference to an established Solana program. When referencing a `KnownIdlType` within a policy rule configuring an `SolDataCriterion`, criteria will decode instruction data as documented in the programs. For more information on supported programs, see the links below.
    - [SystemProgram](https://docs.rs/solana-program/latest/solana_program/system_instruction/enum.SystemInstruction.html).
    - [TokenProgram](https://docs.rs/spl-token/latest/spl_token/instruction/enum.TokenInstruction.html).
    - [AssociatedTokenProgram](https://docs.rs/spl-associated-token-account/latest/spl_associated_token_account/instruction/index.html).*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "KnownIdlType",
    ///  "description": "A reference to an established Solana program. When referencing a `KnownIdlType` within a policy rule configuring an `SolDataCriterion`, criteria will decode instruction data as documented in the programs. For more information on supported programs, see the links below.\n  - [SystemProgram](https://docs.rs/solana-program/latest/solana_program/system_instruction/enum.SystemInstruction.html).\n  - [TokenProgram](https://docs.rs/spl-token/latest/spl_token/instruction/enum.TokenInstruction.html).\n  - [AssociatedTokenProgram](https://docs.rs/spl-associated-token-account/latest/spl_associated_token_account/instruction/index.html).",
    ///  "type": "string",
    ///  "enum": [
    ///    "SystemProgram",
    ///    "TokenProgram",
    ///    "AssociatedTokenProgram"
    ///  ],
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum KnownIdlType {
        SystemProgram,
        TokenProgram,
        AssociatedTokenProgram,
    }
    impl ::std::convert::From<&Self> for KnownIdlType {
        fn from(value: &KnownIdlType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for KnownIdlType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SystemProgram => f.write_str("SystemProgram"),
                Self::TokenProgram => f.write_str("TokenProgram"),
                Self::AssociatedTokenProgram => f.write_str("AssociatedTokenProgram"),
            }
        }
    }
    impl ::std::str::FromStr for KnownIdlType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "SystemProgram" => Ok(Self::SystemProgram),
                "TokenProgram" => Ok(Self::TokenProgram),
                "AssociatedTokenProgram" => Ok(Self::AssociatedTokenProgram),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for KnownIdlType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for KnownIdlType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for KnownIdlType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`ListDataTokenBalancesAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ListDataTokenBalancesAddress(::std::string::String);
    impl ::std::ops::Deref for ListDataTokenBalancesAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ListDataTokenBalancesAddress> for ::std::string::String {
        fn from(value: ListDataTokenBalancesAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ListDataTokenBalancesAddress> for ListDataTokenBalancesAddress {
        fn from(value: &ListDataTokenBalancesAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ListDataTokenBalancesAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ListDataTokenBalancesAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ListDataTokenBalancesAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ListDataTokenBalancesAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ListDataTokenBalancesAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`ListDataTokenBalancesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "balances"
    ///      ],
    ///      "properties": {
    ///        "balances": {
    ///          "description": "The list of EVM token balances.",
    ///          "examples": [
    ///            [
    ///              {
    ///                "amount": {
    ///                  "amount": "1250000000000000000",
    ///                  "decimals": 18
    ///                },
    ///                "token": {
    ///                  "contractAddress": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",
    ///                  "name": "ether",
    ///                  "network": "base",
    ///                  "symbol": "ETH"
    ///                }
    ///              },
    ///              {
    ///                "amount": {
    ///                  "amount": "123456",
    ///                  "decimals": 6
    ///                },
    ///                "token": {
    ///                  "contractAddress": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    ///                  "name": "USD Coin",
    ///                  "network": "base",
    ///                  "symbol": "USDC"
    ///                }
    ///              }
    ///            ]
    ///          ],
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/TokenBalance"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ListResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ListDataTokenBalancesResponse {
        ///The list of EVM token balances.
        pub balances: ::std::vec::Vec<TokenBalance>,
        ///The token for the next page of items, if any.
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&ListDataTokenBalancesResponse> for ListDataTokenBalancesResponse {
        fn from(value: &ListDataTokenBalancesResponse) -> Self {
            value.clone()
        }
    }
    impl ListDataTokenBalancesResponse {
        pub fn builder() -> builder::ListDataTokenBalancesResponse {
            Default::default()
        }
    }
    ///`ListEndUsersResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "endUsers"
    ///      ],
    ///      "properties": {
    ///        "endUsers": {
    ///          "description": "The list of end users.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/EndUser"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ListResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ListEndUsersResponse {
        ///The list of end users.
        #[serde(rename = "endUsers")]
        pub end_users: ::std::vec::Vec<EndUser>,
        ///The token for the next page of items, if any.
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&ListEndUsersResponse> for ListEndUsersResponse {
        fn from(value: &ListEndUsersResponse) -> Self {
            value.clone()
        }
    }
    impl ListEndUsersResponse {
        pub fn builder() -> builder::ListEndUsersResponse {
            Default::default()
        }
    }
    ///`ListEndUsersSortItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "createdAt=asc",
    ///    "createdAt=desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListEndUsersSortItem {
        #[serde(rename = "createdAt=asc")]
        CreatedAtAsc,
        #[serde(rename = "createdAt=desc")]
        CreatedAtDesc,
    }
    impl ::std::convert::From<&Self> for ListEndUsersSortItem {
        fn from(value: &ListEndUsersSortItem) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ListEndUsersSortItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::CreatedAtAsc => f.write_str("createdAt=asc"),
                Self::CreatedAtDesc => f.write_str("createdAt=desc"),
            }
        }
    }
    impl ::std::str::FromStr for ListEndUsersSortItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "createdAt=asc" => Ok(Self::CreatedAtAsc),
                "createdAt=desc" => Ok(Self::CreatedAtDesc),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for ListEndUsersSortItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ListEndUsersSortItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ListEndUsersSortItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`ListEvmAccountsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "accounts"
    ///      ],
    ///      "properties": {
    ///        "accounts": {
    ///          "description": "The list of EVM accounts.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/EvmAccount"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ListResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ListEvmAccountsResponse {
        ///The list of EVM accounts.
        pub accounts: ::std::vec::Vec<EvmAccount>,
        ///The token for the next page of items, if any.
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&ListEvmAccountsResponse> for ListEvmAccountsResponse {
        fn from(value: &ListEvmAccountsResponse) -> Self {
            value.clone()
        }
    }
    impl ListEvmAccountsResponse {
        pub fn builder() -> builder::ListEvmAccountsResponse {
            Default::default()
        }
    }
    ///`ListEvmSmartAccountsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "accounts"
    ///      ],
    ///      "properties": {
    ///        "accounts": {
    ///          "description": "The list of Smart Accounts.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/EvmSmartAccount"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ListResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ListEvmSmartAccountsResponse {
        ///The list of Smart Accounts.
        pub accounts: ::std::vec::Vec<EvmSmartAccount>,
        ///The token for the next page of items, if any.
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&ListEvmSmartAccountsResponse> for ListEvmSmartAccountsResponse {
        fn from(value: &ListEvmSmartAccountsResponse) -> Self {
            value.clone()
        }
    }
    impl ListEvmSmartAccountsResponse {
        pub fn builder() -> builder::ListEvmSmartAccountsResponse {
            Default::default()
        }
    }
    ///`ListEvmTokenBalancesAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ListEvmTokenBalancesAddress(::std::string::String);
    impl ::std::ops::Deref for ListEvmTokenBalancesAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ListEvmTokenBalancesAddress> for ::std::string::String {
        fn from(value: ListEvmTokenBalancesAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ListEvmTokenBalancesAddress> for ListEvmTokenBalancesAddress {
        fn from(value: &ListEvmTokenBalancesAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ListEvmTokenBalancesAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ListEvmTokenBalancesAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ListEvmTokenBalancesAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ListEvmTokenBalancesAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ListEvmTokenBalancesAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The name of the supported EVM networks in human-readable format.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the supported EVM networks in human-readable format.",
    ///  "examples": [
    ///    "base"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "base",
    ///    "base-sepolia",
    ///    "ethereum"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListEvmTokenBalancesNetwork {
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "base-sepolia")]
        BaseSepolia,
        #[serde(rename = "ethereum")]
        Ethereum,
    }
    impl ::std::convert::From<&Self> for ListEvmTokenBalancesNetwork {
        fn from(value: &ListEvmTokenBalancesNetwork) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ListEvmTokenBalancesNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base => f.write_str("base"),
                Self::BaseSepolia => f.write_str("base-sepolia"),
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }
    impl ::std::str::FromStr for ListEvmTokenBalancesNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base" => Ok(Self::Base),
                "base-sepolia" => Ok(Self::BaseSepolia),
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for ListEvmTokenBalancesNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ListEvmTokenBalancesNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ListEvmTokenBalancesNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`ListEvmTokenBalancesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "balances"
    ///      ],
    ///      "properties": {
    ///        "balances": {
    ///          "description": "The list of EVM token balances.",
    ///          "examples": [
    ///            [
    ///              {
    ///                "amount": {
    ///                  "amount": "1250000000000000000",
    ///                  "decimals": 18
    ///                },
    ///                "token": {
    ///                  "contractAddress": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",
    ///                  "name": "ether",
    ///                  "network": "base",
    ///                  "symbol": "ETH"
    ///                }
    ///              },
    ///              {
    ///                "amount": {
    ///                  "amount": "123456",
    ///                  "decimals": 6
    ///                },
    ///                "token": {
    ///                  "contractAddress": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    ///                  "name": "USD Coin",
    ///                  "network": "base",
    ///                  "symbol": "USDC"
    ///                }
    ///              }
    ///            ]
    ///          ],
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/TokenBalance"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ListResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ListEvmTokenBalancesResponse {
        ///The list of EVM token balances.
        pub balances: ::std::vec::Vec<TokenBalance>,
        ///The token for the next page of items, if any.
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&ListEvmTokenBalancesResponse> for ListEvmTokenBalancesResponse {
        fn from(value: &ListEvmTokenBalancesResponse) -> Self {
            value.clone()
        }
    }
    impl ListEvmTokenBalancesResponse {
        pub fn builder() -> builder::ListEvmTokenBalancesResponse {
            Default::default()
        }
    }
    ///`ListPoliciesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "policies"
    ///      ],
    ///      "properties": {
    ///        "policies": {
    ///          "description": "The list of policies.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Policy"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ListResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ListPoliciesResponse {
        ///The token for the next page of items, if any.
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<::std::string::String>,
        ///The list of policies.
        pub policies: ::std::vec::Vec<Policy>,
    }
    impl ::std::convert::From<&ListPoliciesResponse> for ListPoliciesResponse {
        fn from(value: &ListPoliciesResponse) -> Self {
            value.clone()
        }
    }
    impl ListPoliciesResponse {
        pub fn builder() -> builder::ListPoliciesResponse {
            Default::default()
        }
    }
    ///`ListPoliciesScope`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "project",
    ///    "account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListPoliciesScope {
        #[serde(rename = "project")]
        Project,
        #[serde(rename = "account")]
        Account,
    }
    impl ::std::convert::From<&Self> for ListPoliciesScope {
        fn from(value: &ListPoliciesScope) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ListPoliciesScope {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Project => f.write_str("project"),
                Self::Account => f.write_str("account"),
            }
        }
    }
    impl ::std::str::FromStr for ListPoliciesScope {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "project" => Ok(Self::Project),
                "account" => Ok(Self::Account),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for ListPoliciesScope {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ListPoliciesScope {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ListPoliciesScope {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`ListResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "nextPageToken": {
    ///      "description": "The token for the next page of items, if any.",
    ///      "examples": [
    ///        "eyJsYXN0X2lkIjogImFiYzEyMyIsICJ0aW1lc3RhbXAiOiAxNzA3ODIzNzAxfQ=="
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ListResponse {
        ///The token for the next page of items, if any.
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&ListResponse> for ListResponse {
        fn from(value: &ListResponse) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for ListResponse {
        fn default() -> Self {
            Self {
                next_page_token: Default::default(),
            }
        }
    }
    impl ListResponse {
        pub fn builder() -> builder::ListResponse {
            Default::default()
        }
    }
    ///`ListSolanaAccountsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "accounts"
    ///      ],
    ///      "properties": {
    ///        "accounts": {
    ///          "description": "The list of Solana accounts.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/SolanaAccount"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ListResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ListSolanaAccountsResponse {
        ///The list of Solana accounts.
        pub accounts: ::std::vec::Vec<SolanaAccount>,
        ///The token for the next page of items, if any.
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&ListSolanaAccountsResponse> for ListSolanaAccountsResponse {
        fn from(value: &ListSolanaAccountsResponse) -> Self {
            value.clone()
        }
    }
    impl ListSolanaAccountsResponse {
        pub fn builder() -> builder::ListSolanaAccountsResponse {
            Default::default()
        }
    }
    ///`ListSolanaTokenBalancesAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ListSolanaTokenBalancesAddress(::std::string::String);
    impl ::std::ops::Deref for ListSolanaTokenBalancesAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ListSolanaTokenBalancesAddress> for ::std::string::String {
        fn from(value: ListSolanaTokenBalancesAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ListSolanaTokenBalancesAddress> for ListSolanaTokenBalancesAddress {
        fn from(value: &ListSolanaTokenBalancesAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ListSolanaTokenBalancesAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ListSolanaTokenBalancesAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ListSolanaTokenBalancesAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ListSolanaTokenBalancesAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ListSolanaTokenBalancesAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The name of the supported Solana networks in human-readable format.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the supported Solana networks in human-readable format.",
    ///  "examples": [
    ///    "solana"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "solana",
    ///    "solana-devnet"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListSolanaTokenBalancesNetwork {
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "solana-devnet")]
        SolanaDevnet,
    }
    impl ::std::convert::From<&Self> for ListSolanaTokenBalancesNetwork {
        fn from(value: &ListSolanaTokenBalancesNetwork) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ListSolanaTokenBalancesNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
                Self::SolanaDevnet => f.write_str("solana-devnet"),
            }
        }
    }
    impl ::std::str::FromStr for ListSolanaTokenBalancesNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                "solana-devnet" => Ok(Self::SolanaDevnet),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for ListSolanaTokenBalancesNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ListSolanaTokenBalancesNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ListSolanaTokenBalancesNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`ListSolanaTokenBalancesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "balances"
    ///      ],
    ///      "properties": {
    ///        "balances": {
    ///          "description": "The list of Solana token balances.",
    ///          "examples": [
    ///            [
    ///              {
    ///                "amount": {
    ///                  "amount": "1250000000",
    ///                  "decimals": 9
    ///                },
    ///                "token": {
    ///                  "mintAddress": "So11111111111111111111111111111111111111111",
    ///                  "name": "Solana",
    ///                  "symbol": "SOL"
    ///                }
    ///              },
    ///              {
    ///                "amount": {
    ///                  "amount": "123456000",
    ///                  "decimals": 6
    ///                },
    ///                "token": {
    ///                  "mintAddress": "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU",
    ///                  "name": "USD Coin",
    ///                  "symbol": "USDC"
    ///                }
    ///              }
    ///            ]
    ///          ],
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/SolanaTokenBalance"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ListResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ListSolanaTokenBalancesResponse {
        ///The list of Solana token balances.
        pub balances: ::std::vec::Vec<SolanaTokenBalance>,
        ///The token for the next page of items, if any.
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&ListSolanaTokenBalancesResponse> for ListSolanaTokenBalancesResponse {
        fn from(value: &ListSolanaTokenBalancesResponse) -> Self {
            value.clone()
        }
    }
    impl ListSolanaTokenBalancesResponse {
        pub fn builder() -> builder::ListSolanaTokenBalancesResponse {
            Default::default()
        }
    }
    ///`ListSpendPermissionsAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ListSpendPermissionsAddress(::std::string::String);
    impl ::std::ops::Deref for ListSpendPermissionsAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ListSpendPermissionsAddress> for ::std::string::String {
        fn from(value: ListSpendPermissionsAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ListSpendPermissionsAddress> for ListSpendPermissionsAddress {
        fn from(value: &ListSpendPermissionsAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ListSpendPermissionsAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ListSpendPermissionsAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ListSpendPermissionsAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ListSpendPermissionsAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ListSpendPermissionsAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`ListSpendPermissionsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "spendPermissions"
    ///      ],
    ///      "properties": {
    ///        "spendPermissions": {
    ///          "description": "The spend permissions for the smart account.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/SpendPermissionResponseObject"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ListResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ListSpendPermissionsResponse {
        ///The token for the next page of items, if any.
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<::std::string::String>,
        ///The spend permissions for the smart account.
        #[serde(rename = "spendPermissions")]
        pub spend_permissions: ::std::vec::Vec<SpendPermissionResponseObject>,
    }
    impl ::std::convert::From<&ListSpendPermissionsResponse> for ListSpendPermissionsResponse {
        fn from(value: &ListSpendPermissionsResponse) -> Self {
            value.clone()
        }
    }
    impl ListSpendPermissionsResponse {
        pub fn builder() -> builder::ListSpendPermissionsResponse {
            Default::default()
        }
    }
    ///`ListTokensForAccountAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ListTokensForAccountAddress(::std::string::String);
    impl ::std::ops::Deref for ListTokensForAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ListTokensForAccountAddress> for ::std::string::String {
        fn from(value: ListTokensForAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ListTokensForAccountAddress> for ListTokensForAccountAddress {
        fn from(value: &ListTokensForAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ListTokensForAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ListTokensForAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ListTokensForAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ListTokensForAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ListTokensForAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`ListTokensForAccountNetwork`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "base",
    ///    "base-sepolia"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ListTokensForAccountNetwork {
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "base-sepolia")]
        BaseSepolia,
    }
    impl ::std::convert::From<&Self> for ListTokensForAccountNetwork {
        fn from(value: &ListTokensForAccountNetwork) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ListTokensForAccountNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base => f.write_str("base"),
                Self::BaseSepolia => f.write_str("base-sepolia"),
            }
        }
    }
    impl ::std::str::FromStr for ListTokensForAccountNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base" => Ok(Self::Base),
                "base-sepolia" => Ok(Self::BaseSepolia),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for ListTokensForAccountNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ListTokensForAccountNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ListTokensForAccountNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The criterion for the token mint addresses of a Solana transaction's SPL token transfer instructions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "MintAddressCriterion",
    ///  "description": "The criterion for the token mint addresses of a Solana transaction's SPL token transfer instructions.",
    ///  "type": "object",
    ///  "required": [
    ///    "addresses",
    ///    "operator",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "addresses": {
    ///      "description": "The Solana addresses that are compared to the list of token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.",
    ///      "examples": [
    ///        [
    ///          "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "The Solana address that is compared to the list of token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.",
    ///        "type": "string",
    ///        "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///      }
    ///    },
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. Each of the token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.",
    ///      "examples": [
    ///        "in"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "in",
    ///        "not in"
    ///      ]
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `mintAddress`.",
    ///      "examples": [
    ///        "mintAddress"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "mintAddress"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MintAddressCriterion {
        ///The Solana addresses that are compared to the list of token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.
        pub addresses: ::std::vec::Vec<MintAddressCriterionAddressesItem>,
        ///The operator to use for the comparison. Each of the token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
        pub operator: MintAddressCriterionOperator,
        ///The type of criterion to use. This should be `mintAddress`.
        #[serde(rename = "type")]
        pub type_: MintAddressCriterionType,
    }
    impl ::std::convert::From<&MintAddressCriterion> for MintAddressCriterion {
        fn from(value: &MintAddressCriterion) -> Self {
            value.clone()
        }
    }
    impl MintAddressCriterion {
        pub fn builder() -> builder::MintAddressCriterion {
            Default::default()
        }
    }
    ///The Solana address that is compared to the list of token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Solana address that is compared to the list of token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.",
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct MintAddressCriterionAddressesItem(::std::string::String);
    impl ::std::ops::Deref for MintAddressCriterionAddressesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<MintAddressCriterionAddressesItem> for ::std::string::String {
        fn from(value: MintAddressCriterionAddressesItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&MintAddressCriterionAddressesItem>
        for MintAddressCriterionAddressesItem
    {
        fn from(value: &MintAddressCriterionAddressesItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for MintAddressCriterionAddressesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for MintAddressCriterionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for MintAddressCriterionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for MintAddressCriterionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MintAddressCriterionAddressesItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The operator to use for the comparison. Each of the token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. Each of the token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.",
    ///  "examples": [
    ///    "in"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "in",
    ///    "not in"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MintAddressCriterionOperator {
        #[serde(rename = "in")]
        In,
        #[serde(rename = "not in")]
        NotIn,
    }
    impl ::std::convert::From<&Self> for MintAddressCriterionOperator {
        fn from(value: &MintAddressCriterionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MintAddressCriterionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::In => f.write_str("in"),
                Self::NotIn => f.write_str("not in"),
            }
        }
    }
    impl ::std::str::FromStr for MintAddressCriterionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "in" => Ok(Self::In),
                "not in" => Ok(Self::NotIn),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for MintAddressCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for MintAddressCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for MintAddressCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The type of criterion to use. This should be `mintAddress`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `mintAddress`.",
    ///  "examples": [
    ///    "mintAddress"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "mintAddress"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MintAddressCriterionType {
        #[serde(rename = "mintAddress")]
        MintAddress,
    }
    impl ::std::convert::From<&Self> for MintAddressCriterionType {
        fn from(value: &MintAddressCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MintAddressCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::MintAddress => f.write_str("mintAddress"),
            }
        }
    }
    impl ::std::str::FromStr for MintAddressCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "mintAddress" => Ok(Self::MintAddress),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for MintAddressCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for MintAddressCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for MintAddressCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///A schema for specifying a criterion for the USD denominated asset transfer or exposure for a transaction. This includes native transfers, as well as token transfers.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "NetUSDChangeCriterion",
    ///  "description": "A schema for specifying a criterion for the USD denominated asset transfer or exposure for a transaction. This includes native transfers, as well as token transfers.",
    ///  "type": "object",
    ///  "required": [
    ///    "changeCents",
    ///    "operator",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "changeCents": {
    ///      "description": "The amount of USD, in cents, that the total value of a transaction's asset transfer should be compared to.",
    ///      "examples": [
    ///        10000
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. The total value of a transaction's asset transfer will be on the left-hand side of the operator, and the `changeCents` field will be on the right-hand side.",
    ///      "examples": [
    ///        "<="
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "GreaterThan",
    ///        "GreaterThanOrEqual",
    ///        "LessThan",
    ///        "LessThanOrEqual",
    ///        "Equal"
    ///      ]
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `netUSDChange`.",
    ///      "examples": [
    ///        "netUSDChange"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "netUSDChange"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NetUsdChangeCriterion {
        ///The amount of USD, in cents, that the total value of a transaction's asset transfer should be compared to.
        #[serde(rename = "changeCents")]
        pub change_cents: i64,
        ///The operator to use for the comparison. The total value of a transaction's asset transfer will be on the left-hand side of the operator, and the `changeCents` field will be on the right-hand side.
        pub operator: NetUsdChangeCriterionOperator,
        ///The type of criterion to use. This should be `netUSDChange`.
        #[serde(rename = "type")]
        pub type_: NetUsdChangeCriterionType,
    }
    impl ::std::convert::From<&NetUsdChangeCriterion> for NetUsdChangeCriterion {
        fn from(value: &NetUsdChangeCriterion) -> Self {
            value.clone()
        }
    }
    impl NetUsdChangeCriterion {
        pub fn builder() -> builder::NetUsdChangeCriterion {
            Default::default()
        }
    }
    ///The operator to use for the comparison. The total value of a transaction's asset transfer will be on the left-hand side of the operator, and the `changeCents` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. The total value of a transaction's asset transfer will be on the left-hand side of the operator, and the `changeCents` field will be on the right-hand side.",
    ///  "examples": [
    ///    "<="
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "GreaterThan",
    ///    "GreaterThanOrEqual",
    ///    "LessThan",
    ///    "LessThanOrEqual",
    ///    "Equal"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum NetUsdChangeCriterionOperator {
        GreaterThan,
        GreaterThanOrEqual,
        LessThan,
        LessThanOrEqual,
        Equal,
    }
    impl ::std::convert::From<&Self> for NetUsdChangeCriterionOperator {
        fn from(value: &NetUsdChangeCriterionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NetUsdChangeCriterionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GreaterThan => f.write_str("GreaterThan"),
                Self::GreaterThanOrEqual => f.write_str("GreaterThanOrEqual"),
                Self::LessThan => f.write_str("LessThan"),
                Self::LessThanOrEqual => f.write_str("LessThanOrEqual"),
                Self::Equal => f.write_str("Equal"),
            }
        }
    }
    impl ::std::str::FromStr for NetUsdChangeCriterionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "GreaterThan" => Ok(Self::GreaterThan),
                "GreaterThanOrEqual" => Ok(Self::GreaterThanOrEqual),
                "LessThan" => Ok(Self::LessThan),
                "LessThanOrEqual" => Ok(Self::LessThanOrEqual),
                "Equal" => Ok(Self::Equal),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for NetUsdChangeCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for NetUsdChangeCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for NetUsdChangeCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The type of criterion to use. This should be `netUSDChange`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `netUSDChange`.",
    ///  "examples": [
    ///    "netUSDChange"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "netUSDChange"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum NetUsdChangeCriterionType {
        #[serde(rename = "netUSDChange")]
        NetUsdChange,
    }
    impl ::std::convert::From<&Self> for NetUsdChangeCriterionType {
        fn from(value: &NetUsdChangeCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NetUsdChangeCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NetUsdChange => f.write_str("netUSDChange"),
            }
        }
    }
    impl ::std::str::FromStr for NetUsdChangeCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "netUSDChange" => Ok(Self::NetUsdChange),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for NetUsdChangeCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for NetUsdChangeCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for NetUsdChangeCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Information about an end user who authenticates using a third-party provider.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "OAuth2Authentication",
    ///  "description": "Information about an end user who authenticates using a third-party provider.",
    ///  "type": "object",
    ///  "required": [
    ///    "sub",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "description": "The email address of the end user contained within the user's ID token, if available from third-party OAuth2 provider's token exchange.",
    ///      "examples": [
    ///        "test.user@gmail.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "The full name of the end user if available from third-party OAuth2 provider's token exchange.",
    ///      "examples": [
    ///        "Test User"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "sub": {
    ///      "description": "The unique identifier for the end user that is captured in the `sub` claim of the JWT.",
    ///      "examples": [
    ///        "e051beeb-7163-4527-a5b6-35e301529ff2"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/OAuth2ProviderType"
    ///    },
    ///    "username": {
    ///      "description": "The username of the end user if available from third-party OAuth2 provider's token exchange.",
    ///      "examples": [
    ///        "test.user"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct OAuth2Authentication {
        ///The email address of the end user contained within the user's ID token, if available from third-party OAuth2 provider's token exchange.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        ///The full name of the end user if available from third-party OAuth2 provider's token exchange.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The unique identifier for the end user that is captured in the `sub` claim of the JWT.
        pub sub: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: OAuth2ProviderType,
        ///The username of the end user if available from third-party OAuth2 provider's token exchange.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub username: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&OAuth2Authentication> for OAuth2Authentication {
        fn from(value: &OAuth2Authentication) -> Self {
            value.clone()
        }
    }
    impl OAuth2Authentication {
        pub fn builder() -> builder::OAuth2Authentication {
            Default::default()
        }
    }
    ///The type of OAuth2 provider.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of OAuth2 provider.",
    ///  "examples": [
    ///    "google"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "google",
    ///    "apple",
    ///    "x"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OAuth2ProviderType {
        #[serde(rename = "google")]
        Google,
        #[serde(rename = "apple")]
        Apple,
        #[serde(rename = "x")]
        X,
    }
    impl ::std::convert::From<&Self> for OAuth2ProviderType {
        fn from(value: &OAuth2ProviderType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for OAuth2ProviderType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Google => f.write_str("google"),
                Self::Apple => f.write_str("apple"),
                Self::X => f.write_str("x"),
            }
        }
    }
    impl ::std::str::FromStr for OAuth2ProviderType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "google" => Ok(Self::Google),
                "apple" => Ok(Self::Apple),
                "x" => Ok(Self::X),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for OAuth2ProviderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for OAuth2ProviderType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for OAuth2ProviderType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Request to execute a SQL query against indexed blockchain data.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request to execute a SQL query against indexed blockchain data.",
    ///  "type": "object",
    ///  "required": [
    ///    "sql"
    ///  ],
    ///  "properties": {
    ///    "cache": {
    ///      "title": "Query result cache configuration",
    ///      "description": "Enables control over how often queries need to be fully re-executed on the backing store.\nThis can be useful in scenarios where API calls might be made frequently, API latency is critical, and some freshness lag (ex: 750ms, 2s, 5s) is tolerable.\nBy default, each query result is returned from cache so long as the result is from an identical query and less than 500ms old. This freshness tolerance can be modified upwards, to a maximum of 900000ms (i.e. 900s, 15m).\n",
    ///      "examples": [
    ///        {
    ///          "maxAgeMs": 1000
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "maxAgeMs": {
    ///          "description": "The maximum tolerable staleness of the query result cache in milliseconds. If a previous execution result of an identical query is older than this age, the query will be re-executed. If the data is less than this age, the result will be returned from cache.",
    ///          "default": 500,
    ///          "examples": [
    ///            1000
    ///          ],
    ///          "type": "integer",
    ///          "maximum": 900000.0,
    ///          "minimum": 500.0
    ///        }
    ///      }
    ///    },
    ///    "sql": {
    ///      "description": "SQL query to execute against the indexed blockchain data.",
    ///      "examples": [
    ///        "SELECT block_number, transaction_hash FROM base.transactions WHERE block_number > 1000000 LIMIT 10"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 100000,
    ///      "minLength": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct OnchainDataQuery {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cache: ::std::option::Option<QueryResultCacheConfiguration>,
        ///SQL query to execute against the indexed blockchain data.
        pub sql: OnchainDataQuerySql,
    }
    impl ::std::convert::From<&OnchainDataQuery> for OnchainDataQuery {
        fn from(value: &OnchainDataQuery) -> Self {
            value.clone()
        }
    }
    impl OnchainDataQuery {
        pub fn builder() -> builder::OnchainDataQuery {
            Default::default()
        }
    }
    ///SQL query to execute against the indexed blockchain data.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "SQL query to execute against the indexed blockchain data.",
    ///  "examples": [
    ///    "SELECT block_number, transaction_hash FROM base.transactions WHERE block_number > 1000000 LIMIT 10"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 100000,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct OnchainDataQuerySql(::std::string::String);
    impl ::std::ops::Deref for OnchainDataQuerySql {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<OnchainDataQuerySql> for ::std::string::String {
        fn from(value: OnchainDataQuerySql) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&OnchainDataQuerySql> for OnchainDataQuerySql {
        fn from(value: &OnchainDataQuerySql) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for OnchainDataQuerySql {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 100000usize {
                return Err("longer than 100000 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for OnchainDataQuerySql {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for OnchainDataQuerySql {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for OnchainDataQuerySql {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for OnchainDataQuerySql {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///Result of executing a SQL query.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Result of executing a SQL query.",
    ///  "type": "object",
    ///  "properties": {
    ///    "metadata": {
    ///      "description": "Metadata about query execution.",
    ///      "examples": [
    ///        {
    ///          "cached": false,
    ///          "executionTimeMs": 145,
    ///          "executionTimestamp": "2025-01-01T00:00:00.000Z",
    ///          "rowCount": 2
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "cached": {
    ///          "description": "Whether the result was served from the query result cache.",
    ///          "examples": [
    ///            false
    ///          ],
    ///          "type": "boolean"
    ///        },
    ///        "executionTimeMs": {
    ///          "description": "Query execution time in milliseconds.",
    ///          "examples": [
    ///            145
    ///          ],
    ///          "type": "integer"
    ///        },
    ///        "executionTimestamp": {
    ///          "description": "When the query result was executed against the backing store in RFC 3339 format.",
    ///          "examples": [
    ///            "2025-01-01T00:00:00.000Z"
    ///          ],
    ///          "type": "string",
    ///          "format": "date-time"
    ///        },
    ///        "rowCount": {
    ///          "description": "Number of rows returned.",
    ///          "examples": [
    ///            2
    ///          ],
    ///          "type": "integer"
    ///        }
    ///      }
    ///    },
    ///    "result": {
    ///      "description": "Query result as an array of objects representing rows.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "amount": 1000000000000000000,
    ///            "event_signature": "Transfer(address,address,uint256)",
    ///            "from": "0x1234567890abcdef",
    ///            "to": "0x1234567890abcdef"
    ///          },
    ///          {
    ///            "amount": 2000000000000000000,
    ///            "event_signature": "Transfer(address,address,uint256)",
    ///            "from": "0x1234567890abcdef",
    ///            "to": "0x1234567890abcdef"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "Row data with column names as keys.",
    ///        "examples": [
    ///          {
    ///            "amount": 1000000000000000000,
    ///            "event_signature": "Transfer(address,address,uint256)",
    ///            "from": "0x1234567890abcdef",
    ///            "to": "0x1234567890abcdef"
    ///          }
    ///        ],
    ///        "type": "object",
    ///        "additionalProperties": true
    ///      }
    ///    },
    ///    "schema": {
    ///      "description": "Schema information for the query result. This is a derived schema from the query result, so types may not match the underlying table.\n",
    ///      "examples": [
    ///        {
    ///          "columns": [
    ///            {
    ///              "name": "block_number",
    ///              "type": "UInt64"
    ///            },
    ///            {
    ///              "name": "transaction_hash",
    ///              "type": "String"
    ///            }
    ///          ]
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "columns": {
    ///          "description": "Column definitions.",
    ///          "type": "array",
    ///          "items": {
    ///            "examples": [
    ///              {
    ///                "description": "The signature of the event.",
    ///                "name": "event_signature",
    ///                "type": "String"
    ///              }
    ///            ],
    ///            "type": "object",
    ///            "properties": {
    ///              "name": {
    ///                "description": "Column name.",
    ///                "type": "string"
    ///              },
    ///              "type": {
    ///                "description": "Column data type (ClickHouse types).",
    ///                "type": "string",
    ///                "enum": [
    ///                  "String",
    ///                  "UInt8",
    ///                  "UInt16",
    ///                  "UInt32",
    ///                  "UInt64",
    ///                  "UInt128",
    ///                  "UInt256",
    ///                  "Int8",
    ///                  "Int16",
    ///                  "Int32",
    ///                  "Int64",
    ///                  "Int128",
    ///                  "Int256",
    ///                  "Float32",
    ///                  "Float64",
    ///                  "Bool",
    ///                  "Date",
    ///                  "DateTime",
    ///                  "DateTime64",
    ///                  "UUID"
    ///                ]
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct OnchainDataResult {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<OnchainDataResultMetadata>,
        ///Query result as an array of objects representing rows.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub result: ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub schema: ::std::option::Option<OnchainDataResultSchema>,
    }
    impl ::std::convert::From<&OnchainDataResult> for OnchainDataResult {
        fn from(value: &OnchainDataResult) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for OnchainDataResult {
        fn default() -> Self {
            Self {
                metadata: Default::default(),
                result: Default::default(),
                schema: Default::default(),
            }
        }
    }
    impl OnchainDataResult {
        pub fn builder() -> builder::OnchainDataResult {
            Default::default()
        }
    }
    ///Metadata about query execution.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata about query execution.",
    ///  "examples": [
    ///    {
    ///      "cached": false,
    ///      "executionTimeMs": 145,
    ///      "executionTimestamp": "2025-01-01T00:00:00.000Z",
    ///      "rowCount": 2
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "cached": {
    ///      "description": "Whether the result was served from the query result cache.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "executionTimeMs": {
    ///      "description": "Query execution time in milliseconds.",
    ///      "examples": [
    ///        145
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "executionTimestamp": {
    ///      "description": "When the query result was executed against the backing store in RFC 3339 format.",
    ///      "examples": [
    ///        "2025-01-01T00:00:00.000Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "rowCount": {
    ///      "description": "Number of rows returned.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct OnchainDataResultMetadata {
        ///Whether the result was served from the query result cache.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cached: ::std::option::Option<bool>,
        ///Query execution time in milliseconds.
        #[serde(
            rename = "executionTimeMs",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub execution_time_ms: ::std::option::Option<i64>,
        ///When the query result was executed against the backing store in RFC 3339 format.
        #[serde(
            rename = "executionTimestamp",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub execution_timestamp: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        ///Number of rows returned.
        #[serde(
            rename = "rowCount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub row_count: ::std::option::Option<i64>,
    }
    impl ::std::convert::From<&OnchainDataResultMetadata> for OnchainDataResultMetadata {
        fn from(value: &OnchainDataResultMetadata) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for OnchainDataResultMetadata {
        fn default() -> Self {
            Self {
                cached: Default::default(),
                execution_time_ms: Default::default(),
                execution_timestamp: Default::default(),
                row_count: Default::default(),
            }
        }
    }
    impl OnchainDataResultMetadata {
        pub fn builder() -> builder::OnchainDataResultMetadata {
            Default::default()
        }
    }
    /**Schema information for the query result. This is a derived schema from the query result, so types may not match the underlying table.
     */
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Schema information for the query result. This is a derived schema from the query result, so types may not match the underlying table.\n",
    ///  "examples": [
    ///    {
    ///      "columns": [
    ///        {
    ///          "name": "block_number",
    ///          "type": "UInt64"
    ///        },
    ///        {
    ///          "name": "transaction_hash",
    ///          "type": "String"
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "columns": {
    ///      "description": "Column definitions.",
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          {
    ///            "description": "The signature of the event.",
    ///            "name": "event_signature",
    ///            "type": "String"
    ///          }
    ///        ],
    ///        "type": "object",
    ///        "properties": {
    ///          "name": {
    ///            "description": "Column name.",
    ///            "type": "string"
    ///          },
    ///          "type": {
    ///            "description": "Column data type (ClickHouse types).",
    ///            "type": "string",
    ///            "enum": [
    ///              "String",
    ///              "UInt8",
    ///              "UInt16",
    ///              "UInt32",
    ///              "UInt64",
    ///              "UInt128",
    ///              "UInt256",
    ///              "Int8",
    ///              "Int16",
    ///              "Int32",
    ///              "Int64",
    ///              "Int128",
    ///              "Int256",
    ///              "Float32",
    ///              "Float64",
    ///              "Bool",
    ///              "Date",
    ///              "DateTime",
    ///              "DateTime64",
    ///              "UUID"
    ///            ]
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct OnchainDataResultSchema {
        ///Column definitions.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub columns: ::std::vec::Vec<OnchainDataResultSchemaColumnsItem>,
    }
    impl ::std::convert::From<&OnchainDataResultSchema> for OnchainDataResultSchema {
        fn from(value: &OnchainDataResultSchema) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for OnchainDataResultSchema {
        fn default() -> Self {
            Self {
                columns: Default::default(),
            }
        }
    }
    impl OnchainDataResultSchema {
        pub fn builder() -> builder::OnchainDataResultSchema {
            Default::default()
        }
    }
    ///`OnchainDataResultSchemaColumnsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "description": "The signature of the event.",
    ///      "name": "event_signature",
    ///      "type": "String"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "name": {
    ///      "description": "Column name.",
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "Column data type (ClickHouse types).",
    ///      "type": "string",
    ///      "enum": [
    ///        "String",
    ///        "UInt8",
    ///        "UInt16",
    ///        "UInt32",
    ///        "UInt64",
    ///        "UInt128",
    ///        "UInt256",
    ///        "Int8",
    ///        "Int16",
    ///        "Int32",
    ///        "Int64",
    ///        "Int128",
    ///        "Int256",
    ///        "Float32",
    ///        "Float64",
    ///        "Bool",
    ///        "Date",
    ///        "DateTime",
    ///        "DateTime64",
    ///        "UUID"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct OnchainDataResultSchemaColumnsItem {
        ///Column name.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///Column data type (ClickHouse types).
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<OnchainDataResultSchemaColumnsItemType>,
    }
    impl ::std::convert::From<&OnchainDataResultSchemaColumnsItem>
        for OnchainDataResultSchemaColumnsItem
    {
        fn from(value: &OnchainDataResultSchemaColumnsItem) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for OnchainDataResultSchemaColumnsItem {
        fn default() -> Self {
            Self {
                name: Default::default(),
                type_: Default::default(),
            }
        }
    }
    impl OnchainDataResultSchemaColumnsItem {
        pub fn builder() -> builder::OnchainDataResultSchemaColumnsItem {
            Default::default()
        }
    }
    ///Column data type (ClickHouse types).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Column data type (ClickHouse types).",
    ///  "type": "string",
    ///  "enum": [
    ///    "String",
    ///    "UInt8",
    ///    "UInt16",
    ///    "UInt32",
    ///    "UInt64",
    ///    "UInt128",
    ///    "UInt256",
    ///    "Int8",
    ///    "Int16",
    ///    "Int32",
    ///    "Int64",
    ///    "Int128",
    ///    "Int256",
    ///    "Float32",
    ///    "Float64",
    ///    "Bool",
    ///    "Date",
    ///    "DateTime",
    ///    "DateTime64",
    ///    "UUID"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OnchainDataResultSchemaColumnsItemType {
        String,
        UInt8,
        UInt16,
        UInt32,
        UInt64,
        UInt128,
        UInt256,
        Int8,
        Int16,
        Int32,
        Int64,
        Int128,
        Int256,
        Float32,
        Float64,
        Bool,
        Date,
        DateTime,
        DateTime64,
        #[serde(rename = "UUID")]
        Uuid,
    }
    impl ::std::convert::From<&Self> for OnchainDataResultSchemaColumnsItemType {
        fn from(value: &OnchainDataResultSchemaColumnsItemType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for OnchainDataResultSchemaColumnsItemType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::String => f.write_str("String"),
                Self::UInt8 => f.write_str("UInt8"),
                Self::UInt16 => f.write_str("UInt16"),
                Self::UInt32 => f.write_str("UInt32"),
                Self::UInt64 => f.write_str("UInt64"),
                Self::UInt128 => f.write_str("UInt128"),
                Self::UInt256 => f.write_str("UInt256"),
                Self::Int8 => f.write_str("Int8"),
                Self::Int16 => f.write_str("Int16"),
                Self::Int32 => f.write_str("Int32"),
                Self::Int64 => f.write_str("Int64"),
                Self::Int128 => f.write_str("Int128"),
                Self::Int256 => f.write_str("Int256"),
                Self::Float32 => f.write_str("Float32"),
                Self::Float64 => f.write_str("Float64"),
                Self::Bool => f.write_str("Bool"),
                Self::Date => f.write_str("Date"),
                Self::DateTime => f.write_str("DateTime"),
                Self::DateTime64 => f.write_str("DateTime64"),
                Self::Uuid => f.write_str("UUID"),
            }
        }
    }
    impl ::std::str::FromStr for OnchainDataResultSchemaColumnsItemType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "String" => Ok(Self::String),
                "UInt8" => Ok(Self::UInt8),
                "UInt16" => Ok(Self::UInt16),
                "UInt32" => Ok(Self::UInt32),
                "UInt64" => Ok(Self::UInt64),
                "UInt128" => Ok(Self::UInt128),
                "UInt256" => Ok(Self::UInt256),
                "Int8" => Ok(Self::Int8),
                "Int16" => Ok(Self::Int16),
                "Int32" => Ok(Self::Int32),
                "Int64" => Ok(Self::Int64),
                "Int128" => Ok(Self::Int128),
                "Int256" => Ok(Self::Int256),
                "Float32" => Ok(Self::Float32),
                "Float64" => Ok(Self::Float64),
                "Bool" => Ok(Self::Bool),
                "Date" => Ok(Self::Date),
                "DateTime" => Ok(Self::DateTime),
                "DateTime64" => Ok(Self::DateTime64),
                "UUID" => Ok(Self::Uuid),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for OnchainDataResultSchemaColumnsItemType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for OnchainDataResultSchemaColumnsItemType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for OnchainDataResultSchemaColumnsItemType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///An Onramp order.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An Onramp order.",
    ///  "type": "object",
    ///  "required": [
    ///    "createdAt",
    ///    "destinationAddress",
    ///    "destinationNetwork",
    ///    "exchangeRate",
    ///    "fees",
    ///    "orderId",
    ///    "paymentCurrency",
    ///    "paymentMethod",
    ///    "paymentSubtotal",
    ///    "paymentTotal",
    ///    "purchaseAmount",
    ///    "purchaseCurrency",
    ///    "status",
    ///    "updatedAt"
    ///  ],
    ///  "properties": {
    ///    "createdAt": {
    ///      "description": "The date and time the order was created.",
    ///      "examples": [
    ///        "2025-04-24T00:00:00Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "destinationAddress": {
    ///      "description": "The destination address to send the crypto to.",
    ///      "examples": [
    ///        "0x71C7656EC7ab88b098defB751B7401B5f6d8976F"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "destinationNetwork": {
    ///      "description": "The network to send the crypto on.",
    ///      "examples": [
    ///        "base"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "exchangeRate": {
    ///      "description": "The exchange rate used to convert fiat to crypto i.e. the crypto value of one fiat.",
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fees": {
    ///      "description": "The fees associated with the order.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "amount": "0.5",
    ///            "currency": "USD",
    ///            "type": "FEE_TYPE_EXCHANGE"
    ///          },
    ///          {
    ///            "amount": "0.25",
    ///            "currency": "USD",
    ///            "type": "FEE_TYPE_NETWORK"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/OnrampOrderFee"
    ///      }
    ///    },
    ///    "orderId": {
    ///      "description": "The ID of the onramp order.",
    ///      "examples": [
    ///        "123e4567-e89b-12d3-a456-426614174000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "partnerUserRef": {
    ///      "description": "The partner user reference ID.",
    ///      "examples": [
    ///        "user123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentCurrency": {
    ///      "description": "The fiat currency to be converted to crypto.",
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentMethod": {
    ///      "$ref": "#/components/schemas/OnrampOrderPaymentMethodTypeId"
    ///    },
    ///    "paymentSubtotal": {
    ///      "description": "The amount of fiat to be converted to crypto.",
    ///      "examples": [
    ///        "100"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentTotal": {
    ///      "description": "The total amount of fiat to be paid, inclusive of any fees.",
    ///      "examples": [
    ///        "100.75"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "purchaseAmount": {
    ///      "description": "The amount of crypto to be purchased.",
    ///      "examples": [
    ///        "100.000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "purchaseCurrency": {
    ///      "description": "The crypto currency to be purchased.",
    ///      "examples": [
    ///        "USDC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/OnrampOrderStatus"
    ///    },
    ///    "txHash": {
    ///      "description": "The transaction hash of the order (only available once crypto has been sent).",
    ///      "examples": [
    ///        "0x363cd3b3d4f49497cf5076150cd709307b90e9fc897fdd623546ea7b9313cecb"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updatedAt": {
    ///      "description": "The date and time the order was last updated.",
    ///      "examples": [
    ///        "2025-04-24T00:00:00Z"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct OnrampOrder {
        ///The date and time the order was created.
        #[serde(rename = "createdAt")]
        pub created_at: ::std::string::String,
        ///The destination address to send the crypto to.
        #[serde(rename = "destinationAddress")]
        pub destination_address: ::std::string::String,
        ///The network to send the crypto on.
        #[serde(rename = "destinationNetwork")]
        pub destination_network: ::std::string::String,
        ///The exchange rate used to convert fiat to crypto i.e. the crypto value of one fiat.
        #[serde(rename = "exchangeRate")]
        pub exchange_rate: ::std::string::String,
        ///The fees associated with the order.
        pub fees: ::std::vec::Vec<OnrampOrderFee>,
        ///The ID of the onramp order.
        #[serde(rename = "orderId")]
        pub order_id: ::std::string::String,
        ///The partner user reference ID.
        #[serde(
            rename = "partnerUserRef",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub partner_user_ref: ::std::option::Option<::std::string::String>,
        ///The fiat currency to be converted to crypto.
        #[serde(rename = "paymentCurrency")]
        pub payment_currency: ::std::string::String,
        #[serde(rename = "paymentMethod")]
        pub payment_method: OnrampOrderPaymentMethodTypeId,
        ///The amount of fiat to be converted to crypto.
        #[serde(rename = "paymentSubtotal")]
        pub payment_subtotal: ::std::string::String,
        ///The total amount of fiat to be paid, inclusive of any fees.
        #[serde(rename = "paymentTotal")]
        pub payment_total: ::std::string::String,
        ///The amount of crypto to be purchased.
        #[serde(rename = "purchaseAmount")]
        pub purchase_amount: ::std::string::String,
        ///The crypto currency to be purchased.
        #[serde(rename = "purchaseCurrency")]
        pub purchase_currency: ::std::string::String,
        pub status: OnrampOrderStatus,
        ///The transaction hash of the order (only available once crypto has been sent).
        #[serde(
            rename = "txHash",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub tx_hash: ::std::option::Option<::std::string::String>,
        ///The date and time the order was last updated.
        #[serde(rename = "updatedAt")]
        pub updated_at: ::std::string::String,
    }
    impl ::std::convert::From<&OnrampOrder> for OnrampOrder {
        fn from(value: &OnrampOrder) -> Self {
            value.clone()
        }
    }
    impl OnrampOrder {
        pub fn builder() -> builder::OnrampOrder {
            Default::default()
        }
    }
    ///A fee associated with an order.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A fee associated with an order.",
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "currency",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "The amount of the fee.",
    ///      "examples": [
    ///        "0.95"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "currency": {
    ///      "description": "The currency of the fee.",
    ///      "examples": [
    ///        "USDC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of fee.",
    ///      "examples": [
    ///        "FEE_TYPE_NETWORK"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "FEE_TYPE_NETWORK",
    ///        "FEE_TYPE_EXCHANGE"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct OnrampOrderFee {
        ///The amount of the fee.
        pub amount: ::std::string::String,
        ///The currency of the fee.
        pub currency: ::std::string::String,
        ///The type of fee.
        #[serde(rename = "type")]
        pub type_: OnrampOrderFeeType,
    }
    impl ::std::convert::From<&OnrampOrderFee> for OnrampOrderFee {
        fn from(value: &OnrampOrderFee) -> Self {
            value.clone()
        }
    }
    impl OnrampOrderFee {
        pub fn builder() -> builder::OnrampOrderFee {
            Default::default()
        }
    }
    ///The type of fee.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of fee.",
    ///  "examples": [
    ///    "FEE_TYPE_NETWORK"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "FEE_TYPE_NETWORK",
    ///    "FEE_TYPE_EXCHANGE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OnrampOrderFeeType {
        #[serde(rename = "FEE_TYPE_NETWORK")]
        FeeTypeNetwork,
        #[serde(rename = "FEE_TYPE_EXCHANGE")]
        FeeTypeExchange,
    }
    impl ::std::convert::From<&Self> for OnrampOrderFeeType {
        fn from(value: &OnrampOrderFeeType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for OnrampOrderFeeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::FeeTypeNetwork => f.write_str("FEE_TYPE_NETWORK"),
                Self::FeeTypeExchange => f.write_str("FEE_TYPE_EXCHANGE"),
            }
        }
    }
    impl ::std::str::FromStr for OnrampOrderFeeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "FEE_TYPE_NETWORK" => Ok(Self::FeeTypeNetwork),
                "FEE_TYPE_EXCHANGE" => Ok(Self::FeeTypeExchange),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for OnrampOrderFeeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for OnrampOrderFeeType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for OnrampOrderFeeType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The type of payment method to be used to complete an onramp order.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of payment method to be used to complete an onramp order.",
    ///  "examples": [
    ///    "GUEST_CHECKOUT_APPLE_PAY"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "GUEST_CHECKOUT_APPLE_PAY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OnrampOrderPaymentMethodTypeId {
        #[serde(rename = "GUEST_CHECKOUT_APPLE_PAY")]
        GuestCheckoutApplePay,
    }
    impl ::std::convert::From<&Self> for OnrampOrderPaymentMethodTypeId {
        fn from(value: &OnrampOrderPaymentMethodTypeId) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for OnrampOrderPaymentMethodTypeId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GuestCheckoutApplePay => f.write_str("GUEST_CHECKOUT_APPLE_PAY"),
            }
        }
    }
    impl ::std::str::FromStr for OnrampOrderPaymentMethodTypeId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "GUEST_CHECKOUT_APPLE_PAY" => Ok(Self::GuestCheckoutApplePay),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for OnrampOrderPaymentMethodTypeId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for OnrampOrderPaymentMethodTypeId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for OnrampOrderPaymentMethodTypeId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The status of an onramp order.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of an onramp order.",
    ///  "examples": [
    ///    "ONRAMP_ORDER_STATUS_COMPLETED"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "ONRAMP_ORDER_STATUS_PENDING_AUTH",
    ///    "ONRAMP_ORDER_STATUS_PENDING_PAYMENT",
    ///    "ONRAMP_ORDER_STATUS_PROCESSING",
    ///    "ONRAMP_ORDER_STATUS_COMPLETED",
    ///    "ONRAMP_ORDER_STATUS_FAILED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OnrampOrderStatus {
        #[serde(rename = "ONRAMP_ORDER_STATUS_PENDING_AUTH")]
        OnrampOrderStatusPendingAuth,
        #[serde(rename = "ONRAMP_ORDER_STATUS_PENDING_PAYMENT")]
        OnrampOrderStatusPendingPayment,
        #[serde(rename = "ONRAMP_ORDER_STATUS_PROCESSING")]
        OnrampOrderStatusProcessing,
        #[serde(rename = "ONRAMP_ORDER_STATUS_COMPLETED")]
        OnrampOrderStatusCompleted,
        #[serde(rename = "ONRAMP_ORDER_STATUS_FAILED")]
        OnrampOrderStatusFailed,
    }
    impl ::std::convert::From<&Self> for OnrampOrderStatus {
        fn from(value: &OnrampOrderStatus) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for OnrampOrderStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::OnrampOrderStatusPendingAuth => {
                    f.write_str("ONRAMP_ORDER_STATUS_PENDING_AUTH")
                }
                Self::OnrampOrderStatusPendingPayment => {
                    f.write_str("ONRAMP_ORDER_STATUS_PENDING_PAYMENT")
                }
                Self::OnrampOrderStatusProcessing => f.write_str("ONRAMP_ORDER_STATUS_PROCESSING"),
                Self::OnrampOrderStatusCompleted => f.write_str("ONRAMP_ORDER_STATUS_COMPLETED"),
                Self::OnrampOrderStatusFailed => f.write_str("ONRAMP_ORDER_STATUS_FAILED"),
            }
        }
    }
    impl ::std::str::FromStr for OnrampOrderStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ONRAMP_ORDER_STATUS_PENDING_AUTH" => Ok(Self::OnrampOrderStatusPendingAuth),
                "ONRAMP_ORDER_STATUS_PENDING_PAYMENT" => Ok(Self::OnrampOrderStatusPendingPayment),
                "ONRAMP_ORDER_STATUS_PROCESSING" => Ok(Self::OnrampOrderStatusProcessing),
                "ONRAMP_ORDER_STATUS_COMPLETED" => Ok(Self::OnrampOrderStatusCompleted),
                "ONRAMP_ORDER_STATUS_FAILED" => Ok(Self::OnrampOrderStatusFailed),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for OnrampOrderStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for OnrampOrderStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for OnrampOrderStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    /**A payment link to pay for an order.

    Please refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/onramp-overview) for details on how to integrate with the different payment link types.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A payment link to pay for an order.\n\nPlease refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/onramp-overview) for details on how to integrate with the different payment link types.",
    ///  "type": "object",
    ///  "required": [
    ///    "paymentLinkType",
    ///    "url"
    ///  ],
    ///  "properties": {
    ///    "paymentLinkType": {
    ///      "$ref": "#/components/schemas/OnrampPaymentLinkType"
    ///    },
    ///    "url": {
    ///      "description": "The URL to the hosted widget the user should be redirected to. For certain payment link types you can append your own redirect_url query parameter to this URL to ensure the user is redirected back to your app after the widget completes.",
    ///      "examples": [
    ///        "https://pay.coinbase.com/v2/api-onramp/apple-pay?sessionToken=MWYwNWQwODktZTZlYy02OTdlLTgzZTYtMTI3NzcyOWJhNjM3"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Url"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct OnrampPaymentLink {
        #[serde(rename = "paymentLinkType")]
        pub payment_link_type: OnrampPaymentLinkType,
        ///The URL to the hosted widget the user should be redirected to. For certain payment link types you can append your own redirect_url query parameter to this URL to ensure the user is redirected back to your app after the widget completes.
        pub url: Url,
    }
    impl ::std::convert::From<&OnrampPaymentLink> for OnrampPaymentLink {
        fn from(value: &OnrampPaymentLink) -> Self {
            value.clone()
        }
    }
    impl OnrampPaymentLink {
        pub fn builder() -> builder::OnrampPaymentLink {
            Default::default()
        }
    }
    ///The type of payment link.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of payment link.",
    ///  "examples": [
    ///    "PAYMENT_LINK_TYPE_APPLE_PAY_BUTTON"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "PAYMENT_LINK_TYPE_APPLE_PAY_BUTTON"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OnrampPaymentLinkType {
        #[serde(rename = "PAYMENT_LINK_TYPE_APPLE_PAY_BUTTON")]
        PaymentLinkTypeApplePayButton,
    }
    impl ::std::convert::From<&Self> for OnrampPaymentLinkType {
        fn from(value: &OnrampPaymentLinkType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for OnrampPaymentLinkType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PaymentLinkTypeApplePayButton => {
                    f.write_str("PAYMENT_LINK_TYPE_APPLE_PAY_BUTTON")
                }
            }
        }
    }
    impl ::std::str::FromStr for OnrampPaymentLinkType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "PAYMENT_LINK_TYPE_APPLE_PAY_BUTTON" => Ok(Self::PaymentLinkTypeApplePayButton),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for OnrampPaymentLinkType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for OnrampPaymentLinkType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for OnrampPaymentLinkType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Quote information with pricing details for the crypto purchase.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Quote information with pricing details for the crypto purchase.",
    ///  "examples": [
    ///    {
    ///      "destinationNetwork": "base",
    ///      "exchangeRate": "1",
    ///      "fees": [
    ///        {
    ///          "amount": "0.5",
    ///          "currency": "USD",
    ///          "type": "FEE_TYPE_EXCHANGE"
    ///        },
    ///        {
    ///          "amount": "0.25",
    ///          "currency": "USD",
    ///          "type": "FEE_TYPE_NETWORK"
    ///        }
    ///      ],
    ///      "paymentCurrency": "USD",
    ///      "paymentSubtotal": "100.00",
    ///      "paymentTotal": "100.75",
    ///      "purchaseAmount": "100.000000",
    ///      "purchaseCurrency": "USDC"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "destinationNetwork",
    ///    "exchangeRate",
    ///    "fees",
    ///    "paymentCurrency",
    ///    "paymentSubtotal",
    ///    "paymentTotal",
    ///    "purchaseAmount",
    ///    "purchaseCurrency"
    ///  ],
    ///  "properties": {
    ///    "destinationNetwork": {
    ///      "description": "The network to send the crypto on.",
    ///      "examples": [
    ///        "base"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "exchangeRate": {
    ///      "description": "The exchange rate used to convert fiat to crypto i.e. the crypto value of one fiat.",
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fees": {
    ///      "description": "The fees associated with the quote.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "amount": "0.5",
    ///            "currency": "USD",
    ///            "type": "FEE_TYPE_EXCHANGE"
    ///          },
    ///          {
    ///            "amount": "0.25",
    ///            "currency": "USD",
    ///            "type": "FEE_TYPE_NETWORK"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/OnrampOrderFee"
    ///      }
    ///    },
    ///    "paymentCurrency": {
    ///      "description": "The fiat currency to be converted to crypto.",
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentSubtotal": {
    ///      "description": "The amount of fiat to be converted to crypto.",
    ///      "examples": [
    ///        "100.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "paymentTotal": {
    ///      "description": "The total amount of fiat to be paid, inclusive of any fees.",
    ///      "examples": [
    ///        "100.75"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "purchaseAmount": {
    ///      "description": "The amount of crypto to be purchased.",
    ///      "examples": [
    ///        "100.000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "purchaseCurrency": {
    ///      "description": "The crypto currency to be purchased.",
    ///      "examples": [
    ///        "USDC"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct OnrampQuote {
        ///The network to send the crypto on.
        #[serde(rename = "destinationNetwork")]
        pub destination_network: ::std::string::String,
        ///The exchange rate used to convert fiat to crypto i.e. the crypto value of one fiat.
        #[serde(rename = "exchangeRate")]
        pub exchange_rate: ::std::string::String,
        ///The fees associated with the quote.
        pub fees: ::std::vec::Vec<OnrampOrderFee>,
        ///The fiat currency to be converted to crypto.
        #[serde(rename = "paymentCurrency")]
        pub payment_currency: ::std::string::String,
        ///The amount of fiat to be converted to crypto.
        #[serde(rename = "paymentSubtotal")]
        pub payment_subtotal: ::std::string::String,
        ///The total amount of fiat to be paid, inclusive of any fees.
        #[serde(rename = "paymentTotal")]
        pub payment_total: ::std::string::String,
        ///The amount of crypto to be purchased.
        #[serde(rename = "purchaseAmount")]
        pub purchase_amount: ::std::string::String,
        ///The crypto currency to be purchased.
        #[serde(rename = "purchaseCurrency")]
        pub purchase_currency: ::std::string::String,
    }
    impl ::std::convert::From<&OnrampQuote> for OnrampQuote {
        fn from(value: &OnrampQuote) -> Self {
            value.clone()
        }
    }
    impl OnrampQuote {
        pub fn builder() -> builder::OnrampQuote {
            Default::default()
        }
    }
    ///The type of payment method used to generate the onramp quote.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of payment method used to generate the onramp quote.",
    ///  "examples": [
    ///    "CARD"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "CARD",
    ///    "ACH",
    ///    "APPLE_PAY",
    ///    "PAYPAL",
    ///    "FIAT_WALLET",
    ///    "CRYPTO_WALLET"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OnrampQuotePaymentMethodTypeId {
        #[serde(rename = "CARD")]
        Card,
        #[serde(rename = "ACH")]
        Ach,
        #[serde(rename = "APPLE_PAY")]
        ApplePay,
        #[serde(rename = "PAYPAL")]
        Paypal,
        #[serde(rename = "FIAT_WALLET")]
        FiatWallet,
        #[serde(rename = "CRYPTO_WALLET")]
        CryptoWallet,
    }
    impl ::std::convert::From<&Self> for OnrampQuotePaymentMethodTypeId {
        fn from(value: &OnrampQuotePaymentMethodTypeId) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for OnrampQuotePaymentMethodTypeId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Card => f.write_str("CARD"),
                Self::Ach => f.write_str("ACH"),
                Self::ApplePay => f.write_str("APPLE_PAY"),
                Self::Paypal => f.write_str("PAYPAL"),
                Self::FiatWallet => f.write_str("FIAT_WALLET"),
                Self::CryptoWallet => f.write_str("CRYPTO_WALLET"),
            }
        }
    }
    impl ::std::str::FromStr for OnrampQuotePaymentMethodTypeId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "CARD" => Ok(Self::Card),
                "ACH" => Ok(Self::Ach),
                "APPLE_PAY" => Ok(Self::ApplePay),
                "PAYPAL" => Ok(Self::Paypal),
                "FIAT_WALLET" => Ok(Self::FiatWallet),
                "CRYPTO_WALLET" => Ok(Self::CryptoWallet),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for OnrampQuotePaymentMethodTypeId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for OnrampQuotePaymentMethodTypeId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for OnrampQuotePaymentMethodTypeId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///An onramp session containing a ready-to-use onramp URL.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An onramp session containing a ready-to-use onramp URL.",
    ///  "examples": [
    ///    {
    ///      "onrampUrl": "https://pay.coinbase.com/buy?sessionToken=abc123F"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "onrampUrl"
    ///  ],
    ///  "properties": {
    ///    "onrampUrl": {
    ///      "description": "Ready-to-use onramp URL.",
    ///      "examples": [
    ///        "https://pay.coinbase.com/buy?sessionToken=abc123F"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Url"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct OnrampSession {
        ///Ready-to-use onramp URL.
        #[serde(rename = "onrampUrl")]
        pub onramp_url: Url,
    }
    impl ::std::convert::From<&OnrampSession> for OnrampSession {
        fn from(value: &OnrampSession) -> Self {
            value.clone()
        }
    }
    impl OnrampSession {
        pub fn builder() -> builder::OnrampSession {
            Default::default()
        }
    }
    ///`Policy`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "createdAt",
    ///    "id",
    ///    "rules",
    ///    "scope",
    ///    "updatedAt"
    ///  ],
    ///  "properties": {
    ///    "createdAt": {
    ///      "description": "The ISO 8601 timestamp at which the Policy was created.",
    ///      "examples": [
    ///        "2025-03-25T12:00:00Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "description": "An optional human-readable description of the policy.\nPolicy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.",
    ///      "examples": [
    ///        "Default policy"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[A-Za-z0-9 ,.]{1,50}$"
    ///    },
    ///    "id": {
    ///      "description": "The unique identifier for the policy.",
    ///      "examples": [
    ///        "123e4567-e89b-12d3-a456-426614174000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
    ///    },
    ///    "rules": {
    ///      "description": "A list of rules that comprise the policy.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "action": "accept",
    ///            "criteria": [
    ///              {
    ///                "ethValue": "1000000000000000000",
    ///                "operator": "<=",
    ///                "type": "ethValue"
    ///              },
    ///              {
    ///                "addresses": [
    ///                  "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///                  "0x1234567890123456789012345678901234567890"
    ///                ],
    ///                "operator": "in",
    ///                "type": "evmAddress"
    ///              }
    ///            ],
    ///            "operation": "signEvmTransaction"
    ///          },
    ///          {
    ///            "action": "accept",
    ///            "criteria": [
    ///              {
    ///                "addresses": [
    ///                  "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///                ],
    ///                "operator": "in",
    ///                "type": "solAddress"
    ///              }
    ///            ],
    ///            "operation": "signSolTransaction"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Rule"
    ///      }
    ///    },
    ///    "scope": {
    ///      "description": "The scope of the policy. Only one project-level policy can exist at any time.",
    ///      "examples": [
    ///        "project"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "project",
    ///        "account"
    ///      ]
    ///    },
    ///    "updatedAt": {
    ///      "description": "The ISO 8601 timestamp at which the Policy was last updated.",
    ///      "examples": [
    ///        "2025-03-26T12:00:00Z"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct Policy {
        ///The ISO 8601 timestamp at which the Policy was created.
        #[serde(rename = "createdAt")]
        pub created_at: ::std::string::String,
        /**An optional human-readable description of the policy.
        Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<PolicyDescription>,
        ///The unique identifier for the policy.
        pub id: PolicyId,
        ///A list of rules that comprise the policy.
        pub rules: ::std::vec::Vec<Rule>,
        ///The scope of the policy. Only one project-level policy can exist at any time.
        pub scope: PolicyScope,
        ///The ISO 8601 timestamp at which the Policy was last updated.
        #[serde(rename = "updatedAt")]
        pub updated_at: ::std::string::String,
    }
    impl ::std::convert::From<&Policy> for Policy {
        fn from(value: &Policy) -> Self {
            value.clone()
        }
    }
    impl Policy {
        pub fn builder() -> builder::Policy {
            Default::default()
        }
    }
    /**An optional human-readable description of the policy.
    Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An optional human-readable description of the policy.\nPolicy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.",
    ///  "examples": [
    ///    "Default policy"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[A-Za-z0-9 ,.]{1,50}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PolicyDescription(::std::string::String);
    impl ::std::ops::Deref for PolicyDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<PolicyDescription> for ::std::string::String {
        fn from(value: PolicyDescription) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&PolicyDescription> for PolicyDescription {
        fn from(value: &PolicyDescription) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PolicyDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[A-Za-z0-9 ,.]{1,50}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[A-Za-z0-9 ,.]{1,50}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PolicyDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PolicyDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PolicyDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PolicyDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The unique identifier for the policy.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The unique identifier for the policy.",
    ///  "examples": [
    ///    "123e4567-e89b-12d3-a456-426614174000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PolicyId(::std::string::String);
    impl ::std::ops::Deref for PolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<PolicyId> for ::std::string::String {
        fn from(value: PolicyId) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&PolicyId> for PolicyId {
        fn from(value: &PolicyId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(
                || {
                    ::regress::Regex::new(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
                    )
                    .unwrap()
                },
            );
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The scope of the policy. Only one project-level policy can exist at any time.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The scope of the policy. Only one project-level policy can exist at any time.",
    ///  "examples": [
    ///    "project"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "project",
    ///    "account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PolicyScope {
        #[serde(rename = "project")]
        Project,
        #[serde(rename = "account")]
        Account,
    }
    impl ::std::convert::From<&Self> for PolicyScope {
        fn from(value: &PolicyScope) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PolicyScope {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Project => f.write_str("project"),
                Self::Account => f.write_str("account"),
            }
        }
    }
    impl ::std::str::FromStr for PolicyScope {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "project" => Ok(Self::Project),
                "account" => Ok(Self::Account),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PolicyScope {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PolicyScope {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PolicyScope {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PrepareAndSendUserOperationAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PrepareAndSendUserOperationAddress(::std::string::String);
    impl ::std::ops::Deref for PrepareAndSendUserOperationAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<PrepareAndSendUserOperationAddress> for ::std::string::String {
        fn from(value: PrepareAndSendUserOperationAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&PrepareAndSendUserOperationAddress>
        for PrepareAndSendUserOperationAddress
    {
        fn from(value: &PrepareAndSendUserOperationAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PrepareAndSendUserOperationAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PrepareAndSendUserOperationAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PrepareAndSendUserOperationAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PrepareAndSendUserOperationAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PrepareAndSendUserOperationAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`PrepareAndSendUserOperationBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "calls",
    ///    "network"
    ///  ],
    ///  "properties": {
    ///    "calls": {
    ///      "description": "The list of calls to make from the Smart Account.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EvmCall"
    ///      }
    ///    },
    ///    "network": {
    ///      "$ref": "#/components/schemas/EvmUserOperationNetwork"
    ///    },
    ///    "paymasterUrl": {
    ///      "description": "The URL of the paymaster to use for the user operation.",
    ///      "examples": [
    ///        "https://api.developer.coinbase.com/rpc/v1/base/<token>"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Url"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PrepareAndSendUserOperationBody {
        ///The list of calls to make from the Smart Account.
        pub calls: ::std::vec::Vec<EvmCall>,
        pub network: EvmUserOperationNetwork,
        ///The URL of the paymaster to use for the user operation.
        #[serde(
            rename = "paymasterUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paymaster_url: ::std::option::Option<Url>,
    }
    impl ::std::convert::From<&PrepareAndSendUserOperationBody> for PrepareAndSendUserOperationBody {
        fn from(value: &PrepareAndSendUserOperationBody) -> Self {
            value.clone()
        }
    }
    impl PrepareAndSendUserOperationBody {
        pub fn builder() -> builder::PrepareAndSendUserOperationBody {
            Default::default()
        }
    }
    ///`PrepareAndSendUserOperationXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PrepareAndSendUserOperationXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for PrepareAndSendUserOperationXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<PrepareAndSendUserOperationXIdempotencyKey> for ::std::string::String {
        fn from(value: PrepareAndSendUserOperationXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&PrepareAndSendUserOperationXIdempotencyKey>
        for PrepareAndSendUserOperationXIdempotencyKey
    {
        fn from(value: &PrepareAndSendUserOperationXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PrepareAndSendUserOperationXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PrepareAndSendUserOperationXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for PrepareAndSendUserOperationXIdempotencyKey
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PrepareAndSendUserOperationXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PrepareAndSendUserOperationXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`PrepareUserOperationAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PrepareUserOperationAddress(::std::string::String);
    impl ::std::ops::Deref for PrepareUserOperationAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<PrepareUserOperationAddress> for ::std::string::String {
        fn from(value: PrepareUserOperationAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&PrepareUserOperationAddress> for PrepareUserOperationAddress {
        fn from(value: &PrepareUserOperationAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PrepareUserOperationAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PrepareUserOperationAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PrepareUserOperationAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PrepareUserOperationAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PrepareUserOperationAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`PrepareUserOperationBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "calls",
    ///    "network"
    ///  ],
    ///  "properties": {
    ///    "calls": {
    ///      "description": "The list of calls to make from the Smart Account.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EvmCall"
    ///      }
    ///    },
    ///    "dataSuffix": {
    ///      "description": "The EIP-8021 data suffix (hex-encoded) that enables transaction attribution for the user operation.",
    ///      "examples": [
    ///        "0xdddddddd62617365617070070080218021802180218021802180218021"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]+$"
    ///    },
    ///    "network": {
    ///      "$ref": "#/components/schemas/EvmUserOperationNetwork"
    ///    },
    ///    "paymasterUrl": {
    ///      "description": "The URL of the paymaster to use for the user operation.",
    ///      "examples": [
    ///        "https://api.developer.coinbase.com/rpc/v1/base/<token>"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Url"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PrepareUserOperationBody {
        ///The list of calls to make from the Smart Account.
        pub calls: ::std::vec::Vec<EvmCall>,
        ///The EIP-8021 data suffix (hex-encoded) that enables transaction attribution for the user operation.
        #[serde(
            rename = "dataSuffix",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub data_suffix: ::std::option::Option<PrepareUserOperationBodyDataSuffix>,
        pub network: EvmUserOperationNetwork,
        ///The URL of the paymaster to use for the user operation.
        #[serde(
            rename = "paymasterUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paymaster_url: ::std::option::Option<Url>,
    }
    impl ::std::convert::From<&PrepareUserOperationBody> for PrepareUserOperationBody {
        fn from(value: &PrepareUserOperationBody) -> Self {
            value.clone()
        }
    }
    impl PrepareUserOperationBody {
        pub fn builder() -> builder::PrepareUserOperationBody {
            Default::default()
        }
    }
    ///The EIP-8021 data suffix (hex-encoded) that enables transaction attribution for the user operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The EIP-8021 data suffix (hex-encoded) that enables transaction attribution for the user operation.",
    ///  "examples": [
    ///    "0xdddddddd62617365617070070080218021802180218021802180218021"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PrepareUserOperationBodyDataSuffix(::std::string::String);
    impl ::std::ops::Deref for PrepareUserOperationBodyDataSuffix {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<PrepareUserOperationBodyDataSuffix> for ::std::string::String {
        fn from(value: PrepareUserOperationBodyDataSuffix) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&PrepareUserOperationBodyDataSuffix>
        for PrepareUserOperationBodyDataSuffix
    {
        fn from(value: &PrepareUserOperationBodyDataSuffix) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PrepareUserOperationBodyDataSuffix {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^0x[0-9a-fA-F]+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PrepareUserOperationBodyDataSuffix {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PrepareUserOperationBodyDataSuffix {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PrepareUserOperationBodyDataSuffix {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PrepareUserOperationBodyDataSuffix {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///A schema for specifying criteria for the PrepareUserOperation operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A schema for specifying criteria for the PrepareUserOperation operation.",
    ///  "examples": [
    ///    [
    ///      {
    ///        "ethValue": "1000000",
    ///        "operator": ">=",
    ///        "type": "ethValue"
    ///      },
    ///      {
    ///        "addresses": [
    ///          "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///        ],
    ///        "operator": "in",
    ///        "type": "evmAddress"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "array",
    ///  "items": {
    ///    "oneOf": [
    ///      {
    ///        "$ref": "#/components/schemas/EthValueCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/EvmAddressCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/EvmNetworkCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/EvmDataCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/NetUSDChangeCriterion"
    ///      }
    ///    ]
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PrepareUserOperationCriteria(pub ::std::vec::Vec<PrepareUserOperationCriteriaItem>);
    impl ::std::ops::Deref for PrepareUserOperationCriteria {
        type Target = ::std::vec::Vec<PrepareUserOperationCriteriaItem>;
        fn deref(&self) -> &::std::vec::Vec<PrepareUserOperationCriteriaItem> {
            &self.0
        }
    }
    impl ::std::convert::From<PrepareUserOperationCriteria>
        for ::std::vec::Vec<PrepareUserOperationCriteriaItem>
    {
        fn from(value: PrepareUserOperationCriteria) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&PrepareUserOperationCriteria> for PrepareUserOperationCriteria {
        fn from(value: &PrepareUserOperationCriteria) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::vec::Vec<PrepareUserOperationCriteriaItem>>
        for PrepareUserOperationCriteria
    {
        fn from(value: ::std::vec::Vec<PrepareUserOperationCriteriaItem>) -> Self {
            Self(value)
        }
    }
    ///`PrepareUserOperationCriteriaItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/EthValueCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EvmAddressCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EvmNetworkCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EvmDataCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NetUSDChangeCriterion"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PrepareUserOperationCriteriaItem {
        EthValueCriterion(EthValueCriterion),
        EvmAddressCriterion(EvmAddressCriterion),
        EvmNetworkCriterion(EvmNetworkCriterion),
        EvmDataCriterion(EvmDataCriterion),
        NetUsdChangeCriterion(NetUsdChangeCriterion),
    }
    impl ::std::convert::From<&Self> for PrepareUserOperationCriteriaItem {
        fn from(value: &PrepareUserOperationCriteriaItem) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<EthValueCriterion> for PrepareUserOperationCriteriaItem {
        fn from(value: EthValueCriterion) -> Self {
            Self::EthValueCriterion(value)
        }
    }
    impl ::std::convert::From<EvmAddressCriterion> for PrepareUserOperationCriteriaItem {
        fn from(value: EvmAddressCriterion) -> Self {
            Self::EvmAddressCriterion(value)
        }
    }
    impl ::std::convert::From<EvmNetworkCriterion> for PrepareUserOperationCriteriaItem {
        fn from(value: EvmNetworkCriterion) -> Self {
            Self::EvmNetworkCriterion(value)
        }
    }
    impl ::std::convert::From<EvmDataCriterion> for PrepareUserOperationCriteriaItem {
        fn from(value: EvmDataCriterion) -> Self {
            Self::EvmDataCriterion(value)
        }
    }
    impl ::std::convert::From<NetUsdChangeCriterion> for PrepareUserOperationCriteriaItem {
        fn from(value: NetUsdChangeCriterion) -> Self {
            Self::NetUsdChangeCriterion(value)
        }
    }
    ///`PrepareUserOperationRule`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "PrepareUserOperationRule",
    ///  "required": [
    ///    "action",
    ///    "criteria",
    ///    "operation"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///      "examples": [
    ///        "accept"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "reject",
    ///        "accept"
    ///      ]
    ///    },
    ///    "criteria": {
    ///      "$ref": "#/components/schemas/PrepareUserOperationCriteria"
    ///    },
    ///    "operation": {
    ///      "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///      "examples": [
    ///        "prepareUserOperation"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "prepareUserOperation"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PrepareUserOperationRule {
        ///Whether matching the rule will cause the request to be rejected or accepted.
        pub action: PrepareUserOperationRuleAction,
        pub criteria: PrepareUserOperationCriteria,
        ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
        pub operation: PrepareUserOperationRuleOperation,
    }
    impl ::std::convert::From<&PrepareUserOperationRule> for PrepareUserOperationRule {
        fn from(value: &PrepareUserOperationRule) -> Self {
            value.clone()
        }
    }
    impl PrepareUserOperationRule {
        pub fn builder() -> builder::PrepareUserOperationRule {
            Default::default()
        }
    }
    ///Whether matching the rule will cause the request to be rejected or accepted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///  "examples": [
    ///    "accept"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "reject",
    ///    "accept"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PrepareUserOperationRuleAction {
        #[serde(rename = "reject")]
        Reject,
        #[serde(rename = "accept")]
        Accept,
    }
    impl ::std::convert::From<&Self> for PrepareUserOperationRuleAction {
        fn from(value: &PrepareUserOperationRuleAction) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PrepareUserOperationRuleAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Reject => f.write_str("reject"),
                Self::Accept => f.write_str("accept"),
            }
        }
    }
    impl ::std::str::FromStr for PrepareUserOperationRuleAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "reject" => Ok(Self::Reject),
                "accept" => Ok(Self::Accept),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PrepareUserOperationRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PrepareUserOperationRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PrepareUserOperationRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///  "examples": [
    ///    "prepareUserOperation"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "prepareUserOperation"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PrepareUserOperationRuleOperation {
        #[serde(rename = "prepareUserOperation")]
        PrepareUserOperation,
    }
    impl ::std::convert::From<&Self> for PrepareUserOperationRuleOperation {
        fn from(value: &PrepareUserOperationRuleOperation) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PrepareUserOperationRuleOperation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PrepareUserOperation => f.write_str("prepareUserOperation"),
            }
        }
    }
    impl ::std::str::FromStr for PrepareUserOperationRuleOperation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "prepareUserOperation" => Ok(Self::PrepareUserOperation),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PrepareUserOperationRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PrepareUserOperationRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PrepareUserOperationRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The criterion for the program IDs of a Solana transaction's instructions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "ProgramIdCriterion",
    ///  "description": "The criterion for the program IDs of a Solana transaction's instructions.",
    ///  "type": "object",
    ///  "required": [
    ///    "operator",
    ///    "programIds",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. Each of the program IDs in the transaction's instructions will be on the left-hand side of the operator, and the `programIds` field will be on the right-hand side.",
    ///      "examples": [
    ///        "in"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "in",
    ///        "not in"
    ///      ]
    ///    },
    ///    "programIds": {
    ///      "description": "The Solana program IDs that are compared to the list of program IDs in the transaction's instructions.",
    ///      "examples": [
    ///        [
    ///          "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
    ///          "11111111111111111111111111111112"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "The Solana program ID that is compared to the list of program IDs in the transaction's instructions.",
    ///        "type": "string",
    ///        "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///      }
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `programId`.",
    ///      "examples": [
    ///        "programId"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "programId"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgramIdCriterion {
        ///The operator to use for the comparison. Each of the program IDs in the transaction's instructions will be on the left-hand side of the operator, and the `programIds` field will be on the right-hand side.
        pub operator: ProgramIdCriterionOperator,
        ///The Solana program IDs that are compared to the list of program IDs in the transaction's instructions.
        #[serde(rename = "programIds")]
        pub program_ids: ::std::vec::Vec<ProgramIdCriterionProgramIdsItem>,
        ///The type of criterion to use. This should be `programId`.
        #[serde(rename = "type")]
        pub type_: ProgramIdCriterionType,
    }
    impl ::std::convert::From<&ProgramIdCriterion> for ProgramIdCriterion {
        fn from(value: &ProgramIdCriterion) -> Self {
            value.clone()
        }
    }
    impl ProgramIdCriterion {
        pub fn builder() -> builder::ProgramIdCriterion {
            Default::default()
        }
    }
    ///The operator to use for the comparison. Each of the program IDs in the transaction's instructions will be on the left-hand side of the operator, and the `programIds` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. Each of the program IDs in the transaction's instructions will be on the left-hand side of the operator, and the `programIds` field will be on the right-hand side.",
    ///  "examples": [
    ///    "in"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "in",
    ///    "not in"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ProgramIdCriterionOperator {
        #[serde(rename = "in")]
        In,
        #[serde(rename = "not in")]
        NotIn,
    }
    impl ::std::convert::From<&Self> for ProgramIdCriterionOperator {
        fn from(value: &ProgramIdCriterionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgramIdCriterionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::In => f.write_str("in"),
                Self::NotIn => f.write_str("not in"),
            }
        }
    }
    impl ::std::str::FromStr for ProgramIdCriterionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "in" => Ok(Self::In),
                "not in" => Ok(Self::NotIn),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for ProgramIdCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ProgramIdCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ProgramIdCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The Solana program ID that is compared to the list of program IDs in the transaction's instructions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Solana program ID that is compared to the list of program IDs in the transaction's instructions.",
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ProgramIdCriterionProgramIdsItem(::std::string::String);
    impl ::std::ops::Deref for ProgramIdCriterionProgramIdsItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ProgramIdCriterionProgramIdsItem> for ::std::string::String {
        fn from(value: ProgramIdCriterionProgramIdsItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ProgramIdCriterionProgramIdsItem> for ProgramIdCriterionProgramIdsItem {
        fn from(value: &ProgramIdCriterionProgramIdsItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ProgramIdCriterionProgramIdsItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ProgramIdCriterionProgramIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ProgramIdCriterionProgramIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ProgramIdCriterionProgramIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ProgramIdCriterionProgramIdsItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The type of criterion to use. This should be `programId`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `programId`.",
    ///  "examples": [
    ///    "programId"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "programId"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ProgramIdCriterionType {
        #[serde(rename = "programId")]
        ProgramId,
    }
    impl ::std::convert::From<&Self> for ProgramIdCriterionType {
        fn from(value: &ProgramIdCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgramIdCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ProgramId => f.write_str("programId"),
            }
        }
    }
    impl ::std::str::FromStr for ProgramIdCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "programId" => Ok(Self::ProgramId),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for ProgramIdCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ProgramIdCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ProgramIdCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    /**Enables control over how often queries need to be fully re-executed on the backing store.
    This can be useful in scenarios where API calls might be made frequently, API latency is critical, and some freshness lag (ex: 750ms, 2s, 5s) is tolerable.
    By default, each query result is returned from cache so long as the result is from an identical query and less than 500ms old. This freshness tolerance can be modified upwards, to a maximum of 900000ms (i.e. 900s, 15m).
    */
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Query result cache configuration",
    ///  "description": "Enables control over how often queries need to be fully re-executed on the backing store.\nThis can be useful in scenarios where API calls might be made frequently, API latency is critical, and some freshness lag (ex: 750ms, 2s, 5s) is tolerable.\nBy default, each query result is returned from cache so long as the result is from an identical query and less than 500ms old. This freshness tolerance can be modified upwards, to a maximum of 900000ms (i.e. 900s, 15m).\n",
    ///  "examples": [
    ///    {
    ///      "maxAgeMs": 1000
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "maxAgeMs": {
    ///      "description": "The maximum tolerable staleness of the query result cache in milliseconds. If a previous execution result of an identical query is older than this age, the query will be re-executed. If the data is less than this age, the result will be returned from cache.",
    ///      "default": 500,
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "integer",
    ///      "maximum": 900000.0,
    ///      "minimum": 500.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct QueryResultCacheConfiguration {
        ///The maximum tolerable staleness of the query result cache in milliseconds. If a previous execution result of an identical query is older than this age, the query will be re-executed. If the data is less than this age, the result will be returned from cache.
        #[serde(rename = "maxAgeMs", default = "defaults::default_u64::<i64, 500>")]
        pub max_age_ms: i64,
    }
    impl ::std::convert::From<&QueryResultCacheConfiguration> for QueryResultCacheConfiguration {
        fn from(value: &QueryResultCacheConfiguration) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for QueryResultCacheConfiguration {
        fn default() -> Self {
            Self {
                max_age_ms: defaults::default_u64::<i64, 500>(),
            }
        }
    }
    impl QueryResultCacheConfiguration {
        pub fn builder() -> builder::QueryResultCacheConfiguration {
            Default::default()
        }
    }
    ///`RequestEvmFaucetBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "network",
    ///    "token"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The address to request funds to, which is a 0x-prefixed hexadecimal string.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]{40}$"
    ///    },
    ///    "network": {
    ///      "description": "The network to request funds from.",
    ///      "examples": [
    ///        "base-sepolia"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "base-sepolia",
    ///        "ethereum-sepolia",
    ///        "ethereum-hoodi"
    ///      ]
    ///    },
    ///    "token": {
    ///      "description": "The token to request funds for.",
    ///      "examples": [
    ///        "eth"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "eth",
    ///        "usdc",
    ///        "eurc",
    ///        "cbbtc"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct RequestEvmFaucetBody {
        ///The address to request funds to, which is a 0x-prefixed hexadecimal string.
        pub address: RequestEvmFaucetBodyAddress,
        ///The network to request funds from.
        pub network: RequestEvmFaucetBodyNetwork,
        ///The token to request funds for.
        pub token: RequestEvmFaucetBodyToken,
    }
    impl ::std::convert::From<&RequestEvmFaucetBody> for RequestEvmFaucetBody {
        fn from(value: &RequestEvmFaucetBody) -> Self {
            value.clone()
        }
    }
    impl RequestEvmFaucetBody {
        pub fn builder() -> builder::RequestEvmFaucetBody {
            Default::default()
        }
    }
    ///The address to request funds to, which is a 0x-prefixed hexadecimal string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The address to request funds to, which is a 0x-prefixed hexadecimal string.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct RequestEvmFaucetBodyAddress(::std::string::String);
    impl ::std::ops::Deref for RequestEvmFaucetBodyAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<RequestEvmFaucetBodyAddress> for ::std::string::String {
        fn from(value: RequestEvmFaucetBodyAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&RequestEvmFaucetBodyAddress> for RequestEvmFaucetBodyAddress {
        fn from(value: &RequestEvmFaucetBodyAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for RequestEvmFaucetBodyAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for RequestEvmFaucetBodyAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for RequestEvmFaucetBodyAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for RequestEvmFaucetBodyAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RequestEvmFaucetBodyAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The network to request funds from.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The network to request funds from.",
    ///  "examples": [
    ///    "base-sepolia"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "base-sepolia",
    ///    "ethereum-sepolia",
    ///    "ethereum-hoodi"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RequestEvmFaucetBodyNetwork {
        #[serde(rename = "base-sepolia")]
        BaseSepolia,
        #[serde(rename = "ethereum-sepolia")]
        EthereumSepolia,
        #[serde(rename = "ethereum-hoodi")]
        EthereumHoodi,
    }
    impl ::std::convert::From<&Self> for RequestEvmFaucetBodyNetwork {
        fn from(value: &RequestEvmFaucetBodyNetwork) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for RequestEvmFaucetBodyNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BaseSepolia => f.write_str("base-sepolia"),
                Self::EthereumSepolia => f.write_str("ethereum-sepolia"),
                Self::EthereumHoodi => f.write_str("ethereum-hoodi"),
            }
        }
    }
    impl ::std::str::FromStr for RequestEvmFaucetBodyNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base-sepolia" => Ok(Self::BaseSepolia),
                "ethereum-sepolia" => Ok(Self::EthereumSepolia),
                "ethereum-hoodi" => Ok(Self::EthereumHoodi),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for RequestEvmFaucetBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for RequestEvmFaucetBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for RequestEvmFaucetBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The token to request funds for.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The token to request funds for.",
    ///  "examples": [
    ///    "eth"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "eth",
    ///    "usdc",
    ///    "eurc",
    ///    "cbbtc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RequestEvmFaucetBodyToken {
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eurc")]
        Eurc,
        #[serde(rename = "cbbtc")]
        Cbbtc,
    }
    impl ::std::convert::From<&Self> for RequestEvmFaucetBodyToken {
        fn from(value: &RequestEvmFaucetBodyToken) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for RequestEvmFaucetBodyToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Eth => f.write_str("eth"),
                Self::Usdc => f.write_str("usdc"),
                Self::Eurc => f.write_str("eurc"),
                Self::Cbbtc => f.write_str("cbbtc"),
            }
        }
    }
    impl ::std::str::FromStr for RequestEvmFaucetBodyToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth" => Ok(Self::Eth),
                "usdc" => Ok(Self::Usdc),
                "eurc" => Ok(Self::Eurc),
                "cbbtc" => Ok(Self::Cbbtc),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for RequestEvmFaucetBodyToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for RequestEvmFaucetBodyToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for RequestEvmFaucetBodyToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`RequestEvmFaucetResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "transactionHash"
    ///  ],
    ///  "properties": {
    ///    "transactionHash": {
    ///      "description": "The hash of the transaction that requested the funds.\n**Note:** In rare cases, when gas conditions are unusually high, the transaction may not confirm, and the system may issue a replacement transaction to complete the faucet request. In these rare cases, the `transactionHash` will be out of sync with the actual faucet transaction that was confirmed onchain.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct RequestEvmFaucetResponse {
        /**The hash of the transaction that requested the funds.
         **Note:** In rare cases, when gas conditions are unusually high, the transaction may not confirm, and the system may issue a replacement transaction to complete the faucet request. In these rare cases, the `transactionHash` will be out of sync with the actual faucet transaction that was confirmed onchain.*/
        #[serde(rename = "transactionHash")]
        pub transaction_hash: ::std::string::String,
    }
    impl ::std::convert::From<&RequestEvmFaucetResponse> for RequestEvmFaucetResponse {
        fn from(value: &RequestEvmFaucetResponse) -> Self {
            value.clone()
        }
    }
    impl RequestEvmFaucetResponse {
        pub fn builder() -> builder::RequestEvmFaucetResponse {
            Default::default()
        }
    }
    ///`RequestSolanaFaucetBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "token"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The address to request funds to, which is a base58-encoded string.",
    ///      "examples": [
    ///        "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///    },
    ///    "token": {
    ///      "description": "The token to request funds for.",
    ///      "examples": [
    ///        "sol"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "sol",
    ///        "usdc"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct RequestSolanaFaucetBody {
        ///The address to request funds to, which is a base58-encoded string.
        pub address: RequestSolanaFaucetBodyAddress,
        ///The token to request funds for.
        pub token: RequestSolanaFaucetBodyToken,
    }
    impl ::std::convert::From<&RequestSolanaFaucetBody> for RequestSolanaFaucetBody {
        fn from(value: &RequestSolanaFaucetBody) -> Self {
            value.clone()
        }
    }
    impl RequestSolanaFaucetBody {
        pub fn builder() -> builder::RequestSolanaFaucetBody {
            Default::default()
        }
    }
    ///The address to request funds to, which is a base58-encoded string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The address to request funds to, which is a base58-encoded string.",
    ///  "examples": [
    ///    "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct RequestSolanaFaucetBodyAddress(::std::string::String);
    impl ::std::ops::Deref for RequestSolanaFaucetBodyAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<RequestSolanaFaucetBodyAddress> for ::std::string::String {
        fn from(value: RequestSolanaFaucetBodyAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&RequestSolanaFaucetBodyAddress> for RequestSolanaFaucetBodyAddress {
        fn from(value: &RequestSolanaFaucetBodyAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for RequestSolanaFaucetBodyAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for RequestSolanaFaucetBodyAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for RequestSolanaFaucetBodyAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for RequestSolanaFaucetBodyAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RequestSolanaFaucetBodyAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The token to request funds for.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The token to request funds for.",
    ///  "examples": [
    ///    "sol"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "sol",
    ///    "usdc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RequestSolanaFaucetBodyToken {
        #[serde(rename = "sol")]
        Sol,
        #[serde(rename = "usdc")]
        Usdc,
    }
    impl ::std::convert::From<&Self> for RequestSolanaFaucetBodyToken {
        fn from(value: &RequestSolanaFaucetBodyToken) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for RequestSolanaFaucetBodyToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sol => f.write_str("sol"),
                Self::Usdc => f.write_str("usdc"),
            }
        }
    }
    impl ::std::str::FromStr for RequestSolanaFaucetBodyToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sol" => Ok(Self::Sol),
                "usdc" => Ok(Self::Usdc),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for RequestSolanaFaucetBodyToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for RequestSolanaFaucetBodyToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for RequestSolanaFaucetBodyToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`RequestSolanaFaucetResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "transactionSignature"
    ///  ],
    ///  "properties": {
    ///    "transactionSignature": {
    ///      "description": "The signature identifying the transaction that requested the funds.",
    ///      "examples": [
    ///        "4dje1d24iG2FfxwxTJJt8VSTtYXNc6AAuJwngtL97TJSqqPD3pgRZ7uh4szoU6WDrKyFTBgaswkDrCr7BqWjQqqK"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct RequestSolanaFaucetResponse {
        ///The signature identifying the transaction that requested the funds.
        #[serde(rename = "transactionSignature")]
        pub transaction_signature: ::std::string::String,
    }
    impl ::std::convert::From<&RequestSolanaFaucetResponse> for RequestSolanaFaucetResponse {
        fn from(value: &RequestSolanaFaucetResponse) -> Self {
            value.clone()
        }
    }
    impl RequestSolanaFaucetResponse {
        pub fn builder() -> builder::RequestSolanaFaucetResponse {
            Default::default()
        }
    }
    ///`RevokeSpendPermissionAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct RevokeSpendPermissionAddress(::std::string::String);
    impl ::std::ops::Deref for RevokeSpendPermissionAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<RevokeSpendPermissionAddress> for ::std::string::String {
        fn from(value: RevokeSpendPermissionAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&RevokeSpendPermissionAddress> for RevokeSpendPermissionAddress {
        fn from(value: &RevokeSpendPermissionAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for RevokeSpendPermissionAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for RevokeSpendPermissionAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for RevokeSpendPermissionAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for RevokeSpendPermissionAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RevokeSpendPermissionAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///Request parameters for revoking a Spend Permission.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request parameters for revoking a Spend Permission.",
    ///  "type": "object",
    ///  "required": [
    ///    "network",
    ///    "permissionHash"
    ///  ],
    ///  "properties": {
    ///    "network": {
    ///      "$ref": "#/components/schemas/SpendPermissionNetwork"
    ///    },
    ///    "paymasterUrl": {
    ///      "description": "The paymaster URL of the spend permission.",
    ///      "examples": [
    ///        "https://paymaster.cdp.coinbase.com"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Url"
    ///        }
    ///      ]
    ///    },
    ///    "permissionHash": {
    ///      "description": "The hash of the spend permission to revoke.",
    ///      "examples": [
    ///        "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct RevokeSpendPermissionRequest {
        pub network: SpendPermissionNetwork,
        ///The paymaster URL of the spend permission.
        #[serde(
            rename = "paymasterUrl",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub paymaster_url: ::std::option::Option<Url>,
        ///The hash of the spend permission to revoke.
        #[serde(rename = "permissionHash")]
        pub permission_hash: ::std::string::String,
    }
    impl ::std::convert::From<&RevokeSpendPermissionRequest> for RevokeSpendPermissionRequest {
        fn from(value: &RevokeSpendPermissionRequest) -> Self {
            value.clone()
        }
    }
    impl RevokeSpendPermissionRequest {
        pub fn builder() -> builder::RevokeSpendPermissionRequest {
            Default::default()
        }
    }
    ///`RevokeSpendPermissionXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct RevokeSpendPermissionXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for RevokeSpendPermissionXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<RevokeSpendPermissionXIdempotencyKey> for ::std::string::String {
        fn from(value: RevokeSpendPermissionXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&RevokeSpendPermissionXIdempotencyKey>
        for RevokeSpendPermissionXIdempotencyKey
    {
        fn from(value: &RevokeSpendPermissionXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for RevokeSpendPermissionXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for RevokeSpendPermissionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for RevokeSpendPermissionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for RevokeSpendPermissionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RevokeSpendPermissionXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///A rule that limits the behavior of an account.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A rule that limits the behavior of an account.",
    ///  "examples": [
    ///    {
    ///      "action": "accept",
    ///      "criteria": [
    ///        {
    ///          "ethValue": "1000000",
    ///          "operator": ">=",
    ///          "type": "ethValue"
    ///        },
    ///        {
    ///          "addresses": [
    ///            "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///          ],
    ///          "operator": "in",
    ///          "type": "evmAddress"
    ///        }
    ///      ],
    ///      "operation": "signEvmTransaction"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SignEvmTransactionRule"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SendEvmTransactionRule"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SignEvmMessageRule"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SignEvmTypedDataRule"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SignSolTransactionRule"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SendSolTransactionRule"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SignSolMessageRule"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SignEvmHashRule"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PrepareUserOperationRule"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SendUserOperationRule"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum Rule {
        SignEvmTransactionRule(SignEvmTransactionRule),
        SendEvmTransactionRule(SendEvmTransactionRule),
        SignEvmMessageRule(SignEvmMessageRule),
        SignEvmTypedDataRule(SignEvmTypedDataRule),
        SignSolTransactionRule(SignSolTransactionRule),
        SendSolTransactionRule(SendSolTransactionRule),
        SignSolMessageRule(SignSolMessageRule),
        SignEvmHashRule(SignEvmHashRule),
        PrepareUserOperationRule(PrepareUserOperationRule),
        SendUserOperationRule(SendUserOperationRule),
    }
    impl ::std::convert::From<&Self> for Rule {
        fn from(value: &Rule) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<SignEvmTransactionRule> for Rule {
        fn from(value: SignEvmTransactionRule) -> Self {
            Self::SignEvmTransactionRule(value)
        }
    }
    impl ::std::convert::From<SendEvmTransactionRule> for Rule {
        fn from(value: SendEvmTransactionRule) -> Self {
            Self::SendEvmTransactionRule(value)
        }
    }
    impl ::std::convert::From<SignEvmMessageRule> for Rule {
        fn from(value: SignEvmMessageRule) -> Self {
            Self::SignEvmMessageRule(value)
        }
    }
    impl ::std::convert::From<SignEvmTypedDataRule> for Rule {
        fn from(value: SignEvmTypedDataRule) -> Self {
            Self::SignEvmTypedDataRule(value)
        }
    }
    impl ::std::convert::From<SignSolTransactionRule> for Rule {
        fn from(value: SignSolTransactionRule) -> Self {
            Self::SignSolTransactionRule(value)
        }
    }
    impl ::std::convert::From<SendSolTransactionRule> for Rule {
        fn from(value: SendSolTransactionRule) -> Self {
            Self::SendSolTransactionRule(value)
        }
    }
    impl ::std::convert::From<SignSolMessageRule> for Rule {
        fn from(value: SignSolMessageRule) -> Self {
            Self::SignSolMessageRule(value)
        }
    }
    impl ::std::convert::From<SignEvmHashRule> for Rule {
        fn from(value: SignEvmHashRule) -> Self {
            Self::SignEvmHashRule(value)
        }
    }
    impl ::std::convert::From<PrepareUserOperationRule> for Rule {
        fn from(value: PrepareUserOperationRule) -> Self {
            Self::PrepareUserOperationRule(value)
        }
    }
    impl ::std::convert::From<SendUserOperationRule> for Rule {
        fn from(value: SendUserOperationRule) -> Self {
            Self::SendUserOperationRule(value)
        }
    }
    ///`SendEvmTransactionAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SendEvmTransactionAddress(::std::string::String);
    impl ::std::ops::Deref for SendEvmTransactionAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SendEvmTransactionAddress> for ::std::string::String {
        fn from(value: SendEvmTransactionAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SendEvmTransactionAddress> for SendEvmTransactionAddress {
        fn from(value: &SendEvmTransactionAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SendEvmTransactionAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SendEvmTransactionAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SendEvmTransactionAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SendEvmTransactionAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SendEvmTransactionAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SendEvmTransactionBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "network",
    ///    "transaction"
    ///  ],
    ///  "properties": {
    ///    "network": {
    ///      "description": "The network to send the transaction to.",
    ///      "examples": [
    ///        "base-sepolia"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "base",
    ///        "base-sepolia",
    ///        "ethereum",
    ///        "ethereum-sepolia",
    ///        "avalanche",
    ///        "polygon",
    ///        "optimism",
    ///        "arbitrum"
    ///      ]
    ///    },
    ///    "transaction": {
    ///      "description": "The RLP-encoded transaction to sign and send, as a 0x-prefixed hex string.",
    ///      "examples": [
    ///        "0xf86b098505d21dba00830334509431415daf58e2c6b7323b4c58712fd92952145da79018080"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SendEvmTransactionBody {
        ///The network to send the transaction to.
        pub network: SendEvmTransactionBodyNetwork,
        ///The RLP-encoded transaction to sign and send, as a 0x-prefixed hex string.
        pub transaction: ::std::string::String,
    }
    impl ::std::convert::From<&SendEvmTransactionBody> for SendEvmTransactionBody {
        fn from(value: &SendEvmTransactionBody) -> Self {
            value.clone()
        }
    }
    impl SendEvmTransactionBody {
        pub fn builder() -> builder::SendEvmTransactionBody {
            Default::default()
        }
    }
    ///The network to send the transaction to.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The network to send the transaction to.",
    ///  "examples": [
    ///    "base-sepolia"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "base",
    ///    "base-sepolia",
    ///    "ethereum",
    ///    "ethereum-sepolia",
    ///    "avalanche",
    ///    "polygon",
    ///    "optimism",
    ///    "arbitrum"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SendEvmTransactionBodyNetwork {
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "base-sepolia")]
        BaseSepolia,
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "ethereum-sepolia")]
        EthereumSepolia,
        #[serde(rename = "avalanche")]
        Avalanche,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "optimism")]
        Optimism,
        #[serde(rename = "arbitrum")]
        Arbitrum,
    }
    impl ::std::convert::From<&Self> for SendEvmTransactionBodyNetwork {
        fn from(value: &SendEvmTransactionBodyNetwork) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SendEvmTransactionBodyNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base => f.write_str("base"),
                Self::BaseSepolia => f.write_str("base-sepolia"),
                Self::Ethereum => f.write_str("ethereum"),
                Self::EthereumSepolia => f.write_str("ethereum-sepolia"),
                Self::Avalanche => f.write_str("avalanche"),
                Self::Polygon => f.write_str("polygon"),
                Self::Optimism => f.write_str("optimism"),
                Self::Arbitrum => f.write_str("arbitrum"),
            }
        }
    }
    impl ::std::str::FromStr for SendEvmTransactionBodyNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base" => Ok(Self::Base),
                "base-sepolia" => Ok(Self::BaseSepolia),
                "ethereum" => Ok(Self::Ethereum),
                "ethereum-sepolia" => Ok(Self::EthereumSepolia),
                "avalanche" => Ok(Self::Avalanche),
                "polygon" => Ok(Self::Polygon),
                "optimism" => Ok(Self::Optimism),
                "arbitrum" => Ok(Self::Arbitrum),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SendEvmTransactionBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SendEvmTransactionBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SendEvmTransactionBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///A schema for specifying criteria for the SignEvmTransaction operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A schema for specifying criteria for the SignEvmTransaction operation.",
    ///  "examples": [
    ///    [
    ///      {
    ///        "ethValue": "1000000",
    ///        "operator": ">=",
    ///        "type": "ethValue"
    ///      },
    ///      {
    ///        "addresses": [
    ///          "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///        ],
    ///        "operator": "in",
    ///        "type": "evmAddress"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "array",
    ///  "items": {
    ///    "oneOf": [
    ///      {
    ///        "$ref": "#/components/schemas/EthValueCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/EvmAddressCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/EvmNetworkCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/EvmDataCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/NetUSDChangeCriterion"
    ///      }
    ///    ]
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SendEvmTransactionCriteria(pub ::std::vec::Vec<SendEvmTransactionCriteriaItem>);
    impl ::std::ops::Deref for SendEvmTransactionCriteria {
        type Target = ::std::vec::Vec<SendEvmTransactionCriteriaItem>;
        fn deref(&self) -> &::std::vec::Vec<SendEvmTransactionCriteriaItem> {
            &self.0
        }
    }
    impl ::std::convert::From<SendEvmTransactionCriteria>
        for ::std::vec::Vec<SendEvmTransactionCriteriaItem>
    {
        fn from(value: SendEvmTransactionCriteria) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SendEvmTransactionCriteria> for SendEvmTransactionCriteria {
        fn from(value: &SendEvmTransactionCriteria) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::vec::Vec<SendEvmTransactionCriteriaItem>>
        for SendEvmTransactionCriteria
    {
        fn from(value: ::std::vec::Vec<SendEvmTransactionCriteriaItem>) -> Self {
            Self(value)
        }
    }
    ///`SendEvmTransactionCriteriaItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/EthValueCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EvmAddressCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EvmNetworkCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EvmDataCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NetUSDChangeCriterion"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum SendEvmTransactionCriteriaItem {
        EthValueCriterion(EthValueCriterion),
        EvmAddressCriterion(EvmAddressCriterion),
        EvmNetworkCriterion(EvmNetworkCriterion),
        EvmDataCriterion(EvmDataCriterion),
        NetUsdChangeCriterion(NetUsdChangeCriterion),
    }
    impl ::std::convert::From<&Self> for SendEvmTransactionCriteriaItem {
        fn from(value: &SendEvmTransactionCriteriaItem) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<EthValueCriterion> for SendEvmTransactionCriteriaItem {
        fn from(value: EthValueCriterion) -> Self {
            Self::EthValueCriterion(value)
        }
    }
    impl ::std::convert::From<EvmAddressCriterion> for SendEvmTransactionCriteriaItem {
        fn from(value: EvmAddressCriterion) -> Self {
            Self::EvmAddressCriterion(value)
        }
    }
    impl ::std::convert::From<EvmNetworkCriterion> for SendEvmTransactionCriteriaItem {
        fn from(value: EvmNetworkCriterion) -> Self {
            Self::EvmNetworkCriterion(value)
        }
    }
    impl ::std::convert::From<EvmDataCriterion> for SendEvmTransactionCriteriaItem {
        fn from(value: EvmDataCriterion) -> Self {
            Self::EvmDataCriterion(value)
        }
    }
    impl ::std::convert::From<NetUsdChangeCriterion> for SendEvmTransactionCriteriaItem {
        fn from(value: NetUsdChangeCriterion) -> Self {
            Self::NetUsdChangeCriterion(value)
        }
    }
    ///`SendEvmTransactionResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "transactionHash"
    ///  ],
    ///  "properties": {
    ///    "transactionHash": {
    ///      "description": "The hash of the transaction, as a 0x-prefixed hex string.",
    ///      "examples": [
    ///        "0xf8f98fb6726fc936f24b2007df5cb20e2b8444ff3dfaa2a929335f432a9be2e7"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SendEvmTransactionResponse {
        ///The hash of the transaction, as a 0x-prefixed hex string.
        #[serde(rename = "transactionHash")]
        pub transaction_hash: ::std::string::String,
    }
    impl ::std::convert::From<&SendEvmTransactionResponse> for SendEvmTransactionResponse {
        fn from(value: &SendEvmTransactionResponse) -> Self {
            value.clone()
        }
    }
    impl SendEvmTransactionResponse {
        pub fn builder() -> builder::SendEvmTransactionResponse {
            Default::default()
        }
    }
    ///`SendEvmTransactionRule`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SendEvmTransactionRule",
    ///  "required": [
    ///    "action",
    ///    "criteria",
    ///    "operation"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///      "examples": [
    ///        "accept"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "reject",
    ///        "accept"
    ///      ]
    ///    },
    ///    "criteria": {
    ///      "$ref": "#/components/schemas/SendEvmTransactionCriteria"
    ///    },
    ///    "operation": {
    ///      "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///      "examples": [
    ///        "sendEvmTransaction"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "sendEvmTransaction"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SendEvmTransactionRule {
        ///Whether matching the rule will cause the request to be rejected or accepted.
        pub action: SendEvmTransactionRuleAction,
        pub criteria: SendEvmTransactionCriteria,
        ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
        pub operation: SendEvmTransactionRuleOperation,
    }
    impl ::std::convert::From<&SendEvmTransactionRule> for SendEvmTransactionRule {
        fn from(value: &SendEvmTransactionRule) -> Self {
            value.clone()
        }
    }
    impl SendEvmTransactionRule {
        pub fn builder() -> builder::SendEvmTransactionRule {
            Default::default()
        }
    }
    ///Whether matching the rule will cause the request to be rejected or accepted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///  "examples": [
    ///    "accept"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "reject",
    ///    "accept"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SendEvmTransactionRuleAction {
        #[serde(rename = "reject")]
        Reject,
        #[serde(rename = "accept")]
        Accept,
    }
    impl ::std::convert::From<&Self> for SendEvmTransactionRuleAction {
        fn from(value: &SendEvmTransactionRuleAction) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SendEvmTransactionRuleAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Reject => f.write_str("reject"),
                Self::Accept => f.write_str("accept"),
            }
        }
    }
    impl ::std::str::FromStr for SendEvmTransactionRuleAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "reject" => Ok(Self::Reject),
                "accept" => Ok(Self::Accept),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SendEvmTransactionRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SendEvmTransactionRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SendEvmTransactionRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///  "examples": [
    ///    "sendEvmTransaction"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "sendEvmTransaction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SendEvmTransactionRuleOperation {
        #[serde(rename = "sendEvmTransaction")]
        SendEvmTransaction,
    }
    impl ::std::convert::From<&Self> for SendEvmTransactionRuleOperation {
        fn from(value: &SendEvmTransactionRuleOperation) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SendEvmTransactionRuleOperation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SendEvmTransaction => f.write_str("sendEvmTransaction"),
            }
        }
    }
    impl ::std::str::FromStr for SendEvmTransactionRuleOperation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sendEvmTransaction" => Ok(Self::SendEvmTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SendEvmTransactionRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SendEvmTransactionRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SendEvmTransactionRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`SendEvmTransactionXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SendEvmTransactionXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for SendEvmTransactionXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SendEvmTransactionXIdempotencyKey> for ::std::string::String {
        fn from(value: SendEvmTransactionXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SendEvmTransactionXIdempotencyKey>
        for SendEvmTransactionXIdempotencyKey
    {
        fn from(value: &SendEvmTransactionXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SendEvmTransactionXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SendEvmTransactionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SendEvmTransactionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SendEvmTransactionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SendEvmTransactionXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///A schema for specifying criteria for the SendSolTransaction operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A schema for specifying criteria for the SendSolTransaction operation.",
    ///  "examples": [
    ///    [
    ///      {
    ///        "addresses": [
    ///          "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///        ],
    ///        "operator": "in",
    ///        "type": "solAddress"
    ///      },
    ///      {
    ///        "operator": "<=",
    ///        "solValue": "1000000000000000000",
    ///        "type": "solValue"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "array",
    ///  "items": {
    ///    "oneOf": [
    ///      {
    ///        "$ref": "#/components/schemas/SolAddressCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/SolValueCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/SplAddressCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/SplValueCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/MintAddressCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/SolDataCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/ProgramIdCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/SolNetworkCriterion"
    ///      }
    ///    ]
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SendSolTransactionCriteria(pub ::std::vec::Vec<SendSolTransactionCriteriaItem>);
    impl ::std::ops::Deref for SendSolTransactionCriteria {
        type Target = ::std::vec::Vec<SendSolTransactionCriteriaItem>;
        fn deref(&self) -> &::std::vec::Vec<SendSolTransactionCriteriaItem> {
            &self.0
        }
    }
    impl ::std::convert::From<SendSolTransactionCriteria>
        for ::std::vec::Vec<SendSolTransactionCriteriaItem>
    {
        fn from(value: SendSolTransactionCriteria) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SendSolTransactionCriteria> for SendSolTransactionCriteria {
        fn from(value: &SendSolTransactionCriteria) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::vec::Vec<SendSolTransactionCriteriaItem>>
        for SendSolTransactionCriteria
    {
        fn from(value: ::std::vec::Vec<SendSolTransactionCriteriaItem>) -> Self {
            Self(value)
        }
    }
    ///`SendSolTransactionCriteriaItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SolAddressCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SolValueCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SplAddressCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SplValueCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MintAddressCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SolDataCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgramIdCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SolNetworkCriterion"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum SendSolTransactionCriteriaItem {
        SolAddressCriterion(SolAddressCriterion),
        SolValueCriterion(SolValueCriterion),
        SplAddressCriterion(SplAddressCriterion),
        SplValueCriterion(SplValueCriterion),
        MintAddressCriterion(MintAddressCriterion),
        SolDataCriterion(SolDataCriterion),
        ProgramIdCriterion(ProgramIdCriterion),
        SolNetworkCriterion(SolNetworkCriterion),
    }
    impl ::std::convert::From<&Self> for SendSolTransactionCriteriaItem {
        fn from(value: &SendSolTransactionCriteriaItem) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<SolAddressCriterion> for SendSolTransactionCriteriaItem {
        fn from(value: SolAddressCriterion) -> Self {
            Self::SolAddressCriterion(value)
        }
    }
    impl ::std::convert::From<SolValueCriterion> for SendSolTransactionCriteriaItem {
        fn from(value: SolValueCriterion) -> Self {
            Self::SolValueCriterion(value)
        }
    }
    impl ::std::convert::From<SplAddressCriterion> for SendSolTransactionCriteriaItem {
        fn from(value: SplAddressCriterion) -> Self {
            Self::SplAddressCriterion(value)
        }
    }
    impl ::std::convert::From<SplValueCriterion> for SendSolTransactionCriteriaItem {
        fn from(value: SplValueCriterion) -> Self {
            Self::SplValueCriterion(value)
        }
    }
    impl ::std::convert::From<MintAddressCriterion> for SendSolTransactionCriteriaItem {
        fn from(value: MintAddressCriterion) -> Self {
            Self::MintAddressCriterion(value)
        }
    }
    impl ::std::convert::From<SolDataCriterion> for SendSolTransactionCriteriaItem {
        fn from(value: SolDataCriterion) -> Self {
            Self::SolDataCriterion(value)
        }
    }
    impl ::std::convert::From<ProgramIdCriterion> for SendSolTransactionCriteriaItem {
        fn from(value: ProgramIdCriterion) -> Self {
            Self::ProgramIdCriterion(value)
        }
    }
    impl ::std::convert::From<SolNetworkCriterion> for SendSolTransactionCriteriaItem {
        fn from(value: SolNetworkCriterion) -> Self {
            Self::SolNetworkCriterion(value)
        }
    }
    ///`SendSolTransactionRule`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SendSolTransactionRule",
    ///  "required": [
    ///    "action",
    ///    "criteria",
    ///    "operation"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///      "examples": [
    ///        "accept"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "reject",
    ///        "accept"
    ///      ]
    ///    },
    ///    "criteria": {
    ///      "$ref": "#/components/schemas/SendSolTransactionCriteria"
    ///    },
    ///    "operation": {
    ///      "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///      "examples": [
    ///        "sendSolTransaction"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "sendSolTransaction"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SendSolTransactionRule {
        ///Whether matching the rule will cause the request to be rejected or accepted.
        pub action: SendSolTransactionRuleAction,
        pub criteria: SendSolTransactionCriteria,
        ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
        pub operation: SendSolTransactionRuleOperation,
    }
    impl ::std::convert::From<&SendSolTransactionRule> for SendSolTransactionRule {
        fn from(value: &SendSolTransactionRule) -> Self {
            value.clone()
        }
    }
    impl SendSolTransactionRule {
        pub fn builder() -> builder::SendSolTransactionRule {
            Default::default()
        }
    }
    ///Whether matching the rule will cause the request to be rejected or accepted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///  "examples": [
    ///    "accept"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "reject",
    ///    "accept"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SendSolTransactionRuleAction {
        #[serde(rename = "reject")]
        Reject,
        #[serde(rename = "accept")]
        Accept,
    }
    impl ::std::convert::From<&Self> for SendSolTransactionRuleAction {
        fn from(value: &SendSolTransactionRuleAction) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SendSolTransactionRuleAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Reject => f.write_str("reject"),
                Self::Accept => f.write_str("accept"),
            }
        }
    }
    impl ::std::str::FromStr for SendSolTransactionRuleAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "reject" => Ok(Self::Reject),
                "accept" => Ok(Self::Accept),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SendSolTransactionRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SendSolTransactionRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SendSolTransactionRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///  "examples": [
    ///    "sendSolTransaction"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "sendSolTransaction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SendSolTransactionRuleOperation {
        #[serde(rename = "sendSolTransaction")]
        SendSolTransaction,
    }
    impl ::std::convert::From<&Self> for SendSolTransactionRuleOperation {
        fn from(value: &SendSolTransactionRuleOperation) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SendSolTransactionRuleOperation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SendSolTransaction => f.write_str("sendSolTransaction"),
            }
        }
    }
    impl ::std::str::FromStr for SendSolTransactionRuleOperation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sendSolTransaction" => Ok(Self::SendSolTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SendSolTransactionRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SendSolTransactionRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SendSolTransactionRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`SendSolanaTransactionBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "network",
    ///    "transaction"
    ///  ],
    ///  "properties": {
    ///    "network": {
    ///      "description": "The Solana network to send the transaction to.",
    ///      "examples": [
    ///        "solana-devnet"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "solana",
    ///        "solana-devnet"
    ///      ]
    ///    },
    ///    "transaction": {
    ///      "description": "The base64 encoded transaction to sign and send. This transaction can contain multiple instructions for native Solana batching.",
    ///      "examples": [
    ///        "AQABAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAQECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8CBgMBAQAAAAIBAwQAAAAABgIAAAAAAAYDBQEBAAAGBAgAAAAABgUAAAAA6AMAAAAAAAAGBgUBAQEBBgcEAQAAAAYICgMBAQIDBgkCBgAAAAYKAwABAQEGCwMGAQEBBgwDAAABAQAAAAA="
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SendSolanaTransactionBody {
        ///The Solana network to send the transaction to.
        pub network: SendSolanaTransactionBodyNetwork,
        ///The base64 encoded transaction to sign and send. This transaction can contain multiple instructions for native Solana batching.
        pub transaction: ::std::string::String,
    }
    impl ::std::convert::From<&SendSolanaTransactionBody> for SendSolanaTransactionBody {
        fn from(value: &SendSolanaTransactionBody) -> Self {
            value.clone()
        }
    }
    impl SendSolanaTransactionBody {
        pub fn builder() -> builder::SendSolanaTransactionBody {
            Default::default()
        }
    }
    ///The Solana network to send the transaction to.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Solana network to send the transaction to.",
    ///  "examples": [
    ///    "solana-devnet"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "solana",
    ///    "solana-devnet"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SendSolanaTransactionBodyNetwork {
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "solana-devnet")]
        SolanaDevnet,
    }
    impl ::std::convert::From<&Self> for SendSolanaTransactionBodyNetwork {
        fn from(value: &SendSolanaTransactionBodyNetwork) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SendSolanaTransactionBodyNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
                Self::SolanaDevnet => f.write_str("solana-devnet"),
            }
        }
    }
    impl ::std::str::FromStr for SendSolanaTransactionBodyNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                "solana-devnet" => Ok(Self::SolanaDevnet),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SendSolanaTransactionBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SendSolanaTransactionBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SendSolanaTransactionBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`SendSolanaTransactionResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "transactionSignature"
    ///  ],
    ///  "properties": {
    ///    "transactionSignature": {
    ///      "description": "The base58 encoded transaction signature.",
    ///      "examples": [
    ///        "5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SendSolanaTransactionResponse {
        ///The base58 encoded transaction signature.
        #[serde(rename = "transactionSignature")]
        pub transaction_signature: ::std::string::String,
    }
    impl ::std::convert::From<&SendSolanaTransactionResponse> for SendSolanaTransactionResponse {
        fn from(value: &SendSolanaTransactionResponse) -> Self {
            value.clone()
        }
    }
    impl SendSolanaTransactionResponse {
        pub fn builder() -> builder::SendSolanaTransactionResponse {
            Default::default()
        }
    }
    ///`SendSolanaTransactionXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SendSolanaTransactionXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for SendSolanaTransactionXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SendSolanaTransactionXIdempotencyKey> for ::std::string::String {
        fn from(value: SendSolanaTransactionXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SendSolanaTransactionXIdempotencyKey>
        for SendSolanaTransactionXIdempotencyKey
    {
        fn from(value: &SendSolanaTransactionXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SendSolanaTransactionXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SendSolanaTransactionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SendSolanaTransactionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SendSolanaTransactionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SendSolanaTransactionXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SendUserOperationAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SendUserOperationAddress(::std::string::String);
    impl ::std::ops::Deref for SendUserOperationAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SendUserOperationAddress> for ::std::string::String {
        fn from(value: SendUserOperationAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SendUserOperationAddress> for SendUserOperationAddress {
        fn from(value: &SendUserOperationAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SendUserOperationAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SendUserOperationAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SendUserOperationAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SendUserOperationAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SendUserOperationAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SendUserOperationBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "signature"
    ///  ],
    ///  "properties": {
    ///    "signature": {
    ///      "description": "The hex-encoded signature of the user operation. This should be a 65-byte signature consisting of the `r`, `s`, and `v` values of the ECDSA signature. Note that the `v` value should conform to the `personal_sign` standard, which means it should be 27 or 28.",
    ///      "examples": [
    ///        "0x1b0c9cf8cd4554c6c6d9e7311e88f1be075d7f25b418a044f4bf2c0a42a93e212ad0a8b54de9e0b5f7e3812de3f2c6cc79aa8c3e1c02e7ad14b4a8f42012c2c01b"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SendUserOperationBody {
        ///The hex-encoded signature of the user operation. This should be a 65-byte signature consisting of the `r`, `s`, and `v` values of the ECDSA signature. Note that the `v` value should conform to the `personal_sign` standard, which means it should be 27 or 28.
        pub signature: ::std::string::String,
    }
    impl ::std::convert::From<&SendUserOperationBody> for SendUserOperationBody {
        fn from(value: &SendUserOperationBody) -> Self {
            value.clone()
        }
    }
    impl SendUserOperationBody {
        pub fn builder() -> builder::SendUserOperationBody {
            Default::default()
        }
    }
    ///A schema for specifying criteria for the SendUserOperation operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A schema for specifying criteria for the SendUserOperation operation.",
    ///  "examples": [
    ///    [
    ///      {
    ///        "ethValue": "1000000",
    ///        "operator": ">=",
    ///        "type": "ethValue"
    ///      },
    ///      {
    ///        "addresses": [
    ///          "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///        ],
    ///        "operator": "in",
    ///        "type": "evmAddress"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "array",
    ///  "items": {
    ///    "oneOf": [
    ///      {
    ///        "$ref": "#/components/schemas/EthValueCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/EvmAddressCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/EvmDataCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/NetUSDChangeCriterion"
    ///      }
    ///    ]
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SendUserOperationCriteria(pub ::std::vec::Vec<SendUserOperationCriteriaItem>);
    impl ::std::ops::Deref for SendUserOperationCriteria {
        type Target = ::std::vec::Vec<SendUserOperationCriteriaItem>;
        fn deref(&self) -> &::std::vec::Vec<SendUserOperationCriteriaItem> {
            &self.0
        }
    }
    impl ::std::convert::From<SendUserOperationCriteria>
        for ::std::vec::Vec<SendUserOperationCriteriaItem>
    {
        fn from(value: SendUserOperationCriteria) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SendUserOperationCriteria> for SendUserOperationCriteria {
        fn from(value: &SendUserOperationCriteria) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::vec::Vec<SendUserOperationCriteriaItem>>
        for SendUserOperationCriteria
    {
        fn from(value: ::std::vec::Vec<SendUserOperationCriteriaItem>) -> Self {
            Self(value)
        }
    }
    ///`SendUserOperationCriteriaItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/EthValueCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EvmAddressCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EvmDataCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NetUSDChangeCriterion"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum SendUserOperationCriteriaItem {
        EthValueCriterion(EthValueCriterion),
        EvmAddressCriterion(EvmAddressCriterion),
        EvmDataCriterion(EvmDataCriterion),
        NetUsdChangeCriterion(NetUsdChangeCriterion),
    }
    impl ::std::convert::From<&Self> for SendUserOperationCriteriaItem {
        fn from(value: &SendUserOperationCriteriaItem) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<EthValueCriterion> for SendUserOperationCriteriaItem {
        fn from(value: EthValueCriterion) -> Self {
            Self::EthValueCriterion(value)
        }
    }
    impl ::std::convert::From<EvmAddressCriterion> for SendUserOperationCriteriaItem {
        fn from(value: EvmAddressCriterion) -> Self {
            Self::EvmAddressCriterion(value)
        }
    }
    impl ::std::convert::From<EvmDataCriterion> for SendUserOperationCriteriaItem {
        fn from(value: EvmDataCriterion) -> Self {
            Self::EvmDataCriterion(value)
        }
    }
    impl ::std::convert::From<NetUsdChangeCriterion> for SendUserOperationCriteriaItem {
        fn from(value: NetUsdChangeCriterion) -> Self {
            Self::NetUsdChangeCriterion(value)
        }
    }
    ///`SendUserOperationRule`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SendUserOperationRule",
    ///  "required": [
    ///    "action",
    ///    "criteria",
    ///    "operation"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///      "examples": [
    ///        "accept"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "reject",
    ///        "accept"
    ///      ]
    ///    },
    ///    "criteria": {
    ///      "$ref": "#/components/schemas/SendUserOperationCriteria"
    ///    },
    ///    "operation": {
    ///      "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///      "examples": [
    ///        "sendUserOperation"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "sendUserOperation"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SendUserOperationRule {
        ///Whether matching the rule will cause the request to be rejected or accepted.
        pub action: SendUserOperationRuleAction,
        pub criteria: SendUserOperationCriteria,
        ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
        pub operation: SendUserOperationRuleOperation,
    }
    impl ::std::convert::From<&SendUserOperationRule> for SendUserOperationRule {
        fn from(value: &SendUserOperationRule) -> Self {
            value.clone()
        }
    }
    impl SendUserOperationRule {
        pub fn builder() -> builder::SendUserOperationRule {
            Default::default()
        }
    }
    ///Whether matching the rule will cause the request to be rejected or accepted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///  "examples": [
    ///    "accept"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "reject",
    ///    "accept"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SendUserOperationRuleAction {
        #[serde(rename = "reject")]
        Reject,
        #[serde(rename = "accept")]
        Accept,
    }
    impl ::std::convert::From<&Self> for SendUserOperationRuleAction {
        fn from(value: &SendUserOperationRuleAction) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SendUserOperationRuleAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Reject => f.write_str("reject"),
                Self::Accept => f.write_str("accept"),
            }
        }
    }
    impl ::std::str::FromStr for SendUserOperationRuleAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "reject" => Ok(Self::Reject),
                "accept" => Ok(Self::Accept),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SendUserOperationRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SendUserOperationRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SendUserOperationRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///  "examples": [
    ///    "sendUserOperation"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "sendUserOperation"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SendUserOperationRuleOperation {
        #[serde(rename = "sendUserOperation")]
        SendUserOperation,
    }
    impl ::std::convert::From<&Self> for SendUserOperationRuleOperation {
        fn from(value: &SendUserOperationRuleOperation) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SendUserOperationRuleOperation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SendUserOperation => f.write_str("sendUserOperation"),
            }
        }
    }
    impl ::std::str::FromStr for SendUserOperationRuleOperation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sendUserOperation" => Ok(Self::SendUserOperation),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SendUserOperationRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SendUserOperationRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SendUserOperationRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`SendUserOperationUserOpHash`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{64}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SendUserOperationUserOpHash(::std::string::String);
    impl ::std::ops::Deref for SendUserOperationUserOpHash {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SendUserOperationUserOpHash> for ::std::string::String {
        fn from(value: SendUserOperationUserOpHash) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SendUserOperationUserOpHash> for SendUserOperationUserOpHash {
        fn from(value: &SendUserOperationUserOpHash) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SendUserOperationUserOpHash {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{64}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{64}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SendUserOperationUserOpHash {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SendUserOperationUserOpHash {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SendUserOperationUserOpHash {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SendUserOperationUserOpHash {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SettleX402PaymentBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "paymentPayload",
    ///    "paymentRequirements",
    ///    "x402Version"
    ///  ],
    ///  "properties": {
    ///    "paymentPayload": {
    ///      "$ref": "#/components/schemas/x402PaymentPayload"
    ///    },
    ///    "paymentRequirements": {
    ///      "$ref": "#/components/schemas/x402PaymentRequirements"
    ///    },
    ///    "x402Version": {
    ///      "$ref": "#/components/schemas/X402Version"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SettleX402PaymentBody {
        #[serde(rename = "paymentPayload")]
        pub payment_payload: X402PaymentPayload,
        #[serde(rename = "paymentRequirements")]
        pub payment_requirements: X402PaymentRequirements,
        #[serde(rename = "x402Version")]
        pub x402_version: X402Version,
    }
    impl ::std::convert::From<&SettleX402PaymentBody> for SettleX402PaymentBody {
        fn from(value: &SettleX402PaymentBody) -> Self {
            value.clone()
        }
    }
    impl SettleX402PaymentBody {
        pub fn builder() -> builder::SettleX402PaymentBody {
            Default::default()
        }
    }
    ///`SettleX402PaymentResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "network",
    ///    "payer",
    ///    "success",
    ///    "transaction"
    ///  ],
    ///  "properties": {
    ///    "errorReason": {
    ///      "$ref": "#/components/schemas/x402SettleErrorReason"
    ///    },
    ///    "network": {
    ///      "description": "The network where the settlement occurred.",
    ///      "examples": [
    ///        "base"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "payer": {
    ///      "description": "The onchain address of the client that is paying for the resource.\n\nFor EVM networks, the payer will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, the payer will be a base58-encoded Solana address.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$"
    ///    },
    ///    "success": {
    ///      "description": "Indicates whether the payment settlement is successful.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "transaction": {
    ///      "description": "The transaction of the settlement.\nFor EVM networks, the transaction will be a 0x-prefixed, EVM transaction hash.\nFor Solana-based networks, the transaction will be a base58-encoded Solana signature.",
    ///      "examples": [
    ///        "0x89c91c789e57059b17285e7ba1716a1f5ff4c5dace0ea5a5135f26158d0421b9"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^(0x[a-fA-F0-9]{64}|[1-9A-HJ-NP-Za-km-z]{87,88})$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SettleX402PaymentResponse {
        #[serde(
            rename = "errorReason",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub error_reason: ::std::option::Option<X402SettleErrorReason>,
        ///The network where the settlement occurred.
        pub network: ::std::string::String,
        /**The onchain address of the client that is paying for the resource.

        For EVM networks, the payer will be a 0x-prefixed, checksum EVM address.

        For Solana-based networks, the payer will be a base58-encoded Solana address.*/
        pub payer: SettleX402PaymentResponsePayer,
        ///Indicates whether the payment settlement is successful.
        pub success: bool,
        /**The transaction of the settlement.
        For EVM networks, the transaction will be a 0x-prefixed, EVM transaction hash.
        For Solana-based networks, the transaction will be a base58-encoded Solana signature.*/
        pub transaction: SettleX402PaymentResponseTransaction,
    }
    impl ::std::convert::From<&SettleX402PaymentResponse> for SettleX402PaymentResponse {
        fn from(value: &SettleX402PaymentResponse) -> Self {
            value.clone()
        }
    }
    impl SettleX402PaymentResponse {
        pub fn builder() -> builder::SettleX402PaymentResponse {
            Default::default()
        }
    }
    /**The onchain address of the client that is paying for the resource.

    For EVM networks, the payer will be a 0x-prefixed, checksum EVM address.

    For Solana-based networks, the payer will be a base58-encoded Solana address.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The onchain address of the client that is paying for the resource.\n\nFor EVM networks, the payer will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, the payer will be a base58-encoded Solana address.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SettleX402PaymentResponsePayer(::std::string::String);
    impl ::std::ops::Deref for SettleX402PaymentResponsePayer {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SettleX402PaymentResponsePayer> for ::std::string::String {
        fn from(value: SettleX402PaymentResponsePayer) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SettleX402PaymentResponsePayer> for SettleX402PaymentResponsePayer {
        fn from(value: &SettleX402PaymentResponsePayer) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SettleX402PaymentResponsePayer {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$")
                        .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SettleX402PaymentResponsePayer {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SettleX402PaymentResponsePayer {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SettleX402PaymentResponsePayer {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SettleX402PaymentResponsePayer {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    /**The transaction of the settlement.
    For EVM networks, the transaction will be a 0x-prefixed, EVM transaction hash.
    For Solana-based networks, the transaction will be a base58-encoded Solana signature.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The transaction of the settlement.\nFor EVM networks, the transaction will be a 0x-prefixed, EVM transaction hash.\nFor Solana-based networks, the transaction will be a base58-encoded Solana signature.",
    ///  "examples": [
    ///    "0x89c91c789e57059b17285e7ba1716a1f5ff4c5dace0ea5a5135f26158d0421b9"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0x[a-fA-F0-9]{64}|[1-9A-HJ-NP-Za-km-z]{87,88})$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SettleX402PaymentResponseTransaction(::std::string::String);
    impl ::std::ops::Deref for SettleX402PaymentResponseTransaction {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SettleX402PaymentResponseTransaction> for ::std::string::String {
        fn from(value: SettleX402PaymentResponseTransaction) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SettleX402PaymentResponseTransaction>
        for SettleX402PaymentResponseTransaction
    {
        fn from(value: &SettleX402PaymentResponseTransaction) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SettleX402PaymentResponseTransaction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^(0x[a-fA-F0-9]{64}|[1-9A-HJ-NP-Za-km-z]{87,88})$")
                        .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^(0x[a-fA-F0-9]{64}|[1-9A-HJ-NP-Za-km-z]{87,88})$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SettleX402PaymentResponseTransaction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SettleX402PaymentResponseTransaction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SettleX402PaymentResponseTransaction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SettleX402PaymentResponseTransaction {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SignEvmHashAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SignEvmHashAddress(::std::string::String);
    impl ::std::ops::Deref for SignEvmHashAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SignEvmHashAddress> for ::std::string::String {
        fn from(value: SignEvmHashAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignEvmHashAddress> for SignEvmHashAddress {
        fn from(value: &SignEvmHashAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SignEvmHashAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmHashAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmHashAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmHashAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SignEvmHashAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SignEvmHashBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "hash"
    ///  ],
    ///  "properties": {
    ///    "hash": {
    ///      "description": "The arbitrary 32 byte hash to sign.",
    ///      "examples": [
    ///        "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmHashBody {
        ///The arbitrary 32 byte hash to sign.
        pub hash: ::std::string::String,
    }
    impl ::std::convert::From<&SignEvmHashBody> for SignEvmHashBody {
        fn from(value: &SignEvmHashBody) -> Self {
            value.clone()
        }
    }
    impl SignEvmHashBody {
        pub fn builder() -> builder::SignEvmHashBody {
            Default::default()
        }
    }
    ///`SignEvmHashResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "signature"
    ///  ],
    ///  "properties": {
    ///    "signature": {
    ///      "description": "The signature of the hash, as a 0x-prefixed hex string.",
    ///      "examples": [
    ///        "0x1b0c9cf8cd4554c6c6d9e7311e88f1be075d7f25b418a044f4bf2c0a42a93e212ad0a8b54de9e0b5f7e3812de3f2c6cc79aa8c3e1c02e7ad14b4a8f42012c2c01b"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmHashResponse {
        ///The signature of the hash, as a 0x-prefixed hex string.
        pub signature: ::std::string::String,
    }
    impl ::std::convert::From<&SignEvmHashResponse> for SignEvmHashResponse {
        fn from(value: &SignEvmHashResponse) -> Self {
            value.clone()
        }
    }
    impl SignEvmHashResponse {
        pub fn builder() -> builder::SignEvmHashResponse {
            Default::default()
        }
    }
    ///`SignEvmHashRule`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SignEvmHashRule",
    ///  "required": [
    ///    "action",
    ///    "operation"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "Whether any attempts to sign a hash will be accepted or rejected. This rule does not accept any criteria.",
    ///      "examples": [
    ///        "accept"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "reject",
    ///        "accept"
    ///      ]
    ///    },
    ///    "operation": {
    ///      "description": "The operation to which the rule applies.",
    ///      "examples": [
    ///        "signEvmHash"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "signEvmHash"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmHashRule {
        ///Whether any attempts to sign a hash will be accepted or rejected. This rule does not accept any criteria.
        pub action: SignEvmHashRuleAction,
        ///The operation to which the rule applies.
        pub operation: SignEvmHashRuleOperation,
    }
    impl ::std::convert::From<&SignEvmHashRule> for SignEvmHashRule {
        fn from(value: &SignEvmHashRule) -> Self {
            value.clone()
        }
    }
    impl SignEvmHashRule {
        pub fn builder() -> builder::SignEvmHashRule {
            Default::default()
        }
    }
    ///Whether any attempts to sign a hash will be accepted or rejected. This rule does not accept any criteria.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Whether any attempts to sign a hash will be accepted or rejected. This rule does not accept any criteria.",
    ///  "examples": [
    ///    "accept"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "reject",
    ///    "accept"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignEvmHashRuleAction {
        #[serde(rename = "reject")]
        Reject,
        #[serde(rename = "accept")]
        Accept,
    }
    impl ::std::convert::From<&Self> for SignEvmHashRuleAction {
        fn from(value: &SignEvmHashRuleAction) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignEvmHashRuleAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Reject => f.write_str("reject"),
                Self::Accept => f.write_str("accept"),
            }
        }
    }
    impl ::std::str::FromStr for SignEvmHashRuleAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "reject" => Ok(Self::Reject),
                "accept" => Ok(Self::Accept),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmHashRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmHashRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmHashRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The operation to which the rule applies.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operation to which the rule applies.",
    ///  "examples": [
    ///    "signEvmHash"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "signEvmHash"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignEvmHashRuleOperation {
        #[serde(rename = "signEvmHash")]
        SignEvmHash,
    }
    impl ::std::convert::From<&Self> for SignEvmHashRuleOperation {
        fn from(value: &SignEvmHashRuleOperation) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignEvmHashRuleOperation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignEvmHash => f.write_str("signEvmHash"),
            }
        }
    }
    impl ::std::str::FromStr for SignEvmHashRuleOperation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signEvmHash" => Ok(Self::SignEvmHash),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmHashRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmHashRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmHashRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`SignEvmHashXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SignEvmHashXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for SignEvmHashXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SignEvmHashXIdempotencyKey> for ::std::string::String {
        fn from(value: SignEvmHashXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignEvmHashXIdempotencyKey> for SignEvmHashXIdempotencyKey {
        fn from(value: &SignEvmHashXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SignEvmHashXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmHashXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmHashXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmHashXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SignEvmHashXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SignEvmMessageAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SignEvmMessageAddress(::std::string::String);
    impl ::std::ops::Deref for SignEvmMessageAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SignEvmMessageAddress> for ::std::string::String {
        fn from(value: SignEvmMessageAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignEvmMessageAddress> for SignEvmMessageAddress {
        fn from(value: &SignEvmMessageAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SignEvmMessageAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmMessageAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmMessageAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmMessageAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SignEvmMessageAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SignEvmMessageBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "message"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "The message to sign.",
    ///      "examples": [
    ///        "Hello, world!"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmMessageBody {
        ///The message to sign.
        pub message: ::std::string::String,
    }
    impl ::std::convert::From<&SignEvmMessageBody> for SignEvmMessageBody {
        fn from(value: &SignEvmMessageBody) -> Self {
            value.clone()
        }
    }
    impl SignEvmMessageBody {
        pub fn builder() -> builder::SignEvmMessageBody {
            Default::default()
        }
    }
    ///A schema for specifying the rejection criteria for the SignEvmMessage operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A schema for specifying the rejection criteria for the SignEvmMessage operation.",
    ///  "examples": [
    ///    [
    ///      {
    ///        "match": "^hello ([a-z]+)$",
    ///        "type": "evmMessage"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "array",
    ///  "items": {
    ///    "oneOf": [
    ///      {
    ///        "$ref": "#/components/schemas/EvmMessageCriterion"
    ///      }
    ///    ]
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SignEvmMessageCriteria(pub ::std::vec::Vec<EvmMessageCriterion>);
    impl ::std::ops::Deref for SignEvmMessageCriteria {
        type Target = ::std::vec::Vec<EvmMessageCriterion>;
        fn deref(&self) -> &::std::vec::Vec<EvmMessageCriterion> {
            &self.0
        }
    }
    impl ::std::convert::From<SignEvmMessageCriteria> for ::std::vec::Vec<EvmMessageCriterion> {
        fn from(value: SignEvmMessageCriteria) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignEvmMessageCriteria> for SignEvmMessageCriteria {
        fn from(value: &SignEvmMessageCriteria) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::vec::Vec<EvmMessageCriterion>> for SignEvmMessageCriteria {
        fn from(value: ::std::vec::Vec<EvmMessageCriterion>) -> Self {
            Self(value)
        }
    }
    ///`SignEvmMessageResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "signature"
    ///  ],
    ///  "properties": {
    ///    "signature": {
    ///      "description": "The signature of the message, as a 0x-prefixed hex string.",
    ///      "examples": [
    ///        "0x1b0c9cf8cd4554c6c6d9e7311e88f1be075d7f25b418a044f4bf2c0a42a93e212ad0a8b54de9e0b5f7e3812de3f2c6cc79aa8c3e1c02e7ad14b4a8f42012c2c01b"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmMessageResponse {
        ///The signature of the message, as a 0x-prefixed hex string.
        pub signature: ::std::string::String,
    }
    impl ::std::convert::From<&SignEvmMessageResponse> for SignEvmMessageResponse {
        fn from(value: &SignEvmMessageResponse) -> Self {
            value.clone()
        }
    }
    impl SignEvmMessageResponse {
        pub fn builder() -> builder::SignEvmMessageResponse {
            Default::default()
        }
    }
    ///`SignEvmMessageRule`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SignEvmMessageRule",
    ///  "required": [
    ///    "action",
    ///    "criteria",
    ///    "operation"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///      "examples": [
    ///        "accept"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "reject",
    ///        "accept"
    ///      ]
    ///    },
    ///    "criteria": {
    ///      "$ref": "#/components/schemas/SignEvmMessageCriteria"
    ///    },
    ///    "operation": {
    ///      "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///      "examples": [
    ///        "signEvmMessage"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "signEvmMessage"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmMessageRule {
        ///Whether matching the rule will cause the request to be rejected or accepted.
        pub action: SignEvmMessageRuleAction,
        pub criteria: SignEvmMessageCriteria,
        ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
        pub operation: SignEvmMessageRuleOperation,
    }
    impl ::std::convert::From<&SignEvmMessageRule> for SignEvmMessageRule {
        fn from(value: &SignEvmMessageRule) -> Self {
            value.clone()
        }
    }
    impl SignEvmMessageRule {
        pub fn builder() -> builder::SignEvmMessageRule {
            Default::default()
        }
    }
    ///Whether matching the rule will cause the request to be rejected or accepted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///  "examples": [
    ///    "accept"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "reject",
    ///    "accept"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignEvmMessageRuleAction {
        #[serde(rename = "reject")]
        Reject,
        #[serde(rename = "accept")]
        Accept,
    }
    impl ::std::convert::From<&Self> for SignEvmMessageRuleAction {
        fn from(value: &SignEvmMessageRuleAction) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignEvmMessageRuleAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Reject => f.write_str("reject"),
                Self::Accept => f.write_str("accept"),
            }
        }
    }
    impl ::std::str::FromStr for SignEvmMessageRuleAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "reject" => Ok(Self::Reject),
                "accept" => Ok(Self::Accept),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmMessageRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmMessageRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmMessageRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///  "examples": [
    ///    "signEvmMessage"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "signEvmMessage"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignEvmMessageRuleOperation {
        #[serde(rename = "signEvmMessage")]
        SignEvmMessage,
    }
    impl ::std::convert::From<&Self> for SignEvmMessageRuleOperation {
        fn from(value: &SignEvmMessageRuleOperation) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignEvmMessageRuleOperation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignEvmMessage => f.write_str("signEvmMessage"),
            }
        }
    }
    impl ::std::str::FromStr for SignEvmMessageRuleOperation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signEvmMessage" => Ok(Self::SignEvmMessage),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmMessageRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmMessageRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmMessageRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`SignEvmMessageXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SignEvmMessageXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for SignEvmMessageXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SignEvmMessageXIdempotencyKey> for ::std::string::String {
        fn from(value: SignEvmMessageXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignEvmMessageXIdempotencyKey> for SignEvmMessageXIdempotencyKey {
        fn from(value: &SignEvmMessageXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SignEvmMessageXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmMessageXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmMessageXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmMessageXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SignEvmMessageXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SignEvmTransactionAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SignEvmTransactionAddress(::std::string::String);
    impl ::std::ops::Deref for SignEvmTransactionAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SignEvmTransactionAddress> for ::std::string::String {
        fn from(value: SignEvmTransactionAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignEvmTransactionAddress> for SignEvmTransactionAddress {
        fn from(value: &SignEvmTransactionAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SignEvmTransactionAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmTransactionAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmTransactionAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmTransactionAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SignEvmTransactionAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SignEvmTransactionBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "transaction"
    ///  ],
    ///  "properties": {
    ///    "transaction": {
    ///      "description": "The RLP-encoded transaction to sign, as a 0x-prefixed hex string.",
    ///      "examples": [
    ///        "0xf86b098505d21dba00830334509431415daf58e2c6b7323b4c58712fd92952145da79018080"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmTransactionBody {
        ///The RLP-encoded transaction to sign, as a 0x-prefixed hex string.
        pub transaction: ::std::string::String,
    }
    impl ::std::convert::From<&SignEvmTransactionBody> for SignEvmTransactionBody {
        fn from(value: &SignEvmTransactionBody) -> Self {
            value.clone()
        }
    }
    impl SignEvmTransactionBody {
        pub fn builder() -> builder::SignEvmTransactionBody {
            Default::default()
        }
    }
    ///A schema for specifying criteria for the SignEvmTransaction operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A schema for specifying criteria for the SignEvmTransaction operation.",
    ///  "examples": [
    ///    [
    ///      {
    ///        "ethValue": "1000000",
    ///        "operator": ">=",
    ///        "type": "ethValue"
    ///      },
    ///      {
    ///        "addresses": [
    ///          "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///        ],
    ///        "operator": "in",
    ///        "type": "evmAddress"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "array",
    ///  "items": {
    ///    "oneOf": [
    ///      {
    ///        "$ref": "#/components/schemas/EthValueCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/EvmAddressCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/EvmDataCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/NetUSDChangeCriterion"
    ///      }
    ///    ]
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SignEvmTransactionCriteria(pub ::std::vec::Vec<SignEvmTransactionCriteriaItem>);
    impl ::std::ops::Deref for SignEvmTransactionCriteria {
        type Target = ::std::vec::Vec<SignEvmTransactionCriteriaItem>;
        fn deref(&self) -> &::std::vec::Vec<SignEvmTransactionCriteriaItem> {
            &self.0
        }
    }
    impl ::std::convert::From<SignEvmTransactionCriteria>
        for ::std::vec::Vec<SignEvmTransactionCriteriaItem>
    {
        fn from(value: SignEvmTransactionCriteria) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignEvmTransactionCriteria> for SignEvmTransactionCriteria {
        fn from(value: &SignEvmTransactionCriteria) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::vec::Vec<SignEvmTransactionCriteriaItem>>
        for SignEvmTransactionCriteria
    {
        fn from(value: ::std::vec::Vec<SignEvmTransactionCriteriaItem>) -> Self {
            Self(value)
        }
    }
    ///`SignEvmTransactionCriteriaItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/EthValueCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EvmAddressCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EvmDataCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NetUSDChangeCriterion"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum SignEvmTransactionCriteriaItem {
        EthValueCriterion(EthValueCriterion),
        EvmAddressCriterion(EvmAddressCriterion),
        EvmDataCriterion(EvmDataCriterion),
        NetUsdChangeCriterion(NetUsdChangeCriterion),
    }
    impl ::std::convert::From<&Self> for SignEvmTransactionCriteriaItem {
        fn from(value: &SignEvmTransactionCriteriaItem) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<EthValueCriterion> for SignEvmTransactionCriteriaItem {
        fn from(value: EthValueCriterion) -> Self {
            Self::EthValueCriterion(value)
        }
    }
    impl ::std::convert::From<EvmAddressCriterion> for SignEvmTransactionCriteriaItem {
        fn from(value: EvmAddressCriterion) -> Self {
            Self::EvmAddressCriterion(value)
        }
    }
    impl ::std::convert::From<EvmDataCriterion> for SignEvmTransactionCriteriaItem {
        fn from(value: EvmDataCriterion) -> Self {
            Self::EvmDataCriterion(value)
        }
    }
    impl ::std::convert::From<NetUsdChangeCriterion> for SignEvmTransactionCriteriaItem {
        fn from(value: NetUsdChangeCriterion) -> Self {
            Self::NetUsdChangeCriterion(value)
        }
    }
    ///`SignEvmTransactionResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "signedTransaction"
    ///  ],
    ///  "properties": {
    ///    "signedTransaction": {
    ///      "description": "The RLP-encoded signed transaction, as a 0x-prefixed hex string.",
    ///      "examples": [
    ///        "0x1b0c9cf8cd4554c6c6d9e7311e88f1be075d7f25b418a044f4bf2c0a42a93e212ad0a8b54de9e0b5f7e3812de3f2c6cc79aa8c3e1c02e7ad14b4a8f42012c2c01b"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmTransactionResponse {
        ///The RLP-encoded signed transaction, as a 0x-prefixed hex string.
        #[serde(rename = "signedTransaction")]
        pub signed_transaction: ::std::string::String,
    }
    impl ::std::convert::From<&SignEvmTransactionResponse> for SignEvmTransactionResponse {
        fn from(value: &SignEvmTransactionResponse) -> Self {
            value.clone()
        }
    }
    impl SignEvmTransactionResponse {
        pub fn builder() -> builder::SignEvmTransactionResponse {
            Default::default()
        }
    }
    ///`SignEvmTransactionRule`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SignEvmTransactionRule",
    ///  "required": [
    ///    "action",
    ///    "criteria",
    ///    "operation"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///      "examples": [
    ///        "accept"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "reject",
    ///        "accept"
    ///      ]
    ///    },
    ///    "criteria": {
    ///      "$ref": "#/components/schemas/SignEvmTransactionCriteria"
    ///    },
    ///    "operation": {
    ///      "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///      "examples": [
    ///        "signEvmTransaction"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "signEvmTransaction"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmTransactionRule {
        ///Whether matching the rule will cause the request to be rejected or accepted.
        pub action: SignEvmTransactionRuleAction,
        pub criteria: SignEvmTransactionCriteria,
        ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
        pub operation: SignEvmTransactionRuleOperation,
    }
    impl ::std::convert::From<&SignEvmTransactionRule> for SignEvmTransactionRule {
        fn from(value: &SignEvmTransactionRule) -> Self {
            value.clone()
        }
    }
    impl SignEvmTransactionRule {
        pub fn builder() -> builder::SignEvmTransactionRule {
            Default::default()
        }
    }
    ///Whether matching the rule will cause the request to be rejected or accepted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///  "examples": [
    ///    "accept"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "reject",
    ///    "accept"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignEvmTransactionRuleAction {
        #[serde(rename = "reject")]
        Reject,
        #[serde(rename = "accept")]
        Accept,
    }
    impl ::std::convert::From<&Self> for SignEvmTransactionRuleAction {
        fn from(value: &SignEvmTransactionRuleAction) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignEvmTransactionRuleAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Reject => f.write_str("reject"),
                Self::Accept => f.write_str("accept"),
            }
        }
    }
    impl ::std::str::FromStr for SignEvmTransactionRuleAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "reject" => Ok(Self::Reject),
                "accept" => Ok(Self::Accept),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmTransactionRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmTransactionRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmTransactionRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///  "examples": [
    ///    "signEvmTransaction"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "signEvmTransaction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignEvmTransactionRuleOperation {
        #[serde(rename = "signEvmTransaction")]
        SignEvmTransaction,
    }
    impl ::std::convert::From<&Self> for SignEvmTransactionRuleOperation {
        fn from(value: &SignEvmTransactionRuleOperation) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignEvmTransactionRuleOperation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignEvmTransaction => f.write_str("signEvmTransaction"),
            }
        }
    }
    impl ::std::str::FromStr for SignEvmTransactionRuleOperation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signEvmTransaction" => Ok(Self::SignEvmTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmTransactionRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmTransactionRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmTransactionRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`SignEvmTransactionXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SignEvmTransactionXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for SignEvmTransactionXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SignEvmTransactionXIdempotencyKey> for ::std::string::String {
        fn from(value: SignEvmTransactionXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignEvmTransactionXIdempotencyKey>
        for SignEvmTransactionXIdempotencyKey
    {
        fn from(value: &SignEvmTransactionXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SignEvmTransactionXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmTransactionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmTransactionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmTransactionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SignEvmTransactionXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SignEvmTypedDataAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SignEvmTypedDataAddress(::std::string::String);
    impl ::std::ops::Deref for SignEvmTypedDataAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SignEvmTypedDataAddress> for ::std::string::String {
        fn from(value: SignEvmTypedDataAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignEvmTypedDataAddress> for SignEvmTypedDataAddress {
        fn from(value: &SignEvmTypedDataAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SignEvmTypedDataAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmTypedDataAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmTypedDataAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmTypedDataAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SignEvmTypedDataAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///A schema for specifying criteria for the SignEvmTypedData operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A schema for specifying criteria for the SignEvmTypedData operation.",
    ///  "examples": [
    ///    [
    ///      {
    ///        "conditions": [
    ///          {
    ///            "addresses": [
    ///              "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///            ],
    ///            "operator": "in",
    ///            "path": "to.wallet"
    ///          },
    ///          {
    ///            "operator": ">=",
    ///            "path": "to.score",
    ///            "value": "50"
    ///          },
    ///          {
    ///            "match": "^hello ([a-z]+)$",
    ///            "path": "contents"
    ///          }
    ///        ],
    ///        "type": "evmTypedDataField",
    ///        "types": {
    ///          "primaryType": "Mail",
    ///          "types": {
    ///            "Mail": [
    ///              {
    ///                "name": "from",
    ///                "type": "Person"
    ///              },
    ///              {
    ///                "name": "to",
    ///                "type": "Person"
    ///              },
    ///              {
    ///                "name": "contents",
    ///                "type": "string"
    ///              }
    ///            ],
    ///            "Person": [
    ///              {
    ///                "name": "name",
    ///                "type": "string"
    ///              },
    ///              {
    ///                "name": "wallet",
    ///                "type": "address"
    ///              },
    ///              {
    ///                "name": "score",
    ///                "type": "uint256"
    ///              }
    ///            ]
    ///          }
    ///        }
    ///      },
    ///      {
    ///        "addresses": [
    ///          "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///        ],
    ///        "operator": "in",
    ///        "type": "evmTypedDataVerifyingContract"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "array",
    ///  "items": {
    ///    "oneOf": [
    ///      {
    ///        "$ref": "#/components/schemas/SignEvmTypedDataFieldCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/SignEvmTypedDataVerifyingContractCriterion"
    ///      }
    ///    ]
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SignEvmTypedDataCriteria(pub ::std::vec::Vec<SignEvmTypedDataCriteriaItem>);
    impl ::std::ops::Deref for SignEvmTypedDataCriteria {
        type Target = ::std::vec::Vec<SignEvmTypedDataCriteriaItem>;
        fn deref(&self) -> &::std::vec::Vec<SignEvmTypedDataCriteriaItem> {
            &self.0
        }
    }
    impl ::std::convert::From<SignEvmTypedDataCriteria>
        for ::std::vec::Vec<SignEvmTypedDataCriteriaItem>
    {
        fn from(value: SignEvmTypedDataCriteria) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignEvmTypedDataCriteria> for SignEvmTypedDataCriteria {
        fn from(value: &SignEvmTypedDataCriteria) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::vec::Vec<SignEvmTypedDataCriteriaItem>>
        for SignEvmTypedDataCriteria
    {
        fn from(value: ::std::vec::Vec<SignEvmTypedDataCriteriaItem>) -> Self {
            Self(value)
        }
    }
    ///`SignEvmTypedDataCriteriaItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SignEvmTypedDataFieldCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SignEvmTypedDataVerifyingContractCriterion"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum SignEvmTypedDataCriteriaItem {
        FieldCriterion(SignEvmTypedDataFieldCriterion),
        VerifyingContractCriterion(SignEvmTypedDataVerifyingContractCriterion),
    }
    impl ::std::convert::From<&Self> for SignEvmTypedDataCriteriaItem {
        fn from(value: &SignEvmTypedDataCriteriaItem) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<SignEvmTypedDataFieldCriterion> for SignEvmTypedDataCriteriaItem {
        fn from(value: SignEvmTypedDataFieldCriterion) -> Self {
            Self::FieldCriterion(value)
        }
    }
    impl ::std::convert::From<SignEvmTypedDataVerifyingContractCriterion>
        for SignEvmTypedDataCriteriaItem
    {
        fn from(value: SignEvmTypedDataVerifyingContractCriterion) -> Self {
            Self::VerifyingContractCriterion(value)
        }
    }
    ///`SignEvmTypedDataFieldCriterion`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SignEvmTypedDataFieldCriterion",
    ///  "type": "object",
    ///  "required": [
    ///    "conditions",
    ///    "type",
    ///    "types"
    ///  ],
    ///  "properties": {
    ///    "conditions": {
    ///      "description": "A list of conditions to check against the data being signed. Each condition must be met for the rule to take effect.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "addresses": [
    ///              "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///            ],
    ///            "operator": "in",
    ///            "path": "to.wallet"
    ///          },
    ///          {
    ///            "operator": ">=",
    ///            "path": "to.score",
    ///            "value": "50"
    ///          },
    ///          {
    ///            "match": "^hello ([a-z]+)$",
    ///            "path": "contents"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "oneOf": [
    ///          {
    ///            "$ref": "#/components/schemas/EvmTypedAddressCondition"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/EvmTypedNumericalCondition"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/EvmTypedStringCondition"
    ///          }
    ///        ]
    ///      }
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `evmTypedDataField`.",
    ///      "examples": [
    ///        "evmTypedDataField"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "evmTypedDataField"
    ///      ]
    ///    },
    ///    "types": {
    ///      "description": "An object containing EIP-712 type definitions, as well as a primary type for the root message object.",
    ///      "examples": [
    ///        {
    ///          "primaryType": "Mail",
    ///          "types": {
    ///            "Mail": [
    ///              {
    ///                "name": "from",
    ///                "type": "Person"
    ///              },
    ///              {
    ///                "name": "to",
    ///                "type": "Person"
    ///              },
    ///              {
    ///                "name": "contents",
    ///                "type": "string"
    ///              }
    ///            ],
    ///            "Person": [
    ///              {
    ///                "name": "name",
    ///                "type": "string"
    ///              },
    ///              {
    ///                "name": "wallet",
    ///                "type": "address"
    ///              },
    ///              {
    ///                "name": "score",
    ///                "type": "uint256"
    ///              }
    ///            ]
    ///          }
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "required": [
    ///        "primaryType",
    ///        "types"
    ///      ],
    ///      "properties": {
    ///        "primaryType": {
    ///          "description": "The name of the root EIP-712 type. This value must be included in the `types` object.",
    ///          "type": "string"
    ///        },
    ///        "types": {
    ///          "description": "EIP-712 compliant map of model names to model definitions.",
    ///          "type": "object",
    ///          "additionalProperties": {
    ///            "description": "Object containing names and types for fields within structured data.",
    ///            "type": "array",
    ///            "items": {
    ///              "type": "object",
    ///              "properties": {
    ///                "name": {
    ///                  "description": "The name of a key within an EIP-712 data structure.",
    ///                  "type": "string"
    ///                },
    ///                "type": {
    ///                  "description": "The Solidity type of a value within an EIP-712 data structure.",
    ///                  "type": "string"
    ///                }
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmTypedDataFieldCriterion {
        ///A list of conditions to check against the data being signed. Each condition must be met for the rule to take effect.
        pub conditions: ::std::vec::Vec<SignEvmTypedDataFieldCriterionConditionsItem>,
        ///The type of criterion to use. This should be `evmTypedDataField`.
        #[serde(rename = "type")]
        pub type_: SignEvmTypedDataFieldCriterionType,
        pub types: SignEvmTypedDataFieldCriterionTypes,
    }
    impl ::std::convert::From<&SignEvmTypedDataFieldCriterion> for SignEvmTypedDataFieldCriterion {
        fn from(value: &SignEvmTypedDataFieldCriterion) -> Self {
            value.clone()
        }
    }
    impl SignEvmTypedDataFieldCriterion {
        pub fn builder() -> builder::SignEvmTypedDataFieldCriterion {
            Default::default()
        }
    }
    ///`SignEvmTypedDataFieldCriterionConditionsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/EvmTypedAddressCondition"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EvmTypedNumericalCondition"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EvmTypedStringCondition"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum SignEvmTypedDataFieldCriterionConditionsItem {
        AddressCondition(EvmTypedAddressCondition),
        NumericalCondition(EvmTypedNumericalCondition),
        StringCondition(EvmTypedStringCondition),
    }
    impl ::std::convert::From<&Self> for SignEvmTypedDataFieldCriterionConditionsItem {
        fn from(value: &SignEvmTypedDataFieldCriterionConditionsItem) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<EvmTypedAddressCondition>
        for SignEvmTypedDataFieldCriterionConditionsItem
    {
        fn from(value: EvmTypedAddressCondition) -> Self {
            Self::AddressCondition(value)
        }
    }
    impl ::std::convert::From<EvmTypedNumericalCondition>
        for SignEvmTypedDataFieldCriterionConditionsItem
    {
        fn from(value: EvmTypedNumericalCondition) -> Self {
            Self::NumericalCondition(value)
        }
    }
    impl ::std::convert::From<EvmTypedStringCondition>
        for SignEvmTypedDataFieldCriterionConditionsItem
    {
        fn from(value: EvmTypedStringCondition) -> Self {
            Self::StringCondition(value)
        }
    }
    ///The type of criterion to use. This should be `evmTypedDataField`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `evmTypedDataField`.",
    ///  "examples": [
    ///    "evmTypedDataField"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "evmTypedDataField"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignEvmTypedDataFieldCriterionType {
        #[serde(rename = "evmTypedDataField")]
        EvmTypedDataField,
    }
    impl ::std::convert::From<&Self> for SignEvmTypedDataFieldCriterionType {
        fn from(value: &SignEvmTypedDataFieldCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignEvmTypedDataFieldCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EvmTypedDataField => f.write_str("evmTypedDataField"),
            }
        }
    }
    impl ::std::str::FromStr for SignEvmTypedDataFieldCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "evmTypedDataField" => Ok(Self::EvmTypedDataField),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmTypedDataFieldCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmTypedDataFieldCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmTypedDataFieldCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///An object containing EIP-712 type definitions, as well as a primary type for the root message object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An object containing EIP-712 type definitions, as well as a primary type for the root message object.",
    ///  "examples": [
    ///    {
    ///      "primaryType": "Mail",
    ///      "types": {
    ///        "Mail": [
    ///          {
    ///            "name": "from",
    ///            "type": "Person"
    ///          },
    ///          {
    ///            "name": "to",
    ///            "type": "Person"
    ///          },
    ///          {
    ///            "name": "contents",
    ///            "type": "string"
    ///          }
    ///        ],
    ///        "Person": [
    ///          {
    ///            "name": "name",
    ///            "type": "string"
    ///          },
    ///          {
    ///            "name": "wallet",
    ///            "type": "address"
    ///          },
    ///          {
    ///            "name": "score",
    ///            "type": "uint256"
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "primaryType",
    ///    "types"
    ///  ],
    ///  "properties": {
    ///    "primaryType": {
    ///      "description": "The name of the root EIP-712 type. This value must be included in the `types` object.",
    ///      "type": "string"
    ///    },
    ///    "types": {
    ///      "description": "EIP-712 compliant map of model names to model definitions.",
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "description": "Object containing names and types for fields within structured data.",
    ///        "type": "array",
    ///        "items": {
    ///          "type": "object",
    ///          "properties": {
    ///            "name": {
    ///              "description": "The name of a key within an EIP-712 data structure.",
    ///              "type": "string"
    ///            },
    ///            "type": {
    ///              "description": "The Solidity type of a value within an EIP-712 data structure.",
    ///              "type": "string"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmTypedDataFieldCriterionTypes {
        ///The name of the root EIP-712 type. This value must be included in the `types` object.
        #[serde(rename = "primaryType")]
        pub primary_type: ::std::string::String,
        ///EIP-712 compliant map of model names to model definitions.
        pub types: ::std::collections::HashMap<
            ::std::string::String,
            ::std::vec::Vec<SignEvmTypedDataFieldCriterionTypesTypesValueItem>,
        >,
    }
    impl ::std::convert::From<&SignEvmTypedDataFieldCriterionTypes>
        for SignEvmTypedDataFieldCriterionTypes
    {
        fn from(value: &SignEvmTypedDataFieldCriterionTypes) -> Self {
            value.clone()
        }
    }
    impl SignEvmTypedDataFieldCriterionTypes {
        pub fn builder() -> builder::SignEvmTypedDataFieldCriterionTypes {
            Default::default()
        }
    }
    ///`SignEvmTypedDataFieldCriterionTypesTypesValueItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "name": {
    ///      "description": "The name of a key within an EIP-712 data structure.",
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The Solidity type of a value within an EIP-712 data structure.",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmTypedDataFieldCriterionTypesTypesValueItem {
        ///The name of a key within an EIP-712 data structure.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The Solidity type of a value within an EIP-712 data structure.
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&SignEvmTypedDataFieldCriterionTypesTypesValueItem>
        for SignEvmTypedDataFieldCriterionTypesTypesValueItem
    {
        fn from(value: &SignEvmTypedDataFieldCriterionTypesTypesValueItem) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for SignEvmTypedDataFieldCriterionTypesTypesValueItem {
        fn default() -> Self {
            Self {
                name: Default::default(),
                type_: Default::default(),
            }
        }
    }
    impl SignEvmTypedDataFieldCriterionTypesTypesValueItem {
        pub fn builder() -> builder::SignEvmTypedDataFieldCriterionTypesTypesValueItem {
            Default::default()
        }
    }
    ///`SignEvmTypedDataResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "signature"
    ///  ],
    ///  "properties": {
    ///    "signature": {
    ///      "description": "The signature of the typed data, as a 0x-prefixed hex string.",
    ///      "examples": [
    ///        "0x1b0c9cf8cd4554c6c6d9e7311e88f1be075d7f25b418a044f4bf2c0a42a93e212ad0a8b54de9e0b5f7e3812de3f2c6cc79aa8c3e1c02e7ad14b4a8f42012c2c01b"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmTypedDataResponse {
        ///The signature of the typed data, as a 0x-prefixed hex string.
        pub signature: ::std::string::String,
    }
    impl ::std::convert::From<&SignEvmTypedDataResponse> for SignEvmTypedDataResponse {
        fn from(value: &SignEvmTypedDataResponse) -> Self {
            value.clone()
        }
    }
    impl SignEvmTypedDataResponse {
        pub fn builder() -> builder::SignEvmTypedDataResponse {
            Default::default()
        }
    }
    ///`SignEvmTypedDataRule`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SignEvmTypedDataRule",
    ///  "required": [
    ///    "action",
    ///    "criteria",
    ///    "operation"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///      "examples": [
    ///        "accept"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "reject",
    ///        "accept"
    ///      ]
    ///    },
    ///    "criteria": {
    ///      "$ref": "#/components/schemas/SignEvmTypedDataCriteria"
    ///    },
    ///    "operation": {
    ///      "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///      "examples": [
    ///        "signEvmTypedData"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "signEvmTypedData"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmTypedDataRule {
        ///Whether matching the rule will cause the request to be rejected or accepted.
        pub action: SignEvmTypedDataRuleAction,
        pub criteria: SignEvmTypedDataCriteria,
        ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
        pub operation: SignEvmTypedDataRuleOperation,
    }
    impl ::std::convert::From<&SignEvmTypedDataRule> for SignEvmTypedDataRule {
        fn from(value: &SignEvmTypedDataRule) -> Self {
            value.clone()
        }
    }
    impl SignEvmTypedDataRule {
        pub fn builder() -> builder::SignEvmTypedDataRule {
            Default::default()
        }
    }
    ///Whether matching the rule will cause the request to be rejected or accepted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///  "examples": [
    ///    "accept"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "reject",
    ///    "accept"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignEvmTypedDataRuleAction {
        #[serde(rename = "reject")]
        Reject,
        #[serde(rename = "accept")]
        Accept,
    }
    impl ::std::convert::From<&Self> for SignEvmTypedDataRuleAction {
        fn from(value: &SignEvmTypedDataRuleAction) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignEvmTypedDataRuleAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Reject => f.write_str("reject"),
                Self::Accept => f.write_str("accept"),
            }
        }
    }
    impl ::std::str::FromStr for SignEvmTypedDataRuleAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "reject" => Ok(Self::Reject),
                "accept" => Ok(Self::Accept),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmTypedDataRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmTypedDataRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmTypedDataRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///  "examples": [
    ///    "signEvmTypedData"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "signEvmTypedData"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignEvmTypedDataRuleOperation {
        #[serde(rename = "signEvmTypedData")]
        SignEvmTypedData,
    }
    impl ::std::convert::From<&Self> for SignEvmTypedDataRuleOperation {
        fn from(value: &SignEvmTypedDataRuleOperation) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignEvmTypedDataRuleOperation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignEvmTypedData => f.write_str("signEvmTypedData"),
            }
        }
    }
    impl ::std::str::FromStr for SignEvmTypedDataRuleOperation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signEvmTypedData" => Ok(Self::SignEvmTypedData),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmTypedDataRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmTypedDataRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmTypedDataRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///A schema for specifying criterion for a domain's verifying contract.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SignEvmTypedDataVerifyingContractCriterion",
    ///  "description": "A schema for specifying criterion for a domain's verifying contract.",
    ///  "type": "object",
    ///  "required": [
    ///    "addresses",
    ///    "operator",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "addresses": {
    ///      "description": "A list of 0x-prefixed EVM addresses that the domain's verifying contract should be compared to. There is a limit of 300 addresses per criterion.",
    ///      "examples": [
    ///        [
    ///          "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///          "0x1234567890123456789012345678901234567890"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "The 0x-prefixed EVM address that the domain's verifying contract should be compared to.",
    ///        "type": "string",
    ///        "pattern": "^0x[0-9a-fA-F]{40}$"
    ///      }
    ///    },
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. The domain's verifying contract will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.",
    ///      "examples": [
    ///        "in"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "in",
    ///        "not in"
    ///      ]
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `evmTypedDataVerifyingContract`.",
    ///      "examples": [
    ///        "evmTypedDataVerifyingContract"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "evmTypedDataVerifyingContract"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignEvmTypedDataVerifyingContractCriterion {
        ///A list of 0x-prefixed EVM addresses that the domain's verifying contract should be compared to. There is a limit of 300 addresses per criterion.
        pub addresses: ::std::vec::Vec<SignEvmTypedDataVerifyingContractCriterionAddressesItem>,
        ///The operator to use for the comparison. The domain's verifying contract will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
        pub operator: SignEvmTypedDataVerifyingContractCriterionOperator,
        ///The type of criterion to use. This should be `evmTypedDataVerifyingContract`.
        #[serde(rename = "type")]
        pub type_: SignEvmTypedDataVerifyingContractCriterionType,
    }
    impl ::std::convert::From<&SignEvmTypedDataVerifyingContractCriterion>
        for SignEvmTypedDataVerifyingContractCriterion
    {
        fn from(value: &SignEvmTypedDataVerifyingContractCriterion) -> Self {
            value.clone()
        }
    }
    impl SignEvmTypedDataVerifyingContractCriterion {
        pub fn builder() -> builder::SignEvmTypedDataVerifyingContractCriterion {
            Default::default()
        }
    }
    ///The 0x-prefixed EVM address that the domain's verifying contract should be compared to.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed EVM address that the domain's verifying contract should be compared to.",
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SignEvmTypedDataVerifyingContractCriterionAddressesItem(::std::string::String);
    impl ::std::ops::Deref for SignEvmTypedDataVerifyingContractCriterionAddressesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SignEvmTypedDataVerifyingContractCriterionAddressesItem>
        for ::std::string::String
    {
        fn from(value: SignEvmTypedDataVerifyingContractCriterionAddressesItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignEvmTypedDataVerifyingContractCriterionAddressesItem>
        for SignEvmTypedDataVerifyingContractCriterionAddressesItem
    {
        fn from(value: &SignEvmTypedDataVerifyingContractCriterionAddressesItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SignEvmTypedDataVerifyingContractCriterionAddressesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmTypedDataVerifyingContractCriterionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SignEvmTypedDataVerifyingContractCriterionAddressesItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for SignEvmTypedDataVerifyingContractCriterionAddressesItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SignEvmTypedDataVerifyingContractCriterionAddressesItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The operator to use for the comparison. The domain's verifying contract will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. The domain's verifying contract will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.",
    ///  "examples": [
    ///    "in"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "in",
    ///    "not in"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignEvmTypedDataVerifyingContractCriterionOperator {
        #[serde(rename = "in")]
        In,
        #[serde(rename = "not in")]
        NotIn,
    }
    impl ::std::convert::From<&Self> for SignEvmTypedDataVerifyingContractCriterionOperator {
        fn from(value: &SignEvmTypedDataVerifyingContractCriterionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignEvmTypedDataVerifyingContractCriterionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::In => f.write_str("in"),
                Self::NotIn => f.write_str("not in"),
            }
        }
    }
    impl ::std::str::FromStr for SignEvmTypedDataVerifyingContractCriterionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "in" => Ok(Self::In),
                "not in" => Ok(Self::NotIn),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmTypedDataVerifyingContractCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SignEvmTypedDataVerifyingContractCriterionOperator
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for SignEvmTypedDataVerifyingContractCriterionOperator
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The type of criterion to use. This should be `evmTypedDataVerifyingContract`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `evmTypedDataVerifyingContract`.",
    ///  "examples": [
    ///    "evmTypedDataVerifyingContract"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "evmTypedDataVerifyingContract"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignEvmTypedDataVerifyingContractCriterionType {
        #[serde(rename = "evmTypedDataVerifyingContract")]
        EvmTypedDataVerifyingContract,
    }
    impl ::std::convert::From<&Self> for SignEvmTypedDataVerifyingContractCriterionType {
        fn from(value: &SignEvmTypedDataVerifyingContractCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignEvmTypedDataVerifyingContractCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EvmTypedDataVerifyingContract => f.write_str("evmTypedDataVerifyingContract"),
            }
        }
    }
    impl ::std::str::FromStr for SignEvmTypedDataVerifyingContractCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "evmTypedDataVerifyingContract" => Ok(Self::EvmTypedDataVerifyingContract),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmTypedDataVerifyingContractCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SignEvmTypedDataVerifyingContractCriterionType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for SignEvmTypedDataVerifyingContractCriterionType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`SignEvmTypedDataXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SignEvmTypedDataXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for SignEvmTypedDataXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SignEvmTypedDataXIdempotencyKey> for ::std::string::String {
        fn from(value: SignEvmTypedDataXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignEvmTypedDataXIdempotencyKey> for SignEvmTypedDataXIdempotencyKey {
        fn from(value: &SignEvmTypedDataXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SignEvmTypedDataXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SignEvmTypedDataXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignEvmTypedDataXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignEvmTypedDataXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SignEvmTypedDataXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///A schema for specifying criteria for the SignSolMessage operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A schema for specifying criteria for the SignSolMessage operation.",
    ///  "examples": [
    ///    [
    ///      {
    ///        "match": "^hello ([a-z]+)$",
    ///        "type": "solMessage"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "array",
    ///  "items": {
    ///    "oneOf": [
    ///      {
    ///        "$ref": "#/components/schemas/SolMessageCriterion"
    ///      }
    ///    ]
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SignSolMessageCriteria(pub ::std::vec::Vec<SolMessageCriterion>);
    impl ::std::ops::Deref for SignSolMessageCriteria {
        type Target = ::std::vec::Vec<SolMessageCriterion>;
        fn deref(&self) -> &::std::vec::Vec<SolMessageCriterion> {
            &self.0
        }
    }
    impl ::std::convert::From<SignSolMessageCriteria> for ::std::vec::Vec<SolMessageCriterion> {
        fn from(value: SignSolMessageCriteria) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignSolMessageCriteria> for SignSolMessageCriteria {
        fn from(value: &SignSolMessageCriteria) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::vec::Vec<SolMessageCriterion>> for SignSolMessageCriteria {
        fn from(value: ::std::vec::Vec<SolMessageCriterion>) -> Self {
            Self(value)
        }
    }
    ///`SignSolMessageRule`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SignSolMessageRule",
    ///  "required": [
    ///    "action",
    ///    "criteria",
    ///    "operation"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///      "examples": [
    ///        "accept"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "reject",
    ///        "accept"
    ///      ]
    ///    },
    ///    "criteria": {
    ///      "$ref": "#/components/schemas/SignSolMessageCriteria"
    ///    },
    ///    "operation": {
    ///      "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///      "examples": [
    ///        "signSolMessage"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "signSolMessage"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignSolMessageRule {
        ///Whether matching the rule will cause the request to be rejected or accepted.
        pub action: SignSolMessageRuleAction,
        pub criteria: SignSolMessageCriteria,
        ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
        pub operation: SignSolMessageRuleOperation,
    }
    impl ::std::convert::From<&SignSolMessageRule> for SignSolMessageRule {
        fn from(value: &SignSolMessageRule) -> Self {
            value.clone()
        }
    }
    impl SignSolMessageRule {
        pub fn builder() -> builder::SignSolMessageRule {
            Default::default()
        }
    }
    ///Whether matching the rule will cause the request to be rejected or accepted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///  "examples": [
    ///    "accept"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "reject",
    ///    "accept"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignSolMessageRuleAction {
        #[serde(rename = "reject")]
        Reject,
        #[serde(rename = "accept")]
        Accept,
    }
    impl ::std::convert::From<&Self> for SignSolMessageRuleAction {
        fn from(value: &SignSolMessageRuleAction) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignSolMessageRuleAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Reject => f.write_str("reject"),
                Self::Accept => f.write_str("accept"),
            }
        }
    }
    impl ::std::str::FromStr for SignSolMessageRuleAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "reject" => Ok(Self::Reject),
                "accept" => Ok(Self::Accept),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignSolMessageRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignSolMessageRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignSolMessageRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///  "examples": [
    ///    "signSolMessage"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "signSolMessage"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignSolMessageRuleOperation {
        #[serde(rename = "signSolMessage")]
        SignSolMessage,
    }
    impl ::std::convert::From<&Self> for SignSolMessageRuleOperation {
        fn from(value: &SignSolMessageRuleOperation) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignSolMessageRuleOperation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignSolMessage => f.write_str("signSolMessage"),
            }
        }
    }
    impl ::std::str::FromStr for SignSolMessageRuleOperation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signSolMessage" => Ok(Self::SignSolMessage),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignSolMessageRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignSolMessageRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignSolMessageRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///A schema for specifying criteria for the SignSolTransaction operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A schema for specifying criteria for the SignSolTransaction operation.",
    ///  "examples": [
    ///    [
    ///      {
    ///        "addresses": [
    ///          "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///        ],
    ///        "operator": "in",
    ///        "type": "solAddress"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "array",
    ///  "items": {
    ///    "oneOf": [
    ///      {
    ///        "$ref": "#/components/schemas/SolAddressCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/SolValueCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/SplAddressCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/SplValueCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/MintAddressCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/SolDataCriterion"
    ///      },
    ///      {
    ///        "$ref": "#/components/schemas/ProgramIdCriterion"
    ///      }
    ///    ]
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SignSolTransactionCriteria(pub ::std::vec::Vec<SignSolTransactionCriteriaItem>);
    impl ::std::ops::Deref for SignSolTransactionCriteria {
        type Target = ::std::vec::Vec<SignSolTransactionCriteriaItem>;
        fn deref(&self) -> &::std::vec::Vec<SignSolTransactionCriteriaItem> {
            &self.0
        }
    }
    impl ::std::convert::From<SignSolTransactionCriteria>
        for ::std::vec::Vec<SignSolTransactionCriteriaItem>
    {
        fn from(value: SignSolTransactionCriteria) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignSolTransactionCriteria> for SignSolTransactionCriteria {
        fn from(value: &SignSolTransactionCriteria) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::vec::Vec<SignSolTransactionCriteriaItem>>
        for SignSolTransactionCriteria
    {
        fn from(value: ::std::vec::Vec<SignSolTransactionCriteriaItem>) -> Self {
            Self(value)
        }
    }
    ///`SignSolTransactionCriteriaItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SolAddressCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SolValueCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SplAddressCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SplValueCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MintAddressCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SolDataCriterion"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgramIdCriterion"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum SignSolTransactionCriteriaItem {
        SolAddressCriterion(SolAddressCriterion),
        SolValueCriterion(SolValueCriterion),
        SplAddressCriterion(SplAddressCriterion),
        SplValueCriterion(SplValueCriterion),
        MintAddressCriterion(MintAddressCriterion),
        SolDataCriterion(SolDataCriterion),
        ProgramIdCriterion(ProgramIdCriterion),
    }
    impl ::std::convert::From<&Self> for SignSolTransactionCriteriaItem {
        fn from(value: &SignSolTransactionCriteriaItem) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<SolAddressCriterion> for SignSolTransactionCriteriaItem {
        fn from(value: SolAddressCriterion) -> Self {
            Self::SolAddressCriterion(value)
        }
    }
    impl ::std::convert::From<SolValueCriterion> for SignSolTransactionCriteriaItem {
        fn from(value: SolValueCriterion) -> Self {
            Self::SolValueCriterion(value)
        }
    }
    impl ::std::convert::From<SplAddressCriterion> for SignSolTransactionCriteriaItem {
        fn from(value: SplAddressCriterion) -> Self {
            Self::SplAddressCriterion(value)
        }
    }
    impl ::std::convert::From<SplValueCriterion> for SignSolTransactionCriteriaItem {
        fn from(value: SplValueCriterion) -> Self {
            Self::SplValueCriterion(value)
        }
    }
    impl ::std::convert::From<MintAddressCriterion> for SignSolTransactionCriteriaItem {
        fn from(value: MintAddressCriterion) -> Self {
            Self::MintAddressCriterion(value)
        }
    }
    impl ::std::convert::From<SolDataCriterion> for SignSolTransactionCriteriaItem {
        fn from(value: SolDataCriterion) -> Self {
            Self::SolDataCriterion(value)
        }
    }
    impl ::std::convert::From<ProgramIdCriterion> for SignSolTransactionCriteriaItem {
        fn from(value: ProgramIdCriterion) -> Self {
            Self::ProgramIdCriterion(value)
        }
    }
    ///`SignSolTransactionRule`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SignSolTransactionRule",
    ///  "required": [
    ///    "action",
    ///    "criteria",
    ///    "operation"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///      "examples": [
    ///        "accept"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "reject",
    ///        "accept"
    ///      ]
    ///    },
    ///    "criteria": {
    ///      "$ref": "#/components/schemas/SignSolTransactionCriteria"
    ///    },
    ///    "operation": {
    ///      "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///      "examples": [
    ///        "signSolTransaction"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "signSolTransaction"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignSolTransactionRule {
        ///Whether matching the rule will cause the request to be rejected or accepted.
        pub action: SignSolTransactionRuleAction,
        pub criteria: SignSolTransactionCriteria,
        ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
        pub operation: SignSolTransactionRuleOperation,
    }
    impl ::std::convert::From<&SignSolTransactionRule> for SignSolTransactionRule {
        fn from(value: &SignSolTransactionRule) -> Self {
            value.clone()
        }
    }
    impl SignSolTransactionRule {
        pub fn builder() -> builder::SignSolTransactionRule {
            Default::default()
        }
    }
    ///Whether matching the rule will cause the request to be rejected or accepted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Whether matching the rule will cause the request to be rejected or accepted.",
    ///  "examples": [
    ///    "accept"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "reject",
    ///    "accept"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignSolTransactionRuleAction {
        #[serde(rename = "reject")]
        Reject,
        #[serde(rename = "accept")]
        Accept,
    }
    impl ::std::convert::From<&Self> for SignSolTransactionRuleAction {
        fn from(value: &SignSolTransactionRuleAction) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignSolTransactionRuleAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Reject => f.write_str("reject"),
                Self::Accept => f.write_str("accept"),
            }
        }
    }
    impl ::std::str::FromStr for SignSolTransactionRuleAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "reject" => Ok(Self::Reject),
                "accept" => Ok(Self::Accept),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignSolTransactionRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignSolTransactionRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignSolTransactionRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.",
    ///  "examples": [
    ///    "signSolTransaction"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "signSolTransaction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SignSolTransactionRuleOperation {
        #[serde(rename = "signSolTransaction")]
        SignSolTransaction,
    }
    impl ::std::convert::From<&Self> for SignSolTransactionRuleOperation {
        fn from(value: &SignSolTransactionRuleOperation) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SignSolTransactionRuleOperation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignSolTransaction => f.write_str("signSolTransaction"),
            }
        }
    }
    impl ::std::str::FromStr for SignSolTransactionRuleOperation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signSolTransaction" => Ok(Self::SignSolTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SignSolTransactionRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignSolTransactionRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignSolTransactionRuleOperation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`SignSolanaMessageAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SignSolanaMessageAddress(::std::string::String);
    impl ::std::ops::Deref for SignSolanaMessageAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SignSolanaMessageAddress> for ::std::string::String {
        fn from(value: SignSolanaMessageAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignSolanaMessageAddress> for SignSolanaMessageAddress {
        fn from(value: &SignSolanaMessageAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SignSolanaMessageAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SignSolanaMessageAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignSolanaMessageAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignSolanaMessageAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SignSolanaMessageAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SignSolanaMessageBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "message"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "The arbitrary message to sign.",
    ///      "examples": [
    ///        "Hello, world!"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignSolanaMessageBody {
        ///The arbitrary message to sign.
        pub message: ::std::string::String,
    }
    impl ::std::convert::From<&SignSolanaMessageBody> for SignSolanaMessageBody {
        fn from(value: &SignSolanaMessageBody) -> Self {
            value.clone()
        }
    }
    impl SignSolanaMessageBody {
        pub fn builder() -> builder::SignSolanaMessageBody {
            Default::default()
        }
    }
    ///`SignSolanaMessageResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "signature"
    ///  ],
    ///  "properties": {
    ///    "signature": {
    ///      "description": "The signature of the message, as a base58 encoded string.",
    ///      "examples": [
    ///        "4YecmNqVT9QFqzuSvE9Zih3toZzNAijjXpj8xupgcC6E4VzwzFjuZBk5P99yz9JQaLRLm1K4L4FpMjxByFxQBe2h"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignSolanaMessageResponse {
        ///The signature of the message, as a base58 encoded string.
        pub signature: ::std::string::String,
    }
    impl ::std::convert::From<&SignSolanaMessageResponse> for SignSolanaMessageResponse {
        fn from(value: &SignSolanaMessageResponse) -> Self {
            value.clone()
        }
    }
    impl SignSolanaMessageResponse {
        pub fn builder() -> builder::SignSolanaMessageResponse {
            Default::default()
        }
    }
    ///`SignSolanaMessageXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SignSolanaMessageXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for SignSolanaMessageXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SignSolanaMessageXIdempotencyKey> for ::std::string::String {
        fn from(value: SignSolanaMessageXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignSolanaMessageXIdempotencyKey> for SignSolanaMessageXIdempotencyKey {
        fn from(value: &SignSolanaMessageXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SignSolanaMessageXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SignSolanaMessageXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignSolanaMessageXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignSolanaMessageXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SignSolanaMessageXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SignSolanaTransactionAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SignSolanaTransactionAddress(::std::string::String);
    impl ::std::ops::Deref for SignSolanaTransactionAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SignSolanaTransactionAddress> for ::std::string::String {
        fn from(value: SignSolanaTransactionAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignSolanaTransactionAddress> for SignSolanaTransactionAddress {
        fn from(value: &SignSolanaTransactionAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SignSolanaTransactionAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SignSolanaTransactionAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignSolanaTransactionAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignSolanaTransactionAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SignSolanaTransactionAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SignSolanaTransactionBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "transaction"
    ///  ],
    ///  "properties": {
    ///    "transaction": {
    ///      "description": "The base64 encoded transaction to sign.",
    ///      "examples": [
    ///        "AQABAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAQECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8CBgMBAQAAAAIBAwQAAAAABgIAAAAAAAYDBQEBAAAGBAgAAAAABgUAAAAA6AMAAAAAAAAGBgUBAQEBBgcEAQAAAAYICgMBAQIDBgkCBgAAAAYKAwABAQEGCwMGAQEBBgwDAAABAQAAAAA="
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignSolanaTransactionBody {
        ///The base64 encoded transaction to sign.
        pub transaction: ::std::string::String,
    }
    impl ::std::convert::From<&SignSolanaTransactionBody> for SignSolanaTransactionBody {
        fn from(value: &SignSolanaTransactionBody) -> Self {
            value.clone()
        }
    }
    impl SignSolanaTransactionBody {
        pub fn builder() -> builder::SignSolanaTransactionBody {
            Default::default()
        }
    }
    ///`SignSolanaTransactionResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "signedTransaction"
    ///  ],
    ///  "properties": {
    ///    "signedTransaction": {
    ///      "description": "The base64 encoded signed transaction.",
    ///      "examples": [
    ///        "AQACAdSOvpk0UJXs/rQRXYKSI9hcR0bkGp24qGv6t0/M1XjcQpHf6AHwLcPjEtKQI7p/U0Zo98lnJ5/PZMfVq/0BAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAQECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8CBgMBAQAAAAIBAwQAAAAABgIAAAAAAAYDBQEBAAAGBAgAAAAABgUAAAAA6AMAAAAAAAAGBgUBAQEBBgcEAQAAAAYICgMBAQIDBgkCBgAAAAYKAwABAQEGCwMGAQEBBgwDAAABAQAAAAA="
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignSolanaTransactionResponse {
        ///The base64 encoded signed transaction.
        #[serde(rename = "signedTransaction")]
        pub signed_transaction: ::std::string::String,
    }
    impl ::std::convert::From<&SignSolanaTransactionResponse> for SignSolanaTransactionResponse {
        fn from(value: &SignSolanaTransactionResponse) -> Self {
            value.clone()
        }
    }
    impl SignSolanaTransactionResponse {
        pub fn builder() -> builder::SignSolanaTransactionResponse {
            Default::default()
        }
    }
    ///`SignSolanaTransactionXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SignSolanaTransactionXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for SignSolanaTransactionXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SignSolanaTransactionXIdempotencyKey> for ::std::string::String {
        fn from(value: SignSolanaTransactionXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignSolanaTransactionXIdempotencyKey>
        for SignSolanaTransactionXIdempotencyKey
    {
        fn from(value: &SignSolanaTransactionXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SignSolanaTransactionXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SignSolanaTransactionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignSolanaTransactionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignSolanaTransactionXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SignSolanaTransactionXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed Externally Owned Account (EOA) address that will sign the `Permit2` EIP-712 permit message. This is only needed if `taker` is a smart contract.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed Externally Owned Account (EOA) address that will sign the `Permit2` EIP-712 permit message. This is only needed if `taker` is a smart contract.",
    ///  "examples": [
    ///    "0x922f49447d8a07e3bd95bd0d56f35241523fbab8"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SignerAddress(::std::string::String);
    impl ::std::ops::Deref for SignerAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SignerAddress> for ::std::string::String {
        fn from(value: SignerAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SignerAddress> for SignerAddress {
        fn from(value: &SignerAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SignerAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SignerAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SignerAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SignerAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SignerAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The maximum acceptable slippage of the `toToken` in basis points. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100 bps (i.e., 1%).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The maximum acceptable slippage of the `toToken` in basis points. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100 bps (i.e., 1%).",
    ///  "default": 100,
    ///  "examples": [
    ///    100
    ///  ],
    ///  "type": "integer",
    ///  "maximum": 10000.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct SlippageBps(pub i64);
    impl ::std::ops::Deref for SlippageBps {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }
    impl ::std::convert::From<SlippageBps> for i64 {
        fn from(value: SlippageBps) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SlippageBps> for SlippageBps {
        fn from(value: &SlippageBps) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<i64> for SlippageBps {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }
    impl ::std::str::FromStr for SlippageBps {
        type Err = <i64 as ::std::str::FromStr>::Err;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }
    impl ::std::convert::TryFrom<&str> for SlippageBps {
        type Error = <i64 as ::std::str::FromStr>::Err;
        fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for SlippageBps {
        type Error = <i64 as ::std::str::FromStr>::Err;
        fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for SlippageBps {
        type Error = <i64 as ::std::str::FromStr>::Err;
        fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl ::std::fmt::Display for SlippageBps {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///Information about an end user who authenticates using a one-time password sent to their phone number via SMS.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SmsAuthentication",
    ///  "description": "Information about an end user who authenticates using a one-time password sent to their phone number via SMS.",
    ///  "type": "object",
    ///  "required": [
    ///    "phoneNumber",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "phoneNumber": {
    ///      "description": "The phone number of the end user in E.164 format.",
    ///      "examples": [
    ///        "+12055555555"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\+[1-9]\\d{1,14}$"
    ///    },
    ///    "type": {
    ///      "description": "The type of authentication information.",
    ///      "examples": [
    ///        "sms"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "sms"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SmsAuthentication {
        ///The phone number of the end user in E.164 format.
        #[serde(rename = "phoneNumber")]
        pub phone_number: SmsAuthenticationPhoneNumber,
        ///The type of authentication information.
        #[serde(rename = "type")]
        pub type_: SmsAuthenticationType,
    }
    impl ::std::convert::From<&SmsAuthentication> for SmsAuthentication {
        fn from(value: &SmsAuthentication) -> Self {
            value.clone()
        }
    }
    impl SmsAuthentication {
        pub fn builder() -> builder::SmsAuthentication {
            Default::default()
        }
    }
    ///The phone number of the end user in E.164 format.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The phone number of the end user in E.164 format.",
    ///  "examples": [
    ///    "+12055555555"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\+[1-9]\\d{1,14}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SmsAuthenticationPhoneNumber(::std::string::String);
    impl ::std::ops::Deref for SmsAuthenticationPhoneNumber {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SmsAuthenticationPhoneNumber> for ::std::string::String {
        fn from(value: SmsAuthenticationPhoneNumber) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SmsAuthenticationPhoneNumber> for SmsAuthenticationPhoneNumber {
        fn from(value: &SmsAuthenticationPhoneNumber) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SmsAuthenticationPhoneNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\+[1-9]\\d{1,14}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\+[1-9]\\d{1,14}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SmsAuthenticationPhoneNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SmsAuthenticationPhoneNumber {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SmsAuthenticationPhoneNumber {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SmsAuthenticationPhoneNumber {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The type of authentication information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of authentication information.",
    ///  "examples": [
    ///    "sms"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "sms"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SmsAuthenticationType {
        #[serde(rename = "sms")]
        Sms,
    }
    impl ::std::convert::From<&Self> for SmsAuthenticationType {
        fn from(value: &SmsAuthenticationType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SmsAuthenticationType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sms => f.write_str("sms"),
            }
        }
    }
    impl ::std::str::FromStr for SmsAuthenticationType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sms" => Ok(Self::Sms),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SmsAuthenticationType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SmsAuthenticationType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SmsAuthenticationType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The criterion for the recipient addresses of a Solana transaction's native transfer instruction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SolAddressCriterion",
    ///  "description": "The criterion for the recipient addresses of a Solana transaction's native transfer instruction.",
    ///  "type": "object",
    ///  "required": [
    ///    "addresses",
    ///    "operator",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "addresses": {
    ///      "description": "The Solana addresses that are compared to the list of native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.",
    ///      "examples": [
    ///        [
    ///          "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "The Solana address that is compared to the list of native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.",
    ///        "type": "string",
    ///        "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///      }
    ///    },
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. Each of the native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.",
    ///      "examples": [
    ///        "in"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "in",
    ///        "not in"
    ///      ]
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `solAddress`.",
    ///      "examples": [
    ///        "solAddress"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "solAddress"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SolAddressCriterion {
        ///The Solana addresses that are compared to the list of native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.
        pub addresses: ::std::vec::Vec<SolAddressCriterionAddressesItem>,
        ///The operator to use for the comparison. Each of the native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
        pub operator: SolAddressCriterionOperator,
        ///The type of criterion to use. This should be `solAddress`.
        #[serde(rename = "type")]
        pub type_: SolAddressCriterionType,
    }
    impl ::std::convert::From<&SolAddressCriterion> for SolAddressCriterion {
        fn from(value: &SolAddressCriterion) -> Self {
            value.clone()
        }
    }
    impl SolAddressCriterion {
        pub fn builder() -> builder::SolAddressCriterion {
            Default::default()
        }
    }
    ///The Solana address that is compared to the list of native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Solana address that is compared to the list of native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.",
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SolAddressCriterionAddressesItem(::std::string::String);
    impl ::std::ops::Deref for SolAddressCriterionAddressesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SolAddressCriterionAddressesItem> for ::std::string::String {
        fn from(value: SolAddressCriterionAddressesItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SolAddressCriterionAddressesItem> for SolAddressCriterionAddressesItem {
        fn from(value: &SolAddressCriterionAddressesItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SolAddressCriterionAddressesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SolAddressCriterionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolAddressCriterionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolAddressCriterionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SolAddressCriterionAddressesItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The operator to use for the comparison. Each of the native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. Each of the native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.",
    ///  "examples": [
    ///    "in"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "in",
    ///    "not in"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolAddressCriterionOperator {
        #[serde(rename = "in")]
        In,
        #[serde(rename = "not in")]
        NotIn,
    }
    impl ::std::convert::From<&Self> for SolAddressCriterionOperator {
        fn from(value: &SolAddressCriterionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolAddressCriterionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::In => f.write_str("in"),
                Self::NotIn => f.write_str("not in"),
            }
        }
    }
    impl ::std::str::FromStr for SolAddressCriterionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "in" => Ok(Self::In),
                "not in" => Ok(Self::NotIn),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolAddressCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolAddressCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolAddressCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The type of criterion to use. This should be `solAddress`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `solAddress`.",
    ///  "examples": [
    ///    "solAddress"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "solAddress"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolAddressCriterionType {
        #[serde(rename = "solAddress")]
        SolAddress,
    }
    impl ::std::convert::From<&Self> for SolAddressCriterionType {
        fn from(value: &SolAddressCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolAddressCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SolAddress => f.write_str("solAddress"),
            }
        }
    }
    impl ::std::str::FromStr for SolAddressCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solAddress" => Ok(Self::SolAddress),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolAddressCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolAddressCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolAddressCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///A single condition to apply against a specific instruction type and its parameters.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single condition to apply against a specific instruction type and its parameters.",
    ///  "type": "object",
    ///  "required": [
    ///    "instruction"
    ///  ],
    ///  "properties": {
    ///    "instruction": {
    ///      "description": "The instruction name.",
    ///      "examples": [
    ///        "transfer_checked"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "params": {
    ///      "description": "Parameter conditions for the instruction.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "name": "amount",
    ///            "operator": "<=",
    ///            "value": "1000000"
    ///          },
    ///          {
    ///            "name": "decimals",
    ///            "operator": "==",
    ///            "value": "6"
    ///          },
    ///          {
    ///            "name": "owner",
    ///            "operator": "in",
    ///            "values": [
    ///              "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
    ///              "So11111111111111111111111111111111111111112"
    ///            ]
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "A list of parameter conditions to apply against a specific instruction's data.",
    ///        "oneOf": [
    ///          {
    ///            "$ref": "#/components/schemas/SolDataParameterCondition"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/SolDataParameterConditionList"
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SolDataCondition {
        ///The instruction name.
        pub instruction: ::std::string::String,
        ///Parameter conditions for the instruction.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub params: ::std::vec::Vec<SolDataConditionParamsItem>,
    }
    impl ::std::convert::From<&SolDataCondition> for SolDataCondition {
        fn from(value: &SolDataCondition) -> Self {
            value.clone()
        }
    }
    impl SolDataCondition {
        pub fn builder() -> builder::SolDataCondition {
            Default::default()
        }
    }
    ///A list of parameter conditions to apply against a specific instruction's data.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A list of parameter conditions to apply against a specific instruction's data.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SolDataParameterCondition"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SolDataParameterConditionList"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum SolDataConditionParamsItem {
        Variant0(SolDataParameterCondition),
        Variant1(SolDataParameterConditionList),
    }
    impl ::std::convert::From<&Self> for SolDataConditionParamsItem {
        fn from(value: &SolDataConditionParamsItem) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<SolDataParameterCondition> for SolDataConditionParamsItem {
        fn from(value: SolDataParameterCondition) -> Self {
            Self::Variant0(value)
        }
    }
    impl ::std::convert::From<SolDataParameterConditionList> for SolDataConditionParamsItem {
        fn from(value: SolDataParameterConditionList) -> Self {
            Self::Variant1(value)
        }
    }
    ///A schema for specifying criterion for instruction data in a Solana transaction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A schema for specifying criterion for instruction data in a Solana transaction.",
    ///  "type": "object",
    ///  "required": [
    ///    "conditions",
    ///    "idls",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "conditions": {
    ///      "description": "A list of conditions to apply against the transaction instruction. Only one condition must evaluate to true for this criterion to be met.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "instruction": "transfer_checked",
    ///            "params": [
    ///              {
    ///                "name": "lamports",
    ///                "operator": "<=",
    ///                "value": "1000000"
    ///              },
    ///              {
    ///                "name": "space",
    ///                "operator": "==",
    ///                "value": "64"
    ///              }
    ///            ]
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SolDataCondition"
    ///      }
    ///    },
    ///    "idls": {
    ///      "description": "List of IDL specifications. Can contain known program names (strings) or custom IDL objects.",
    ///      "examples": [
    ///        [
    ///          "SystemProgram",
    ///          "TokenProgram",
    ///          {
    ///            "address": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
    ///            "instructions": [
    ///              {
    ///                "args": [
    ///                  {
    ///                    "name": "amount",
    ///                    "type": "u64"
    ///                  },
    ///                  {
    ///                    "name": "decimals",
    ///                    "type": "u8"
    ///                  }
    ///                ],
    ///                "discriminator": [
    ///                  119,
    ///                  250,
    ///                  202,
    ///                  24,
    ///                  253,
    ///                  135,
    ///                  244,
    ///                  121
    ///                ],
    ///                "name": "transfer_checked"
    ///              }
    ///            ]
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "oneOf": [
    ///          {
    ///            "$ref": "#/components/schemas/KnownIdlType"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/Idl"
    ///          }
    ///        ]
    ///      }
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `solData`.",
    ///      "examples": [
    ///        "solData"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "solData"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SolDataCriterion {
        ///A list of conditions to apply against the transaction instruction. Only one condition must evaluate to true for this criterion to be met.
        pub conditions: ::std::vec::Vec<SolDataCondition>,
        ///List of IDL specifications. Can contain known program names (strings) or custom IDL objects.
        pub idls: ::std::vec::Vec<SolDataCriterionIdlsItem>,
        ///The type of criterion to use. This should be `solData`.
        #[serde(rename = "type")]
        pub type_: SolDataCriterionType,
    }
    impl ::std::convert::From<&SolDataCriterion> for SolDataCriterion {
        fn from(value: &SolDataCriterion) -> Self {
            value.clone()
        }
    }
    impl SolDataCriterion {
        pub fn builder() -> builder::SolDataCriterion {
            Default::default()
        }
    }
    ///`SolDataCriterionIdlsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/KnownIdlType"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/Idl"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum SolDataCriterionIdlsItem {
        KnownIdlType(KnownIdlType),
        Idl(Idl),
    }
    impl ::std::convert::From<&Self> for SolDataCriterionIdlsItem {
        fn from(value: &SolDataCriterionIdlsItem) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<KnownIdlType> for SolDataCriterionIdlsItem {
        fn from(value: KnownIdlType) -> Self {
            Self::KnownIdlType(value)
        }
    }
    impl ::std::convert::From<Idl> for SolDataCriterionIdlsItem {
        fn from(value: Idl) -> Self {
            Self::Idl(value)
        }
    }
    ///The type of criterion to use. This should be `solData`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `solData`.",
    ///  "examples": [
    ///    "solData"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "solData"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolDataCriterionType {
        #[serde(rename = "solData")]
        SolData,
    }
    impl ::std::convert::From<&Self> for SolDataCriterionType {
        fn from(value: &SolDataCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolDataCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SolData => f.write_str("solData"),
            }
        }
    }
    impl ::std::str::FromStr for SolDataCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solData" => Ok(Self::SolData),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolDataCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolDataCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolDataCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///A single parameter condition to apply against a specific instruction's parameters.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SolDataParameterCondition",
    ///  "description": "A single parameter condition to apply against a specific instruction's parameters.",
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "operator",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "description": "The parameter name.",
    ///      "examples": [
    ///        "amount"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.",
    ///      "examples": [
    ///        "=="
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "GreaterThan",
    ///        "GreaterThanOrEqual",
    ///        "LessThan",
    ///        "LessThanOrEqual",
    ///        "Equal"
    ///      ]
    ///    },
    ///    "value": {
    ///      "description": "The value to compare against.",
    ///      "examples": [
    ///        "1000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SolDataParameterCondition {
        ///The parameter name.
        pub name: ::std::string::String,
        ///The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
        pub operator: SolDataParameterConditionOperator,
        ///The value to compare against.
        pub value: ::std::string::String,
    }
    impl ::std::convert::From<&SolDataParameterCondition> for SolDataParameterCondition {
        fn from(value: &SolDataParameterCondition) -> Self {
            value.clone()
        }
    }
    impl SolDataParameterCondition {
        pub fn builder() -> builder::SolDataParameterCondition {
            Default::default()
        }
    }
    ///A single parameter condition to apply against a specific instruction's parameters.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SolDataParameterConditionList",
    ///  "description": "A single parameter condition to apply against a specific instruction's parameters.",
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "operator",
    ///    "values"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "description": "The parameter name.",
    ///      "examples": [
    ///        "amount"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.",
    ///      "examples": [
    ///        "in"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "in",
    ///        "not in"
    ///      ]
    ///    },
    ///    "values": {
    ///      "description": "The values to compare against.",
    ///      "examples": [
    ///        [
    ///          "1000000",
    ///          "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT",
    ///          "6"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "A single potential value to compare against the resolved `name` value.",
    ///        "examples": [
    ///          "1000000"
    ///        ],
    ///        "type": "string"
    ///      }
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SolDataParameterConditionList {
        ///The parameter name.
        pub name: ::std::string::String,
        ///The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
        pub operator: SolDataParameterConditionListOperator,
        ///The values to compare against.
        pub values: ::std::vec::Vec<::std::string::String>,
    }
    impl ::std::convert::From<&SolDataParameterConditionList> for SolDataParameterConditionList {
        fn from(value: &SolDataParameterConditionList) -> Self {
            value.clone()
        }
    }
    impl SolDataParameterConditionList {
        pub fn builder() -> builder::SolDataParameterConditionList {
            Default::default()
        }
    }
    ///The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.",
    ///  "examples": [
    ///    "in"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "in",
    ///    "not in"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolDataParameterConditionListOperator {
        #[serde(rename = "in")]
        In,
        #[serde(rename = "not in")]
        NotIn,
    }
    impl ::std::convert::From<&Self> for SolDataParameterConditionListOperator {
        fn from(value: &SolDataParameterConditionListOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolDataParameterConditionListOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::In => f.write_str("in"),
                Self::NotIn => f.write_str("not in"),
            }
        }
    }
    impl ::std::str::FromStr for SolDataParameterConditionListOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "in" => Ok(Self::In),
                "not in" => Ok(Self::NotIn),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolDataParameterConditionListOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolDataParameterConditionListOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolDataParameterConditionListOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.",
    ///  "examples": [
    ///    "=="
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "GreaterThan",
    ///    "GreaterThanOrEqual",
    ///    "LessThan",
    ///    "LessThanOrEqual",
    ///    "Equal"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolDataParameterConditionOperator {
        GreaterThan,
        GreaterThanOrEqual,
        LessThan,
        LessThanOrEqual,
        Equal,
    }
    impl ::std::convert::From<&Self> for SolDataParameterConditionOperator {
        fn from(value: &SolDataParameterConditionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolDataParameterConditionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GreaterThan => f.write_str("GreaterThan"),
                Self::GreaterThanOrEqual => f.write_str("GreaterThanOrEqual"),
                Self::LessThan => f.write_str("LessThan"),
                Self::LessThanOrEqual => f.write_str("LessThanOrEqual"),
                Self::Equal => f.write_str("Equal"),
            }
        }
    }
    impl ::std::str::FromStr for SolDataParameterConditionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "GreaterThan" => Ok(Self::GreaterThan),
                "GreaterThanOrEqual" => Ok(Self::GreaterThanOrEqual),
                "LessThan" => Ok(Self::LessThan),
                "LessThanOrEqual" => Ok(Self::LessThanOrEqual),
                "Equal" => Ok(Self::Equal),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolDataParameterConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolDataParameterConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolDataParameterConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The criterion for the message of a Solana transaction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SolMessageCriterion",
    ///  "description": "The criterion for the message of a Solana transaction.",
    ///  "type": "object",
    ///  "required": [
    ///    "match",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "match": {
    ///      "description": "A regular expression the field is matched against.",
    ///      "examples": [
    ///        "^hello ([a-z]+)$"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `solMessage`.",
    ///      "examples": [
    ///        "solMessage"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "solMessage"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SolMessageCriterion {
        ///A regular expression the field is matched against.
        #[serde(rename = "match")]
        pub match_: ::std::string::String,
        ///The type of criterion to use. This should be `solMessage`.
        #[serde(rename = "type")]
        pub type_: SolMessageCriterionType,
    }
    impl ::std::convert::From<&SolMessageCriterion> for SolMessageCriterion {
        fn from(value: &SolMessageCriterion) -> Self {
            value.clone()
        }
    }
    impl SolMessageCriterion {
        pub fn builder() -> builder::SolMessageCriterion {
            Default::default()
        }
    }
    ///The type of criterion to use. This should be `solMessage`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `solMessage`.",
    ///  "examples": [
    ///    "solMessage"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "solMessage"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolMessageCriterionType {
        #[serde(rename = "solMessage")]
        SolMessage,
    }
    impl ::std::convert::From<&Self> for SolMessageCriterionType {
        fn from(value: &SolMessageCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolMessageCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SolMessage => f.write_str("solMessage"),
            }
        }
    }
    impl ::std::str::FromStr for SolMessageCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solMessage" => Ok(Self::SolMessage),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolMessageCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolMessageCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolMessageCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The criterion for the Solana network of a transaction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SolNetworkCriterion",
    ///  "description": "The criterion for the Solana network of a transaction.",
    ///  "type": "object",
    ///  "required": [
    ///    "networks",
    ///    "operator",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "networks": {
    ///      "description": "The Solana networks that the transaction's intended network should be compared to.",
    ///      "examples": [
    ///        [
    ///          "solana-devnet",
    ///          "solana"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "The Solana network the transaction is for.",
    ///        "examples": [
    ///          "solana-devnet"
    ///        ],
    ///        "type": "string",
    ///        "enum": [
    ///          "solana-devnet",
    ///          "solana"
    ///        ]
    ///      }
    ///    },
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. The transaction's intended network will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.",
    ///      "examples": [
    ///        "in"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "in",
    ///        "not in"
    ///      ]
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `solNetwork`.",
    ///      "examples": [
    ///        "solNetwork"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "solNetwork"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SolNetworkCriterion {
        ///The Solana networks that the transaction's intended network should be compared to.
        pub networks: ::std::vec::Vec<SolNetworkCriterionNetworksItem>,
        ///The operator to use for the comparison. The transaction's intended network will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.
        pub operator: SolNetworkCriterionOperator,
        ///The type of criterion to use. This should be `solNetwork`.
        #[serde(rename = "type")]
        pub type_: SolNetworkCriterionType,
    }
    impl ::std::convert::From<&SolNetworkCriterion> for SolNetworkCriterion {
        fn from(value: &SolNetworkCriterion) -> Self {
            value.clone()
        }
    }
    impl SolNetworkCriterion {
        pub fn builder() -> builder::SolNetworkCriterion {
            Default::default()
        }
    }
    ///The Solana network the transaction is for.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Solana network the transaction is for.",
    ///  "examples": [
    ///    "solana-devnet"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "solana-devnet",
    ///    "solana"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolNetworkCriterionNetworksItem {
        #[serde(rename = "solana-devnet")]
        SolanaDevnet,
        #[serde(rename = "solana")]
        Solana,
    }
    impl ::std::convert::From<&Self> for SolNetworkCriterionNetworksItem {
        fn from(value: &SolNetworkCriterionNetworksItem) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolNetworkCriterionNetworksItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SolanaDevnet => f.write_str("solana-devnet"),
                Self::Solana => f.write_str("solana"),
            }
        }
    }
    impl ::std::str::FromStr for SolNetworkCriterionNetworksItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana-devnet" => Ok(Self::SolanaDevnet),
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolNetworkCriterionNetworksItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolNetworkCriterionNetworksItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolNetworkCriterionNetworksItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The operator to use for the comparison. The transaction's intended network will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. The transaction's intended network will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.",
    ///  "examples": [
    ///    "in"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "in",
    ///    "not in"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolNetworkCriterionOperator {
        #[serde(rename = "in")]
        In,
        #[serde(rename = "not in")]
        NotIn,
    }
    impl ::std::convert::From<&Self> for SolNetworkCriterionOperator {
        fn from(value: &SolNetworkCriterionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolNetworkCriterionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::In => f.write_str("in"),
                Self::NotIn => f.write_str("not in"),
            }
        }
    }
    impl ::std::str::FromStr for SolNetworkCriterionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "in" => Ok(Self::In),
                "not in" => Ok(Self::NotIn),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolNetworkCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolNetworkCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolNetworkCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The type of criterion to use. This should be `solNetwork`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `solNetwork`.",
    ///  "examples": [
    ///    "solNetwork"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "solNetwork"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolNetworkCriterionType {
        #[serde(rename = "solNetwork")]
        SolNetwork,
    }
    impl ::std::convert::From<&Self> for SolNetworkCriterionType {
        fn from(value: &SolNetworkCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolNetworkCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SolNetwork => f.write_str("solNetwork"),
            }
        }
    }
    impl ::std::str::FromStr for SolNetworkCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solNetwork" => Ok(Self::SolNetwork),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolNetworkCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolNetworkCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolNetworkCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The criterion for the SOL value in lamports of a native transfer instruction in a Solana transaction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SolValueCriterion",
    ///  "description": "The criterion for the SOL value in lamports of a native transfer instruction in a Solana transaction.",
    ///  "type": "object",
    ///  "required": [
    ///    "operator",
    ///    "solValue",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `solValue` field will be on the right-hand side.",
    ///      "examples": [
    ///        "<="
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "GreaterThan",
    ///        "GreaterThanOrEqual",
    ///        "LessThan",
    ///        "LessThanOrEqual",
    ///        "Equal"
    ///      ]
    ///    },
    ///    "solValue": {
    ///      "description": "The amount of SOL in lamports that the transaction instruction's `value` field should be compared to.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `solValue`.",
    ///      "examples": [
    ///        "solValue"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "solValue"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SolValueCriterion {
        ///The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `solValue` field will be on the right-hand side.
        pub operator: SolValueCriterionOperator,
        ///The amount of SOL in lamports that the transaction instruction's `value` field should be compared to.
        #[serde(rename = "solValue")]
        pub sol_value: ::std::string::String,
        ///The type of criterion to use. This should be `solValue`.
        #[serde(rename = "type")]
        pub type_: SolValueCriterionType,
    }
    impl ::std::convert::From<&SolValueCriterion> for SolValueCriterion {
        fn from(value: &SolValueCriterion) -> Self {
            value.clone()
        }
    }
    impl SolValueCriterion {
        pub fn builder() -> builder::SolValueCriterion {
            Default::default()
        }
    }
    ///The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `solValue` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `solValue` field will be on the right-hand side.",
    ///  "examples": [
    ///    "<="
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "GreaterThan",
    ///    "GreaterThanOrEqual",
    ///    "LessThan",
    ///    "LessThanOrEqual",
    ///    "Equal"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolValueCriterionOperator {
        GreaterThan,
        GreaterThanOrEqual,
        LessThan,
        LessThanOrEqual,
        Equal,
    }
    impl ::std::convert::From<&Self> for SolValueCriterionOperator {
        fn from(value: &SolValueCriterionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolValueCriterionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GreaterThan => f.write_str("GreaterThan"),
                Self::GreaterThanOrEqual => f.write_str("GreaterThanOrEqual"),
                Self::LessThan => f.write_str("LessThan"),
                Self::LessThanOrEqual => f.write_str("LessThanOrEqual"),
                Self::Equal => f.write_str("Equal"),
            }
        }
    }
    impl ::std::str::FromStr for SolValueCriterionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "GreaterThan" => Ok(Self::GreaterThan),
                "GreaterThanOrEqual" => Ok(Self::GreaterThanOrEqual),
                "LessThan" => Ok(Self::LessThan),
                "LessThanOrEqual" => Ok(Self::LessThanOrEqual),
                "Equal" => Ok(Self::Equal),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolValueCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolValueCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolValueCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The type of criterion to use. This should be `solValue`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `solValue`.",
    ///  "examples": [
    ///    "solValue"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "solValue"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolValueCriterionType {
        #[serde(rename = "solValue")]
        SolValue,
    }
    impl ::std::convert::From<&Self> for SolValueCriterionType {
        fn from(value: &SolValueCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolValueCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SolValue => f.write_str("solValue"),
            }
        }
    }
    impl ::std::str::FromStr for SolValueCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solValue" => Ok(Self::SolValue),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolValueCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolValueCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolValueCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`SolanaAccount`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The base58 encoded Solana address.",
    ///      "examples": [
    ///        "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///    },
    ///    "createdAt": {
    ///      "description": "The ISO 8601 UTC timestamp at which the account was created.",
    ///      "examples": [
    ///        "2025-03-25T12:00:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "name": {
    ///      "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names are guaranteed to be unique across all Solana accounts in the developer's CDP Project.",
    ///      "examples": [
    ///        "my-account"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///    },
    ///    "policies": {
    ///      "description": "The list of policy IDs that apply to the account. This will include both the project-level policy and the account-level policy, if one exists.",
    ///      "examples": [
    ///        [
    ///          "123e4567-e89b-12d3-a456-426614174000"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
    ///      },
    ///      "x-audience": "public"
    ///    },
    ///    "updatedAt": {
    ///      "description": "The ISO 8601 UTC timestamp at which the account was last updated.",
    ///      "examples": [
    ///        "2025-03-26T12:00:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SolanaAccount {
        ///The base58 encoded Solana address.
        pub address: SolanaAccountAddress,
        ///The ISO 8601 UTC timestamp at which the account was created.
        #[serde(
            rename = "createdAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub created_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        /**An optional name for the account.
        Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
        Account names are guaranteed to be unique across all Solana accounts in the developer's CDP Project.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<SolanaAccountName>,
        ///The list of policy IDs that apply to the account. This will include both the project-level policy and the account-level policy, if one exists.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub policies: ::std::vec::Vec<SolanaAccountPoliciesItem>,
        ///The ISO 8601 UTC timestamp at which the account was last updated.
        #[serde(
            rename = "updatedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub updated_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    }
    impl ::std::convert::From<&SolanaAccount> for SolanaAccount {
        fn from(value: &SolanaAccount) -> Self {
            value.clone()
        }
    }
    impl SolanaAccount {
        pub fn builder() -> builder::SolanaAccount {
            Default::default()
        }
    }
    ///The base58 encoded Solana address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The base58 encoded Solana address.",
    ///  "examples": [
    ///    "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SolanaAccountAddress(::std::string::String);
    impl ::std::ops::Deref for SolanaAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SolanaAccountAddress> for ::std::string::String {
        fn from(value: SolanaAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SolanaAccountAddress> for SolanaAccountAddress {
        fn from(value: &SolanaAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SolanaAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SolanaAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    /**An optional name for the account.
    Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
    Account names are guaranteed to be unique across all Solana accounts in the developer's CDP Project.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names are guaranteed to be unique across all Solana accounts in the developer's CDP Project.",
    ///  "examples": [
    ///    "my-account"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SolanaAccountName(::std::string::String);
    impl ::std::ops::Deref for SolanaAccountName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SolanaAccountName> for ::std::string::String {
        fn from(value: SolanaAccountName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SolanaAccountName> for SolanaAccountName {
        fn from(value: &SolanaAccountName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SolanaAccountName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaAccountName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaAccountName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaAccountName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SolanaAccountName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SolanaAccountPoliciesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SolanaAccountPoliciesItem(::std::string::String);
    impl ::std::ops::Deref for SolanaAccountPoliciesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SolanaAccountPoliciesItem> for ::std::string::String {
        fn from(value: SolanaAccountPoliciesItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SolanaAccountPoliciesItem> for SolanaAccountPoliciesItem {
        fn from(value: &SolanaAccountPoliciesItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SolanaAccountPoliciesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(
                || {
                    ::regress::Regex::new(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
                    )
                    .unwrap()
                },
            );
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaAccountPoliciesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaAccountPoliciesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaAccountPoliciesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SolanaAccountPoliciesItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///General information about a Solana token. Includes the mint address, and other identifying information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "General information about a Solana token. Includes the mint address, and other identifying information.",
    ///  "examples": [
    ///    {
    ///      "mintAddress": "So11111111111111111111111111111111111111111",
    ///      "name": "Solana",
    ///      "symbol": "SOL"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "mintAddress"
    ///  ],
    ///  "properties": {
    ///    "mintAddress": {
    ///      "description": "The mint address of the token.\nFor native SOL, the mint address is `So11111111111111111111111111111111111111111`. For SPL tokens, this is the mint address where the token is defined.",
    ///      "examples": [
    ///        "So11111111111111111111111111111111111111111"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///    },
    ///    "name": {
    ///      "description": "The name of this token (ex: \"Solana\", \"USD Coin\", \"Raydium\").\nThe token name is not unique. It is possible for two different tokens to have the same name.\nFor the native SOL token, this name is \"Solana\". For SPL tokens, this name is defined in the token's metadata.\nNot all tokens have a name. This field will only be populated when the token has metadata available.",
    ///      "examples": [
    ///        "Solana"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "description": "The symbol of this token (ex: SOL, USDC, RAY).\nThe token symbol is not unique. It is possible for two different tokens to have the same symbol.\nFor the native SOL token, this symbol is \"SOL\". For SPL tokens, this symbol is defined in the token's metadata.\nNot all tokens have a symbol. This field will only be populated when the token has metadata available.",
    ///      "examples": [
    ///        "SOL"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SolanaToken {
        /**The mint address of the token.
        For native SOL, the mint address is `So11111111111111111111111111111111111111111`. For SPL tokens, this is the mint address where the token is defined.*/
        #[serde(rename = "mintAddress")]
        pub mint_address: SolanaTokenMintAddress,
        /**The name of this token (ex: "Solana", "USD Coin", "Raydium").
        The token name is not unique. It is possible for two different tokens to have the same name.
        For the native SOL token, this name is "Solana". For SPL tokens, this name is defined in the token's metadata.
        Not all tokens have a name. This field will only be populated when the token has metadata available.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        /**The symbol of this token (ex: SOL, USDC, RAY).
        The token symbol is not unique. It is possible for two different tokens to have the same symbol.
        For the native SOL token, this symbol is "SOL". For SPL tokens, this symbol is defined in the token's metadata.
        Not all tokens have a symbol. This field will only be populated when the token has metadata available.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub symbol: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&SolanaToken> for SolanaToken {
        fn from(value: &SolanaToken) -> Self {
            value.clone()
        }
    }
    impl SolanaToken {
        pub fn builder() -> builder::SolanaToken {
            Default::default()
        }
    }
    ///Amount of a given Solana token.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Amount of a given Solana token.",
    ///  "examples": [
    ///    {
    ///      "amount": "1250000000",
    ///      "decimals": 9
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "decimals"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "The amount is denominated in the smallest indivisible unit of the token. For SOL, the smallest indivisible unit is lamports (10^-9 SOL). For SPL tokens, the smallest unit is defined by the token's decimals configuration.",
    ///      "examples": [
    ///        "1250000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[0-9]+$"
    ///    },
    ///    "decimals": {
    ///      "description": "'decimals' is the exponential value N that satisfies the equation `amount * 10^-N = standard_denomination`. The standard denomination is the most commonly used denomination for the token.\n- For native SOL, `decimals` is 9 (1 SOL = 10^9 lamports). - For SPL tokens, `decimals` is defined in the token's mint configuration.",
    ///      "examples": [
    ///        9
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SolanaTokenAmount {
        ///The amount is denominated in the smallest indivisible unit of the token. For SOL, the smallest indivisible unit is lamports (10^-9 SOL). For SPL tokens, the smallest unit is defined by the token's decimals configuration.
        pub amount: SolanaTokenAmountAmount,
        /**'decimals' is the exponential value N that satisfies the equation `amount * 10^-N = standard_denomination`. The standard denomination is the most commonly used denomination for the token.
        - For native SOL, `decimals` is 9 (1 SOL = 10^9 lamports). - For SPL tokens, `decimals` is defined in the token's mint configuration.*/
        pub decimals: i64,
    }
    impl ::std::convert::From<&SolanaTokenAmount> for SolanaTokenAmount {
        fn from(value: &SolanaTokenAmount) -> Self {
            value.clone()
        }
    }
    impl SolanaTokenAmount {
        pub fn builder() -> builder::SolanaTokenAmount {
            Default::default()
        }
    }
    ///The amount is denominated in the smallest indivisible unit of the token. For SOL, the smallest indivisible unit is lamports (10^-9 SOL). For SPL tokens, the smallest unit is defined by the token's decimals configuration.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount is denominated in the smallest indivisible unit of the token. For SOL, the smallest indivisible unit is lamports (10^-9 SOL). For SPL tokens, the smallest unit is defined by the token's decimals configuration.",
    ///  "examples": [
    ///    "1250000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[0-9]+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SolanaTokenAmountAmount(::std::string::String);
    impl ::std::ops::Deref for SolanaTokenAmountAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SolanaTokenAmountAmount> for ::std::string::String {
        fn from(value: SolanaTokenAmountAmount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SolanaTokenAmountAmount> for SolanaTokenAmountAmount {
        fn from(value: &SolanaTokenAmountAmount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SolanaTokenAmountAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^[0-9]+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[0-9]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaTokenAmountAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaTokenAmountAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaTokenAmountAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SolanaTokenAmountAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`SolanaTokenBalance`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "token"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/SolanaTokenAmount"
    ///    },
    ///    "token": {
    ///      "$ref": "#/components/schemas/SolanaToken"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SolanaTokenBalance {
        pub amount: SolanaTokenAmount,
        pub token: SolanaToken,
    }
    impl ::std::convert::From<&SolanaTokenBalance> for SolanaTokenBalance {
        fn from(value: &SolanaTokenBalance) -> Self {
            value.clone()
        }
    }
    impl SolanaTokenBalance {
        pub fn builder() -> builder::SolanaTokenBalance {
            Default::default()
        }
    }
    /**The mint address of the token.
    For native SOL, the mint address is `So11111111111111111111111111111111111111111`. For SPL tokens, this is the mint address where the token is defined.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The mint address of the token.\nFor native SOL, the mint address is `So11111111111111111111111111111111111111111`. For SPL tokens, this is the mint address where the token is defined.",
    ///  "examples": [
    ///    "So11111111111111111111111111111111111111111"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SolanaTokenMintAddress(::std::string::String);
    impl ::std::ops::Deref for SolanaTokenMintAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SolanaTokenMintAddress> for ::std::string::String {
        fn from(value: SolanaTokenMintAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SolanaTokenMintAddress> for SolanaTokenMintAddress {
        fn from(value: &SolanaTokenMintAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SolanaTokenMintAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaTokenMintAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaTokenMintAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaTokenMintAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SolanaTokenMintAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The core spend permission.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The core spend permission.",
    ///  "examples": [
    ///    {
    ///      "account": "0xd53Ee96438383Bb1eff07958D110B81363E9Ab47",
    ///      "allowance": "1000000000000000000",
    ///      "end": "281474976710655",
    ///      "extraData": "0x",
    ///      "period": "86400",
    ///      "salt": "0",
    ///      "spender": "0x9Fb909eA400c2b8D99Be292DADf07e63B814527c",
    ///      "start": "0",
    ///      "token": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "account",
    ///    "allowance",
    ///    "end",
    ///    "extraData",
    ///    "period",
    ///    "salt",
    ///    "spender",
    ///    "start",
    ///    "token"
    ///  ],
    ///  "properties": {
    ///    "account": {
    ///      "description": "Smart account this spend permission is valid for.",
    ///      "examples": [
    ///        "0xd53Ee96438383Bb1eff07958D110B81363E9Ab47"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    },
    ///    "allowance": {
    ///      "description": "Maximum allowed value to spend, in atomic units for the specified token, within each period.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "end": {
    ///      "description": "The expiration time for this spend permission, in Unix seconds.",
    ///      "examples": [
    ///        "281474976710655"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "extraData": {
    ///      "description": "Arbitrary data to include in the permission.",
    ///      "examples": [
    ///        "0x"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "period": {
    ///      "description": "Time duration for resetting used allowance on a recurring basis (seconds).",
    ///      "examples": [
    ///        "86400"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "salt": {
    ///      "description": "An arbitrary salt to differentiate unique spend permissions with otherwise identical data.",
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "spender": {
    ///      "description": "Entity that can spend account's tokens.",
    ///      "examples": [
    ///        "0x9Fb909eA400c2b8D99Be292DADf07e63B814527c"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    },
    ///    "start": {
    ///      "description": "The start time for this spend permission, in Unix seconds.",
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "token": {
    ///      "description": "Token address (ERC-7528 native token address or ERC-20 contract).",
    ///      "examples": [
    ///        "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SpendPermission {
        ///Smart account this spend permission is valid for.
        pub account: SpendPermissionAccount,
        ///Maximum allowed value to spend, in atomic units for the specified token, within each period.
        pub allowance: ::std::string::String,
        ///The expiration time for this spend permission, in Unix seconds.
        pub end: ::std::string::String,
        ///Arbitrary data to include in the permission.
        #[serde(rename = "extraData")]
        pub extra_data: ::std::string::String,
        ///Time duration for resetting used allowance on a recurring basis (seconds).
        pub period: ::std::string::String,
        ///An arbitrary salt to differentiate unique spend permissions with otherwise identical data.
        pub salt: ::std::string::String,
        ///Entity that can spend account's tokens.
        pub spender: SpendPermissionSpender,
        ///The start time for this spend permission, in Unix seconds.
        pub start: ::std::string::String,
        ///Token address (ERC-7528 native token address or ERC-20 contract).
        pub token: SpendPermissionToken,
    }
    impl ::std::convert::From<&SpendPermission> for SpendPermission {
        fn from(value: &SpendPermission) -> Self {
            value.clone()
        }
    }
    impl SpendPermission {
        pub fn builder() -> builder::SpendPermission {
            Default::default()
        }
    }
    ///Smart account this spend permission is valid for.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Smart account this spend permission is valid for.",
    ///  "examples": [
    ///    "0xd53Ee96438383Bb1eff07958D110B81363E9Ab47"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SpendPermissionAccount(::std::string::String);
    impl ::std::ops::Deref for SpendPermissionAccount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SpendPermissionAccount> for ::std::string::String {
        fn from(value: SpendPermissionAccount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SpendPermissionAccount> for SpendPermissionAccount {
        fn from(value: &SpendPermissionAccount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SpendPermissionAccount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SpendPermissionAccount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SpendPermissionAccount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SpendPermissionAccount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SpendPermissionAccount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The network the spend permission is on.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The network the spend permission is on.",
    ///  "examples": [
    ///    "base"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "base",
    ///    "base-sepolia",
    ///    "ethereum",
    ///    "ethereum-sepolia",
    ///    "optimism",
    ///    "arbitrum",
    ///    "avalanche",
    ///    "polygon"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SpendPermissionNetwork {
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "base-sepolia")]
        BaseSepolia,
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "ethereum-sepolia")]
        EthereumSepolia,
        #[serde(rename = "optimism")]
        Optimism,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "avalanche")]
        Avalanche,
        #[serde(rename = "polygon")]
        Polygon,
    }
    impl ::std::convert::From<&Self> for SpendPermissionNetwork {
        fn from(value: &SpendPermissionNetwork) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SpendPermissionNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base => f.write_str("base"),
                Self::BaseSepolia => f.write_str("base-sepolia"),
                Self::Ethereum => f.write_str("ethereum"),
                Self::EthereumSepolia => f.write_str("ethereum-sepolia"),
                Self::Optimism => f.write_str("optimism"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Avalanche => f.write_str("avalanche"),
                Self::Polygon => f.write_str("polygon"),
            }
        }
    }
    impl ::std::str::FromStr for SpendPermissionNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base" => Ok(Self::Base),
                "base-sepolia" => Ok(Self::BaseSepolia),
                "ethereum" => Ok(Self::Ethereum),
                "ethereum-sepolia" => Ok(Self::EthereumSepolia),
                "optimism" => Ok(Self::Optimism),
                "arbitrum" => Ok(Self::Arbitrum),
                "avalanche" => Ok(Self::Avalanche),
                "polygon" => Ok(Self::Polygon),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SpendPermissionNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SpendPermissionNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SpendPermissionNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`SpendPermissionResponseObject`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "createdAt",
    ///    "network",
    ///    "permission",
    ///    "permissionHash",
    ///    "revoked"
    ///  ],
    ///  "properties": {
    ///    "createdAt": {
    ///      "description": "The UTC ISO 8601 timestamp when the permission was created.",
    ///      "examples": [
    ///        "2025-03-25T12:00:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "network": {
    ///      "$ref": "#/components/schemas/SpendPermissionNetwork"
    ///    },
    ///    "permission": {
    ///      "$ref": "#/components/schemas/SpendPermission"
    ///    },
    ///    "permissionHash": {
    ///      "description": "Unique hash identifier for this permission.",
    ///      "examples": [
    ///        "0x62bc94756bb6221a7913beab6024171fc60d3380fdc06759bfac76e8ccb3f63d"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "revoked": {
    ///      "description": "Whether this permission has been revoked.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "revokedAt": {
    ///      "description": "The UTC ISO 8601 timestamp when the permission was revoked (if applicable).",
    ///      "examples": [
    ///        "2025-03-25T12:00:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SpendPermissionResponseObject {
        ///The UTC ISO 8601 timestamp when the permission was created.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub network: SpendPermissionNetwork,
        pub permission: SpendPermission,
        ///Unique hash identifier for this permission.
        #[serde(rename = "permissionHash")]
        pub permission_hash: ::std::string::String,
        ///Whether this permission has been revoked.
        pub revoked: bool,
        ///The UTC ISO 8601 timestamp when the permission was revoked (if applicable).
        #[serde(
            rename = "revokedAt",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub revoked_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    }
    impl ::std::convert::From<&SpendPermissionResponseObject> for SpendPermissionResponseObject {
        fn from(value: &SpendPermissionResponseObject) -> Self {
            value.clone()
        }
    }
    impl SpendPermissionResponseObject {
        pub fn builder() -> builder::SpendPermissionResponseObject {
            Default::default()
        }
    }
    ///Entity that can spend account's tokens.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Entity that can spend account's tokens.",
    ///  "examples": [
    ///    "0x9Fb909eA400c2b8D99Be292DADf07e63B814527c"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SpendPermissionSpender(::std::string::String);
    impl ::std::ops::Deref for SpendPermissionSpender {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SpendPermissionSpender> for ::std::string::String {
        fn from(value: SpendPermissionSpender) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SpendPermissionSpender> for SpendPermissionSpender {
        fn from(value: &SpendPermissionSpender) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SpendPermissionSpender {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SpendPermissionSpender {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SpendPermissionSpender {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SpendPermissionSpender {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SpendPermissionSpender {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///Token address (ERC-7528 native token address or ERC-20 contract).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Token address (ERC-7528 native token address or ERC-20 contract).",
    ///  "examples": [
    ///    "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SpendPermissionToken(::std::string::String);
    impl ::std::ops::Deref for SpendPermissionToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SpendPermissionToken> for ::std::string::String {
        fn from(value: SpendPermissionToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SpendPermissionToken> for SpendPermissionToken {
        fn from(value: &SpendPermissionToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SpendPermissionToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SpendPermissionToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SpendPermissionToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SpendPermissionToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SpendPermissionToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The criterion for the recipient addresses of a Solana transaction's SPL token transfer instructions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SplAddressCriterion",
    ///  "description": "The criterion for the recipient addresses of a Solana transaction's SPL token transfer instructions.",
    ///  "type": "object",
    ///  "required": [
    ///    "addresses",
    ///    "operator",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "addresses": {
    ///      "description": "The Solana addresses that are compared to the list of SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.",
    ///      "examples": [
    ///        [
    ///          "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "description": "The Solana address that is compared to the list of SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.",
    ///        "type": "string",
    ///        "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///      }
    ///    },
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. Each of the SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.",
    ///      "examples": [
    ///        "in"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "in",
    ///        "not in"
    ///      ]
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `splAddress`.",
    ///      "examples": [
    ///        "splAddress"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "splAddress"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SplAddressCriterion {
        ///The Solana addresses that are compared to the list of SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.
        pub addresses: ::std::vec::Vec<SplAddressCriterionAddressesItem>,
        ///The operator to use for the comparison. Each of the SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
        pub operator: SplAddressCriterionOperator,
        ///The type of criterion to use. This should be `splAddress`.
        #[serde(rename = "type")]
        pub type_: SplAddressCriterionType,
    }
    impl ::std::convert::From<&SplAddressCriterion> for SplAddressCriterion {
        fn from(value: &SplAddressCriterion) -> Self {
            value.clone()
        }
    }
    impl SplAddressCriterion {
        pub fn builder() -> builder::SplAddressCriterion {
            Default::default()
        }
    }
    ///The Solana address that is compared to the list of SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Solana address that is compared to the list of SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.",
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SplAddressCriterionAddressesItem(::std::string::String);
    impl ::std::ops::Deref for SplAddressCriterionAddressesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SplAddressCriterionAddressesItem> for ::std::string::String {
        fn from(value: SplAddressCriterionAddressesItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SplAddressCriterionAddressesItem> for SplAddressCriterionAddressesItem {
        fn from(value: &SplAddressCriterionAddressesItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SplAddressCriterionAddressesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SplAddressCriterionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SplAddressCriterionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SplAddressCriterionAddressesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SplAddressCriterionAddressesItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The operator to use for the comparison. Each of the SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. Each of the SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.",
    ///  "examples": [
    ///    "in"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "in",
    ///    "not in"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SplAddressCriterionOperator {
        #[serde(rename = "in")]
        In,
        #[serde(rename = "not in")]
        NotIn,
    }
    impl ::std::convert::From<&Self> for SplAddressCriterionOperator {
        fn from(value: &SplAddressCriterionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SplAddressCriterionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::In => f.write_str("in"),
                Self::NotIn => f.write_str("not in"),
            }
        }
    }
    impl ::std::str::FromStr for SplAddressCriterionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "in" => Ok(Self::In),
                "not in" => Ok(Self::NotIn),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SplAddressCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SplAddressCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SplAddressCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The type of criterion to use. This should be `splAddress`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `splAddress`.",
    ///  "examples": [
    ///    "splAddress"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "splAddress"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SplAddressCriterionType {
        #[serde(rename = "splAddress")]
        SplAddress,
    }
    impl ::std::convert::From<&Self> for SplAddressCriterionType {
        fn from(value: &SplAddressCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SplAddressCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SplAddress => f.write_str("splAddress"),
            }
        }
    }
    impl ::std::str::FromStr for SplAddressCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "splAddress" => Ok(Self::SplAddress),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SplAddressCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SplAddressCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SplAddressCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The criterion for the SPL token value of a SPL token transfer instruction in a Solana transaction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SplValueCriterion",
    ///  "description": "The criterion for the SPL token value of a SPL token transfer instruction in a Solana transaction.",
    ///  "type": "object",
    ///  "required": [
    ///    "operator",
    ///    "splValue",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "operator": {
    ///      "description": "The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `splValue` field will be on the right-hand side.",
    ///      "examples": [
    ///        "<="
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "GreaterThan",
    ///        "GreaterThanOrEqual",
    ///        "LessThan",
    ///        "LessThanOrEqual",
    ///        "Equal"
    ///      ]
    ///    },
    ///    "splValue": {
    ///      "description": "The amount of the SPL token that the transaction instruction's `value` field should be compared to.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of criterion to use. This should be `splValue`.",
    ///      "examples": [
    ///        "splValue"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "splValue"
    ///      ]
    ///    }
    ///  },
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SplValueCriterion {
        ///The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `splValue` field will be on the right-hand side.
        pub operator: SplValueCriterionOperator,
        ///The amount of the SPL token that the transaction instruction's `value` field should be compared to.
        #[serde(rename = "splValue")]
        pub spl_value: ::std::string::String,
        ///The type of criterion to use. This should be `splValue`.
        #[serde(rename = "type")]
        pub type_: SplValueCriterionType,
    }
    impl ::std::convert::From<&SplValueCriterion> for SplValueCriterion {
        fn from(value: &SplValueCriterion) -> Self {
            value.clone()
        }
    }
    impl SplValueCriterion {
        pub fn builder() -> builder::SplValueCriterion {
            Default::default()
        }
    }
    ///The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `splValue` field will be on the right-hand side.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `splValue` field will be on the right-hand side.",
    ///  "examples": [
    ///    "<="
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "GreaterThan",
    ///    "GreaterThanOrEqual",
    ///    "LessThan",
    ///    "LessThanOrEqual",
    ///    "Equal"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SplValueCriterionOperator {
        GreaterThan,
        GreaterThanOrEqual,
        LessThan,
        LessThanOrEqual,
        Equal,
    }
    impl ::std::convert::From<&Self> for SplValueCriterionOperator {
        fn from(value: &SplValueCriterionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SplValueCriterionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GreaterThan => f.write_str("GreaterThan"),
                Self::GreaterThanOrEqual => f.write_str("GreaterThanOrEqual"),
                Self::LessThan => f.write_str("LessThan"),
                Self::LessThanOrEqual => f.write_str("LessThanOrEqual"),
                Self::Equal => f.write_str("Equal"),
            }
        }
    }
    impl ::std::str::FromStr for SplValueCriterionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "GreaterThan" => Ok(Self::GreaterThan),
                "GreaterThanOrEqual" => Ok(Self::GreaterThanOrEqual),
                "LessThan" => Ok(Self::LessThan),
                "LessThanOrEqual" => Ok(Self::LessThanOrEqual),
                "Equal" => Ok(Self::Equal),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SplValueCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SplValueCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SplValueCriterionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The type of criterion to use. This should be `splValue`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of criterion to use. This should be `splValue`.",
    ///  "examples": [
    ///    "splValue"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "splValue"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SplValueCriterionType {
        #[serde(rename = "splValue")]
        SplValue,
    }
    impl ::std::convert::From<&Self> for SplValueCriterionType {
        fn from(value: &SplValueCriterionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SplValueCriterionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SplValue => f.write_str("splValue"),
            }
        }
    }
    impl ::std::str::FromStr for SplValueCriterionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "splValue" => Ok(Self::SplValue),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SplValueCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SplValueCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SplValueCriterionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`SupportedX402PaymentKindsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "extensions",
    ///    "kinds",
    ///    "signers"
    ///  ],
    ///  "properties": {
    ///    "extensions": {
    ///      "description": "The list of supported x402 extensions.",
    ///      "examples": [
    ///        [
    ///          "bazaar"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "kinds": {
    ///      "description": "The list of supported payment kinds.",
    ///      "examples": [
    ///        [
    ///          {
    ///            "network": "base",
    ///            "scheme": "exact",
    ///            "x402Version": 1
    ///          },
    ///          {
    ///            "network": "base-sepolia",
    ///            "scheme": "exact",
    ///            "x402Version": 1
    ///          },
    ///          {
    ///            "network": "solana",
    ///            "scheme": "exact",
    ///            "x402Version": 1
    ///          },
    ///          {
    ///            "network": "solana-devnet",
    ///            "scheme": "exact",
    ///            "x402Version": 1
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/x402SupportedPaymentKind"
    ///      }
    ///    },
    ///    "signers": {
    ///      "description": "A map of CAIP-2 network or protocol family patterns to their supported signer addresses.",
    ///      "examples": [
    ///        {
    ///          "eip155:*": [
    ///            "0x1234567890abcdef1234567890abcdef12345678",
    ///            "0xabcdef1234567890abcdef1234567890abcdef12"
    ///          ],
    ///          "solana:*": [
    ///            "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d"
    ///          ]
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "array",
    ///        "items": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SupportedX402PaymentKindsResponse {
        ///The list of supported x402 extensions.
        pub extensions: ::std::vec::Vec<::std::string::String>,
        ///The list of supported payment kinds.
        pub kinds: ::std::vec::Vec<X402SupportedPaymentKind>,
        ///A map of CAIP-2 network or protocol family patterns to their supported signer addresses.
        pub signers: ::std::collections::HashMap<
            ::std::string::String,
            ::std::vec::Vec<::std::string::String>,
        >,
    }
    impl ::std::convert::From<&SupportedX402PaymentKindsResponse>
        for SupportedX402PaymentKindsResponse
    {
        fn from(value: &SupportedX402PaymentKindsResponse) -> Self {
            value.clone()
        }
    }
    impl SupportedX402PaymentKindsResponse {
        pub fn builder() -> builder::SupportedX402PaymentKindsResponse {
            Default::default()
        }
    }
    ///`SwapUnavailableResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SwapUnavailableResponse",
    ///  "examples": [
    ///    {
    ///      "liquidityAvailable": false
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "liquidityAvailable"
    ///  ],
    ///  "properties": {
    ///    "liquidityAvailable": {
    ///      "description": "Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean",
    ///      "enum": [
    ///        false
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SwapUnavailableResponse {
        ///Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
        #[serde(rename = "liquidityAvailable")]
        pub liquidity_available: bool,
    }
    impl ::std::convert::From<&SwapUnavailableResponse> for SwapUnavailableResponse {
        fn from(value: &SwapUnavailableResponse) -> Self {
            value.clone()
        }
    }
    impl SwapUnavailableResponse {
        pub fn builder() -> builder::SwapUnavailableResponse {
            Default::default()
        }
    }
    ///The 0x-prefixed address that holds the `fromToken` balance and has the `Permit2` allowance set for the swap.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed address that holds the `fromToken` balance and has the `Permit2` allowance set for the swap.",
    ///  "examples": [
    ///    "0xAc0974bec39a17e36ba4a6b4d238ff944bacb478"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct Taker(::std::string::String);
    impl ::std::ops::Deref for Taker {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<Taker> for ::std::string::String {
        fn from(value: Taker) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&Taker> for Taker {
        fn from(value: &Taker) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for Taker {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for Taker {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for Taker {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for Taker {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for Taker {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed contract address of the token to receive.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed contract address of the token to receive.",
    ///  "examples": [
    ///    "0x7F5c764cBc14f9669B88837ca1490cCa17c31607"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ToToken(::std::string::String);
    impl ::std::ops::Deref for ToToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<ToToken> for ::std::string::String {
        fn from(value: ToToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&ToToken> for ToToken {
        fn from(value: &ToToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for ToToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for ToToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ToToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ToToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ToToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///General information about a token. Includes the type, the network, and other identifying information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "General information about a token. Includes the type, the network, and other identifying information.",
    ///  "examples": [
    ///    {
    ///      "contractAddress": "0x1234567890123456789012345678901234567890",
    ///      "name": "Ether",
    ///      "network": "base",
    ///      "symbol": "ETH"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "contractAddress",
    ///    "network"
    ///  ],
    ///  "properties": {
    ///    "contractAddress": {
    ///      "description": "The contract address of the token.\nFor Ether, the contract address is `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` per [EIP-7528](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7528.md). For ERC-20 tokens, this is the contract address where the token is deployed.",
    ///      "examples": [
    ///        "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]{40}$"
    ///    },
    ///    "name": {
    ///      "description": "The name of this token (ex: \"Solana\", \"Ether\", \"USD Coin\").\nThe token name is not unique. It is possible for two different tokens to have the same name.\nFor native gas tokens, this name is defined via convention. As an example, for ETH on Ethereum mainnet, the name is \"Ether\". For ERC-20 tokens, this name is defined via configuration. `name` will be the string returned by `function name() public view returns (string)` on the underlying token contract.\nNot all tokens have a name, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#name). This field will only be populated when the token's underlying ERC-20 contract has a `name()` function.\nFurther, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.",
    ///      "examples": [
    ///        "Ether"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "network": {
    ///      "$ref": "#/components/schemas/ListEvmTokenBalancesNetwork"
    ///    },
    ///    "symbol": {
    ///      "description": "The symbol of this token (ex: SOL, ETH, USDC).\nThe token symbol is not unique. It is possible for two different tokens to have the same symbol.\nFor native gas tokens, this symbol is defined via convention. As an example, for ETH on Ethereum mainnet, the symbol is \"ETH\". For ERC-20 tokens, this symbol is defined via configuration. `symbol` will be the string returned by `function symbol() public view returns (string)` on the underlying token contract.\nNot all tokens have a symbol, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#symbol). This field will only be populated when the token's underlying ERC-20 contract has a `symbol()` function.\nFurther, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.",
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct Token {
        /**The contract address of the token.
        For Ether, the contract address is `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` per [EIP-7528](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7528.md). For ERC-20 tokens, this is the contract address where the token is deployed.*/
        #[serde(rename = "contractAddress")]
        pub contract_address: TokenContractAddress,
        /**The name of this token (ex: "Solana", "Ether", "USD Coin").
        The token name is not unique. It is possible for two different tokens to have the same name.
        For native gas tokens, this name is defined via convention. As an example, for ETH on Ethereum mainnet, the name is "Ether". For ERC-20 tokens, this name is defined via configuration. `name` will be the string returned by `function name() public view returns (string)` on the underlying token contract.
        Not all tokens have a name, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#name). This field will only be populated when the token's underlying ERC-20 contract has a `name()` function.
        Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        pub network: ListEvmTokenBalancesNetwork,
        /**The symbol of this token (ex: SOL, ETH, USDC).
        The token symbol is not unique. It is possible for two different tokens to have the same symbol.
        For native gas tokens, this symbol is defined via convention. As an example, for ETH on Ethereum mainnet, the symbol is "ETH". For ERC-20 tokens, this symbol is defined via configuration. `symbol` will be the string returned by `function symbol() public view returns (string)` on the underlying token contract.
        Not all tokens have a symbol, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#symbol). This field will only be populated when the token's underlying ERC-20 contract has a `symbol()` function.
        Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub symbol: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&Token> for Token {
        fn from(value: &Token) -> Self {
            value.clone()
        }
    }
    impl Token {
        pub fn builder() -> builder::Token {
            Default::default()
        }
    }
    ///Amount of a given token.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Amount of a given token.",
    ///  "examples": [
    ///    {
    ///      "amount": "125000000000000000000",
    ///      "decimals": 18
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "decimals"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "The amount is denominated in the smallest indivisible unit of the token. For ETH, the smallest indivisible unit is Wei (10^-18 ETH). For ERC-20s, the smallest unit is the unit returned from `function totalSupply() public view returns (uint256)`.",
    ///      "examples": [
    ///        "1250000000000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[0-9]+$"
    ///    },
    ///    "decimals": {
    ///      "description": "'decimals' is the exponential value N that satisfies the equation `amount * 10^-N = standard_denomination`. The standard denomination is the most commonly used denomination for the token.\n- In the case of the native gas token, `decimals` is defined via convention. As an example, for ETH of Ethereum mainnet, the standard denomination is 10^-18 the smallest denomination (Wei). As such, for ETH on Ethereum mainnet, `decimals` is 18. - In the case of ERC-20 tokens, `decimals` is defined via configuration. `decimals` will be the number returned by `function decimals() public view returns (uint8)` on the underlying token contract.\nNot all tokens have a `decimals` field, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#decimals). This field will be left empty if the underlying token contract doesn't implement `decimals`.\nFurther, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.",
    ///      "examples": [
    ///        18
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TokenAmount {
        ///The amount is denominated in the smallest indivisible unit of the token. For ETH, the smallest indivisible unit is Wei (10^-18 ETH). For ERC-20s, the smallest unit is the unit returned from `function totalSupply() public view returns (uint256)`.
        pub amount: TokenAmountAmount,
        /**'decimals' is the exponential value N that satisfies the equation `amount * 10^-N = standard_denomination`. The standard denomination is the most commonly used denomination for the token.
        - In the case of the native gas token, `decimals` is defined via convention. As an example, for ETH of Ethereum mainnet, the standard denomination is 10^-18 the smallest denomination (Wei). As such, for ETH on Ethereum mainnet, `decimals` is 18. - In the case of ERC-20 tokens, `decimals` is defined via configuration. `decimals` will be the number returned by `function decimals() public view returns (uint8)` on the underlying token contract.
        Not all tokens have a `decimals` field, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#decimals). This field will be left empty if the underlying token contract doesn't implement `decimals`.
        Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.*/
        pub decimals: i64,
    }
    impl ::std::convert::From<&TokenAmount> for TokenAmount {
        fn from(value: &TokenAmount) -> Self {
            value.clone()
        }
    }
    impl TokenAmount {
        pub fn builder() -> builder::TokenAmount {
            Default::default()
        }
    }
    ///The amount is denominated in the smallest indivisible unit of the token. For ETH, the smallest indivisible unit is Wei (10^-18 ETH). For ERC-20s, the smallest unit is the unit returned from `function totalSupply() public view returns (uint256)`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The amount is denominated in the smallest indivisible unit of the token. For ETH, the smallest indivisible unit is Wei (10^-18 ETH). For ERC-20s, the smallest unit is the unit returned from `function totalSupply() public view returns (uint256)`.",
    ///  "examples": [
    ///    "1250000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[0-9]+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct TokenAmountAmount(::std::string::String);
    impl ::std::ops::Deref for TokenAmountAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<TokenAmountAmount> for ::std::string::String {
        fn from(value: TokenAmountAmount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&TokenAmountAmount> for TokenAmountAmount {
        fn from(value: &TokenAmountAmount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for TokenAmountAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^[0-9]+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[0-9]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for TokenAmountAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for TokenAmountAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for TokenAmountAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TokenAmountAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`TokenBalance`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "token"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/TokenAmount"
    ///    },
    ///    "token": {
    ///      "$ref": "#/components/schemas/Token"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TokenBalance {
        pub amount: TokenAmount,
        pub token: Token,
    }
    impl ::std::convert::From<&TokenBalance> for TokenBalance {
        fn from(value: &TokenBalance) -> Self {
            value.clone()
        }
    }
    impl TokenBalance {
        pub fn builder() -> builder::TokenBalance {
            Default::default()
        }
    }
    /**The contract address of the token.
    For Ether, the contract address is `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` per [EIP-7528](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7528.md). For ERC-20 tokens, this is the contract address where the token is deployed.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The contract address of the token.\nFor Ether, the contract address is `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` per [EIP-7528](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7528.md). For ERC-20 tokens, this is the contract address where the token is deployed.",
    ///  "examples": [
    ///    "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct TokenContractAddress(::std::string::String);
    impl ::std::ops::Deref for TokenContractAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<TokenContractAddress> for ::std::string::String {
        fn from(value: TokenContractAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&TokenContractAddress> for TokenContractAddress {
        fn from(value: &TokenContractAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for TokenContractAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for TokenContractAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for TokenContractAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for TokenContractAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TokenContractAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`TokenFee`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "token"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "The estimated amount of the fee in atomic units of the `token`. For example, `1000000000000000` if the fee is in ETH equates to 0.001 ETH, `10000` if the fee is in USDC equates to 0.01 USDC, etc.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^\\d+$"
    ///    },
    ///    "token": {
    ///      "description": "The contract address of the token that the fee is paid in. The address `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` is used for the native token of the network (e.g. ETH).",
    ///      "examples": [
    ///        "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{40}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TokenFee {
        ///The estimated amount of the fee in atomic units of the `token`. For example, `1000000000000000` if the fee is in ETH equates to 0.001 ETH, `10000` if the fee is in USDC equates to 0.01 USDC, etc.
        pub amount: TokenFeeAmount,
        ///The contract address of the token that the fee is paid in. The address `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` is used for the native token of the network (e.g. ETH).
        pub token: TokenFeeToken,
    }
    impl ::std::convert::From<&TokenFee> for TokenFee {
        fn from(value: &TokenFee) -> Self {
            value.clone()
        }
    }
    impl TokenFee {
        pub fn builder() -> builder::TokenFee {
            Default::default()
        }
    }
    ///The estimated amount of the fee in atomic units of the `token`. For example, `1000000000000000` if the fee is in ETH equates to 0.001 ETH, `10000` if the fee is in USDC equates to 0.01 USDC, etc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The estimated amount of the fee in atomic units of the `token`. For example, `1000000000000000` if the fee is in ETH equates to 0.001 ETH, `10000` if the fee is in USDC equates to 0.01 USDC, etc.",
    ///  "examples": [
    ///    "1000000000000000000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^\\d+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct TokenFeeAmount(::std::string::String);
    impl ::std::ops::Deref for TokenFeeAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<TokenFeeAmount> for ::std::string::String {
        fn from(value: TokenFeeAmount) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&TokenFeeAmount> for TokenFeeAmount {
        fn from(value: &TokenFeeAmount) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for TokenFeeAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^\\d+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for TokenFeeAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for TokenFeeAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for TokenFeeAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TokenFeeAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The contract address of the token that the fee is paid in. The address `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` is used for the native token of the network (e.g. ETH).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The contract address of the token that the fee is paid in. The address `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` is used for the native token of the network (e.g. ETH).",
    ///  "examples": [
    ///    "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct TokenFeeToken(::std::string::String);
    impl ::std::ops::Deref for TokenFeeToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<TokenFeeToken> for ::std::string::String {
        fn from(value: TokenFeeToken) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&TokenFeeToken> for TokenFeeToken {
        fn from(value: &TokenFeeToken) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for TokenFeeToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for TokenFeeToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for TokenFeeToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for TokenFeeToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TokenFeeToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`UpdateEvmAccountAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateEvmAccountAddress(::std::string::String);
    impl ::std::ops::Deref for UpdateEvmAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UpdateEvmAccountAddress> for ::std::string::String {
        fn from(value: UpdateEvmAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UpdateEvmAccountAddress> for UpdateEvmAccountAddress {
        fn from(value: &UpdateEvmAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UpdateEvmAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UpdateEvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UpdateEvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UpdateEvmAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdateEvmAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`UpdateEvmAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "accountPolicy": {
    ///      "description": "The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.",
    ///      "examples": [
    ///        "123e4567-e89b-12d3-a456-426614174000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "(^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)|(^$)",
    ///      "x-audience": "public"
    ///    },
    ///    "name": {
    ///      "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.",
    ///      "examples": [
    ///        "my-wallet"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct UpdateEvmAccountBody {
        ///The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.
        #[serde(
            rename = "accountPolicy",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub account_policy: ::std::option::Option<UpdateEvmAccountBodyAccountPolicy>,
        /**An optional name for the account.
        Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
        Account names must be unique across all EVM accounts in the developer's CDP Project.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<UpdateEvmAccountBodyName>,
    }
    impl ::std::convert::From<&UpdateEvmAccountBody> for UpdateEvmAccountBody {
        fn from(value: &UpdateEvmAccountBody) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for UpdateEvmAccountBody {
        fn default() -> Self {
            Self {
                account_policy: Default::default(),
                name: Default::default(),
            }
        }
    }
    impl UpdateEvmAccountBody {
        pub fn builder() -> builder::UpdateEvmAccountBody {
            Default::default()
        }
    }
    ///The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.",
    ///  "examples": [
    ///    "123e4567-e89b-12d3-a456-426614174000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "(^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)|(^$)",
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateEvmAccountBodyAccountPolicy(::std::string::String);
    impl ::std::ops::Deref for UpdateEvmAccountBodyAccountPolicy {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UpdateEvmAccountBodyAccountPolicy> for ::std::string::String {
        fn from(value: UpdateEvmAccountBodyAccountPolicy) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UpdateEvmAccountBodyAccountPolicy>
        for UpdateEvmAccountBodyAccountPolicy
    {
        fn from(value: &UpdateEvmAccountBodyAccountPolicy) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UpdateEvmAccountBodyAccountPolicy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(
                || {
                    ::regress::Regex::new(
                        "(^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)|(^$)",
                    )
                    .unwrap()
                },
            );
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"(^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)|(^$)\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UpdateEvmAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UpdateEvmAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UpdateEvmAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdateEvmAccountBodyAccountPolicy {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    /**An optional name for the account.
    Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
    Account names must be unique across all EVM accounts in the developer's CDP Project.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.",
    ///  "examples": [
    ///    "my-wallet"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateEvmAccountBodyName(::std::string::String);
    impl ::std::ops::Deref for UpdateEvmAccountBodyName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UpdateEvmAccountBodyName> for ::std::string::String {
        fn from(value: UpdateEvmAccountBodyName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UpdateEvmAccountBodyName> for UpdateEvmAccountBodyName {
        fn from(value: &UpdateEvmAccountBodyName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UpdateEvmAccountBodyName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UpdateEvmAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UpdateEvmAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UpdateEvmAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdateEvmAccountBodyName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`UpdateEvmAccountXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateEvmAccountXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for UpdateEvmAccountXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UpdateEvmAccountXIdempotencyKey> for ::std::string::String {
        fn from(value: UpdateEvmAccountXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UpdateEvmAccountXIdempotencyKey> for UpdateEvmAccountXIdempotencyKey {
        fn from(value: &UpdateEvmAccountXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UpdateEvmAccountXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UpdateEvmAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UpdateEvmAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UpdateEvmAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdateEvmAccountXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`UpdateEvmSmartAccountAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateEvmSmartAccountAddress(::std::string::String);
    impl ::std::ops::Deref for UpdateEvmSmartAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UpdateEvmSmartAccountAddress> for ::std::string::String {
        fn from(value: UpdateEvmSmartAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UpdateEvmSmartAccountAddress> for UpdateEvmSmartAccountAddress {
        fn from(value: &UpdateEvmSmartAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UpdateEvmSmartAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UpdateEvmSmartAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UpdateEvmSmartAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UpdateEvmSmartAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdateEvmSmartAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`UpdateEvmSmartAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "name": {
    ///      "description": "An optional name for the smart account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM smart accounts in the developer's CDP Project.",
    ///      "examples": [
    ///        "my-smart-account"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct UpdateEvmSmartAccountBody {
        /**An optional name for the smart account.
        Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
        Account names must be unique across all EVM smart accounts in the developer's CDP Project.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<UpdateEvmSmartAccountBodyName>,
    }
    impl ::std::convert::From<&UpdateEvmSmartAccountBody> for UpdateEvmSmartAccountBody {
        fn from(value: &UpdateEvmSmartAccountBody) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for UpdateEvmSmartAccountBody {
        fn default() -> Self {
            Self {
                name: Default::default(),
            }
        }
    }
    impl UpdateEvmSmartAccountBody {
        pub fn builder() -> builder::UpdateEvmSmartAccountBody {
            Default::default()
        }
    }
    /**An optional name for the smart account.
    Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
    Account names must be unique across all EVM smart accounts in the developer's CDP Project.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An optional name for the smart account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM smart accounts in the developer's CDP Project.",
    ///  "examples": [
    ///    "my-smart-account"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateEvmSmartAccountBodyName(::std::string::String);
    impl ::std::ops::Deref for UpdateEvmSmartAccountBodyName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UpdateEvmSmartAccountBodyName> for ::std::string::String {
        fn from(value: UpdateEvmSmartAccountBodyName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UpdateEvmSmartAccountBodyName> for UpdateEvmSmartAccountBodyName {
        fn from(value: &UpdateEvmSmartAccountBodyName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UpdateEvmSmartAccountBodyName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UpdateEvmSmartAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UpdateEvmSmartAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UpdateEvmSmartAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdateEvmSmartAccountBodyName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`UpdatePolicyBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rules"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "An optional human-readable description for the policy.\nPolicy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.",
    ///      "examples": [
    ///        "Default policy"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[A-Za-z0-9 ,.]{1,50}$"
    ///    },
    ///    "rules": {
    ///      "description": "A list of rules that comprise the policy. There is a limit of 10 rules per policy.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Rule"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct UpdatePolicyBody {
        /**An optional human-readable description for the policy.
        Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<UpdatePolicyBodyDescription>,
        ///A list of rules that comprise the policy. There is a limit of 10 rules per policy.
        pub rules: ::std::vec::Vec<Rule>,
    }
    impl ::std::convert::From<&UpdatePolicyBody> for UpdatePolicyBody {
        fn from(value: &UpdatePolicyBody) -> Self {
            value.clone()
        }
    }
    impl UpdatePolicyBody {
        pub fn builder() -> builder::UpdatePolicyBody {
            Default::default()
        }
    }
    /**An optional human-readable description for the policy.
    Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An optional human-readable description for the policy.\nPolicy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.",
    ///  "examples": [
    ///    "Default policy"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[A-Za-z0-9 ,.]{1,50}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePolicyBodyDescription(::std::string::String);
    impl ::std::ops::Deref for UpdatePolicyBodyDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UpdatePolicyBodyDescription> for ::std::string::String {
        fn from(value: UpdatePolicyBodyDescription) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UpdatePolicyBodyDescription> for UpdatePolicyBodyDescription {
        fn from(value: &UpdatePolicyBodyDescription) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UpdatePolicyBodyDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[A-Za-z0-9 ,.]{1,50}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[A-Za-z0-9 ,.]{1,50}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UpdatePolicyBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePolicyBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UpdatePolicyBodyDescription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdatePolicyBodyDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`UpdatePolicyPolicyId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePolicyPolicyId(::std::string::String);
    impl ::std::ops::Deref for UpdatePolicyPolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UpdatePolicyPolicyId> for ::std::string::String {
        fn from(value: UpdatePolicyPolicyId) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UpdatePolicyPolicyId> for UpdatePolicyPolicyId {
        fn from(value: &UpdatePolicyPolicyId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UpdatePolicyPolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(
                || {
                    ::regress::Regex::new(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
                    )
                    .unwrap()
                },
            );
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UpdatePolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UpdatePolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdatePolicyPolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`UpdatePolicyXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePolicyXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for UpdatePolicyXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UpdatePolicyXIdempotencyKey> for ::std::string::String {
        fn from(value: UpdatePolicyXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UpdatePolicyXIdempotencyKey> for UpdatePolicyXIdempotencyKey {
        fn from(value: &UpdatePolicyXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UpdatePolicyXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UpdatePolicyXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePolicyXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UpdatePolicyXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdatePolicyXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`UpdateSolanaAccountAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[1-9A-HJ-NP-Za-km-z]{32,44}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateSolanaAccountAddress(::std::string::String);
    impl ::std::ops::Deref for UpdateSolanaAccountAddress {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UpdateSolanaAccountAddress> for ::std::string::String {
        fn from(value: UpdateSolanaAccountAddress) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UpdateSolanaAccountAddress> for UpdateSolanaAccountAddress {
        fn from(value: &UpdateSolanaAccountAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UpdateSolanaAccountAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[1-9A-HJ-NP-Za-km-z]{32,44}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[1-9A-HJ-NP-Za-km-z]{32,44}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UpdateSolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UpdateSolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UpdateSolanaAccountAddress {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdateSolanaAccountAddress {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`UpdateSolanaAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "accountPolicy": {
    ///      "description": "The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.",
    ///      "examples": [
    ///        "123e4567-e89b-12d3-a456-426614174000"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "(^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)|(^$)",
    ///      "x-audience": "public"
    ///    },
    ///    "name": {
    ///      "description": "An optional name for the account. Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all Solana accounts in the developer's CDP Project.",
    ///      "examples": [
    ///        "my-wallet"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct UpdateSolanaAccountBody {
        ///The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.
        #[serde(
            rename = "accountPolicy",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub account_policy: ::std::option::Option<UpdateSolanaAccountBodyAccountPolicy>,
        /**An optional name for the account. Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
        Account names must be unique across all Solana accounts in the developer's CDP Project.*/
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<UpdateSolanaAccountBodyName>,
    }
    impl ::std::convert::From<&UpdateSolanaAccountBody> for UpdateSolanaAccountBody {
        fn from(value: &UpdateSolanaAccountBody) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for UpdateSolanaAccountBody {
        fn default() -> Self {
            Self {
                account_policy: Default::default(),
                name: Default::default(),
            }
        }
    }
    impl UpdateSolanaAccountBody {
        pub fn builder() -> builder::UpdateSolanaAccountBody {
            Default::default()
        }
    }
    ///The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.",
    ///  "examples": [
    ///    "123e4567-e89b-12d3-a456-426614174000"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "(^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)|(^$)",
    ///  "x-audience": "public"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateSolanaAccountBodyAccountPolicy(::std::string::String);
    impl ::std::ops::Deref for UpdateSolanaAccountBodyAccountPolicy {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UpdateSolanaAccountBodyAccountPolicy> for ::std::string::String {
        fn from(value: UpdateSolanaAccountBodyAccountPolicy) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UpdateSolanaAccountBodyAccountPolicy>
        for UpdateSolanaAccountBodyAccountPolicy
    {
        fn from(value: &UpdateSolanaAccountBodyAccountPolicy) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UpdateSolanaAccountBodyAccountPolicy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(
                || {
                    ::regress::Regex::new(
                        "(^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)|(^$)",
                    )
                    .unwrap()
                },
            );
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"(^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)|(^$)\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UpdateSolanaAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UpdateSolanaAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UpdateSolanaAccountBodyAccountPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdateSolanaAccountBodyAccountPolicy {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    /**An optional name for the account. Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
    Account names must be unique across all Solana accounts in the developer's CDP Project.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An optional name for the account. Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all Solana accounts in the developer's CDP Project.",
    ///  "examples": [
    ///    "my-wallet"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateSolanaAccountBodyName(::std::string::String);
    impl ::std::ops::Deref for UpdateSolanaAccountBodyName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UpdateSolanaAccountBodyName> for ::std::string::String {
        fn from(value: UpdateSolanaAccountBodyName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UpdateSolanaAccountBodyName> for UpdateSolanaAccountBodyName {
        fn from(value: &UpdateSolanaAccountBodyName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UpdateSolanaAccountBodyName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UpdateSolanaAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UpdateSolanaAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UpdateSolanaAccountBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdateSolanaAccountBodyName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`UpdateSolanaAccountXIdempotencyKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 36,
    ///  "minLength": 36,
    ///  "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateSolanaAccountXIdempotencyKey(::std::string::String);
    impl ::std::ops::Deref for UpdateSolanaAccountXIdempotencyKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UpdateSolanaAccountXIdempotencyKey> for ::std::string::String {
        fn from(value: UpdateSolanaAccountXIdempotencyKey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UpdateSolanaAccountXIdempotencyKey>
        for UpdateSolanaAccountXIdempotencyKey
    {
        fn from(value: &UpdateSolanaAccountXIdempotencyKey) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UpdateSolanaAccountXIdempotencyKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 36usize {
                return Err("longer than 36 characters".into());
            }
            if value.chars().count() < 36usize {
                return Err("shorter than 36 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UpdateSolanaAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UpdateSolanaAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UpdateSolanaAccountXIdempotencyKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdateSolanaAccountXIdempotencyKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///A valid URI.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A valid URI.",
    ///  "examples": [
    ///    "foo://bar"
    ///  ],
    ///  "type": "string",
    ///  "format": "uri",
    ///  "maxLength": 2048,
    ///  "minLength": 5,
    ///  "pattern": "^.*://.*$"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize, ::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd,
    )]
    #[serde(transparent)]
    pub struct Uri(pub ::std::string::String);
    impl ::std::ops::Deref for Uri {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<Uri> for ::std::string::String {
        fn from(value: Uri) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&Uri> for Uri {
        fn from(value: &Uri) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::string::String> for Uri {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }
    impl ::std::str::FromStr for Uri {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for Uri {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///A valid HTTP or HTTPS URL.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A valid HTTP or HTTPS URL.",
    ///  "examples": [
    ///    "https://example.com"
    ///  ],
    ///  "type": "string",
    ///  "format": "uri",
    ///  "maxLength": 2048,
    ///  "minLength": 11,
    ///  "pattern": "^https?://.*$"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize, ::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd,
    )]
    #[serde(transparent)]
    pub struct Url(pub ::std::string::String);
    impl ::std::ops::Deref for Url {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<Url> for ::std::string::String {
        fn from(value: Url) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&Url> for Url {
        fn from(value: &Url) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::string::String> for Url {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }
    impl ::std::str::FromStr for Url {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for Url {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///The receipt that contains information about the execution of user operation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The receipt that contains information about the execution of user operation.",
    ///  "examples": [
    ///    {
    ///      "blockHash": "0x386544b58930c0ec9e8f3ed09fb4cdb76b9ae0a1a37ddcacebe3925b57978e65",
    ///      "blockNumber": 29338819,
    ///      "gasUsed": "100000",
    ///      "revert": {
    ///        "data": "0x123",
    ///        "message": "reason for failure"
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "blockHash": {
    ///      "description": "The block hash of the block including the transaction as 0x-prefixed string.",
    ///      "examples": [
    ///        "0x386544b58930c0ec9e8f3ed09fb4cdb76b9ae0a1a37ddcacebe3925b57978e65"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]{64}$|^$"
    ///    },
    ///    "blockNumber": {
    ///      "description": "The block height (number) of the block including the transaction.",
    ///      "examples": [
    ///        29338819
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "gasUsed": {
    ///      "description": "The gas used for landing this user operation.",
    ///      "examples": [
    ///        "100000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "revert": {
    ///      "$ref": "#/components/schemas/UserOperationReceiptRevert"
    ///    },
    ///    "transactionHash": {
    ///      "description": "The hash of this transaction as 0x-prefixed string.",
    ///      "examples": [
    ///        "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[a-fA-F0-9]{64}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct UserOperationReceipt {
        ///The block hash of the block including the transaction as 0x-prefixed string.
        #[serde(
            rename = "blockHash",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub block_hash: ::std::option::Option<UserOperationReceiptBlockHash>,
        ///The block height (number) of the block including the transaction.
        #[serde(
            rename = "blockNumber",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub block_number: ::std::option::Option<i64>,
        ///The gas used for landing this user operation.
        #[serde(
            rename = "gasUsed",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub gas_used: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub revert: ::std::option::Option<UserOperationReceiptRevert>,
        ///The hash of this transaction as 0x-prefixed string.
        #[serde(
            rename = "transactionHash",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub transaction_hash: ::std::option::Option<UserOperationReceiptTransactionHash>,
    }
    impl ::std::convert::From<&UserOperationReceipt> for UserOperationReceipt {
        fn from(value: &UserOperationReceipt) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for UserOperationReceipt {
        fn default() -> Self {
            Self {
                block_hash: Default::default(),
                block_number: Default::default(),
                gas_used: Default::default(),
                revert: Default::default(),
                transaction_hash: Default::default(),
            }
        }
    }
    impl UserOperationReceipt {
        pub fn builder() -> builder::UserOperationReceipt {
            Default::default()
        }
    }
    ///The block hash of the block including the transaction as 0x-prefixed string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The block hash of the block including the transaction as 0x-prefixed string.",
    ///  "examples": [
    ///    "0x386544b58930c0ec9e8f3ed09fb4cdb76b9ae0a1a37ddcacebe3925b57978e65"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{64}$|^$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UserOperationReceiptBlockHash(::std::string::String);
    impl ::std::ops::Deref for UserOperationReceiptBlockHash {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UserOperationReceiptBlockHash> for ::std::string::String {
        fn from(value: UserOperationReceiptBlockHash) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UserOperationReceiptBlockHash> for UserOperationReceiptBlockHash {
        fn from(value: &UserOperationReceiptBlockHash) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UserOperationReceiptBlockHash {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{64}$|^$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{64}$|^$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UserOperationReceiptBlockHash {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UserOperationReceiptBlockHash {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UserOperationReceiptBlockHash {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UserOperationReceiptBlockHash {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The revert data if the user operation has reverted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The revert data if the user operation has reverted.",
    ///  "examples": [
    ///    {
    ///      "data": "0x123",
    ///      "message": "reason for failure"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "message"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "description": "The 0x-prefixed raw hex string.",
    ///      "examples": [
    ///        "0x123"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]*$"
    ///    },
    ///    "message": {
    ///      "description": "Human-readable revert reason if able to decode.",
    ///      "examples": [
    ///        "reason for failure"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct UserOperationReceiptRevert {
        ///The 0x-prefixed raw hex string.
        pub data: UserOperationReceiptRevertData,
        ///Human-readable revert reason if able to decode.
        pub message: ::std::string::String,
    }
    impl ::std::convert::From<&UserOperationReceiptRevert> for UserOperationReceiptRevert {
        fn from(value: &UserOperationReceiptRevert) -> Self {
            value.clone()
        }
    }
    impl UserOperationReceiptRevert {
        pub fn builder() -> builder::UserOperationReceiptRevert {
            Default::default()
        }
    }
    ///The 0x-prefixed raw hex string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed raw hex string.",
    ///  "examples": [
    ///    "0x123"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]*$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UserOperationReceiptRevertData(::std::string::String);
    impl ::std::ops::Deref for UserOperationReceiptRevertData {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UserOperationReceiptRevertData> for ::std::string::String {
        fn from(value: UserOperationReceiptRevertData) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UserOperationReceiptRevertData> for UserOperationReceiptRevertData {
        fn from(value: &UserOperationReceiptRevertData) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UserOperationReceiptRevertData {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| ::regress::Regex::new("^0x[0-9a-fA-F]*$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]*$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UserOperationReceiptRevertData {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UserOperationReceiptRevertData {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UserOperationReceiptRevertData {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UserOperationReceiptRevertData {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The hash of this transaction as 0x-prefixed string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The hash of this transaction as 0x-prefixed string.",
    ///  "examples": [
    ///    "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[a-fA-F0-9]{64}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UserOperationReceiptTransactionHash(::std::string::String);
    impl ::std::ops::Deref for UserOperationReceiptTransactionHash {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UserOperationReceiptTransactionHash> for ::std::string::String {
        fn from(value: UserOperationReceiptTransactionHash) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UserOperationReceiptTransactionHash>
        for UserOperationReceiptTransactionHash
    {
        fn from(value: &UserOperationReceiptTransactionHash) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UserOperationReceiptTransactionHash {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[a-fA-F0-9]{64}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UserOperationReceiptTransactionHash {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UserOperationReceiptTransactionHash {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UserOperationReceiptTransactionHash {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UserOperationReceiptTransactionHash {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The request body for a developer to verify an end user's access token.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The request body for a developer to verify an end user's access token.",
    ///  "type": "object",
    ///  "required": [
    ///    "accessToken"
    ///  ],
    ///  "properties": {
    ///    "accessToken": {
    ///      "description": "The access token in JWT format to verify.",
    ///      "examples": [
    ///        "eyJhbGciOiJFUzI1NiIsImtpZCI6IjA1ZGNmYTU1LWY1NzktNDg5YS1iNThhLTFlMDI5Nzk0N2VlNiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJjZHAtYXBpIiwiYXV0aF90eXBlIjoiZW1haWwiLCJleHAiOjE3NTM5ODAyOTksImlhdCI6MTc1Mzk3ODQ5OSwiaXNzIjoiY2RwLWFwaSIsImp0aSI6IjA3ZWY5M2JlLTYzMDQtNGQ1YS05NmE3LWJlMGI5MWI0ZTE3NCIsInByb2plY3RfaWQiOiJjNzRkOGI4OC0wOTNiLTQyZDItOGE4Yy1kZGM1YzVlMGViNDMiLCJzdWIiOiJjYTM4YTM4ZC0xNmE5LTRkMjYtYTcxZC0zOWY2NmY5YzZiN2UifQ.1SU0pOy-WR002qUw4hd_UmZWRSLz-ZL6v7PvQvZMKVE6a51x_tqeUeRGaTGuYl1whg0eccMObmK7FqXKRH6E4g"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ValidateEndUserAccessTokenBody {
        ///The access token in JWT format to verify.
        #[serde(rename = "accessToken")]
        pub access_token: ::std::string::String,
    }
    impl ::std::convert::From<&ValidateEndUserAccessTokenBody> for ValidateEndUserAccessTokenBody {
        fn from(value: &ValidateEndUserAccessTokenBody) -> Self {
            value.clone()
        }
    }
    impl ValidateEndUserAccessTokenBody {
        pub fn builder() -> builder::ValidateEndUserAccessTokenBody {
            Default::default()
        }
    }
    ///`VerifyX402PaymentBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "paymentPayload",
    ///    "paymentRequirements",
    ///    "x402Version"
    ///  ],
    ///  "properties": {
    ///    "paymentPayload": {
    ///      "$ref": "#/components/schemas/x402PaymentPayload"
    ///    },
    ///    "paymentRequirements": {
    ///      "$ref": "#/components/schemas/x402PaymentRequirements"
    ///    },
    ///    "x402Version": {
    ///      "$ref": "#/components/schemas/X402Version"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct VerifyX402PaymentBody {
        #[serde(rename = "paymentPayload")]
        pub payment_payload: X402PaymentPayload,
        #[serde(rename = "paymentRequirements")]
        pub payment_requirements: X402PaymentRequirements,
        #[serde(rename = "x402Version")]
        pub x402_version: X402Version,
    }
    impl ::std::convert::From<&VerifyX402PaymentBody> for VerifyX402PaymentBody {
        fn from(value: &VerifyX402PaymentBody) -> Self {
            value.clone()
        }
    }
    impl VerifyX402PaymentBody {
        pub fn builder() -> builder::VerifyX402PaymentBody {
            Default::default()
        }
    }
    ///`VerifyX402PaymentResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "isValid",
    ///    "payer"
    ///  ],
    ///  "properties": {
    ///    "invalidReason": {
    ///      "$ref": "#/components/schemas/x402VerifyInvalidReason"
    ///    },
    ///    "isValid": {
    ///      "description": "Indicates whether the payment is valid.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "payer": {
    ///      "description": "The onchain address of the client that is paying for the resource.\n\nFor EVM networks, the payer will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, the payer will be a base58-encoded Solana address.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct VerifyX402PaymentResponse {
        #[serde(
            rename = "invalidReason",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub invalid_reason: ::std::option::Option<X402VerifyInvalidReason>,
        ///Indicates whether the payment is valid.
        #[serde(rename = "isValid")]
        pub is_valid: bool,
        /**The onchain address of the client that is paying for the resource.

        For EVM networks, the payer will be a 0x-prefixed, checksum EVM address.

        For Solana-based networks, the payer will be a base58-encoded Solana address.*/
        pub payer: VerifyX402PaymentResponsePayer,
    }
    impl ::std::convert::From<&VerifyX402PaymentResponse> for VerifyX402PaymentResponse {
        fn from(value: &VerifyX402PaymentResponse) -> Self {
            value.clone()
        }
    }
    impl VerifyX402PaymentResponse {
        pub fn builder() -> builder::VerifyX402PaymentResponse {
            Default::default()
        }
    }
    /**The onchain address of the client that is paying for the resource.

    For EVM networks, the payer will be a 0x-prefixed, checksum EVM address.

    For Solana-based networks, the payer will be a base58-encoded Solana address.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The onchain address of the client that is paying for the resource.\n\nFor EVM networks, the payer will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, the payer will be a base58-encoded Solana address.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct VerifyX402PaymentResponsePayer(::std::string::String);
    impl ::std::ops::Deref for VerifyX402PaymentResponsePayer {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<VerifyX402PaymentResponsePayer> for ::std::string::String {
        fn from(value: VerifyX402PaymentResponsePayer) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&VerifyX402PaymentResponsePayer> for VerifyX402PaymentResponsePayer {
        fn from(value: &VerifyX402PaymentResponsePayer) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for VerifyX402PaymentResponsePayer {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$")
                        .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for VerifyX402PaymentResponsePayer {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for VerifyX402PaymentResponsePayer {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for VerifyX402PaymentResponsePayer {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for VerifyX402PaymentResponsePayer {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///`WebhookSubscriptionListResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "description": "Response containing a list of webhook subscriptions.",
    ///      "type": "object",
    ///      "required": [
    ///        "subscriptions"
    ///      ],
    ///      "properties": {
    ///        "subscriptions": {
    ///          "description": "The list of webhook subscriptions.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/WebhookSubscriptionResponse"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ListResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct WebhookSubscriptionListResponse {
        ///The token for the next page of items, if any.
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<::std::string::String>,
        ///The list of webhook subscriptions.
        pub subscriptions: ::std::vec::Vec<WebhookSubscriptionResponse>,
    }
    impl ::std::convert::From<&WebhookSubscriptionListResponse> for WebhookSubscriptionListResponse {
        fn from(value: &WebhookSubscriptionListResponse) -> Self {
            value.clone()
        }
    }
    impl WebhookSubscriptionListResponse {
        pub fn builder() -> builder::WebhookSubscriptionListResponse {
            Default::default()
        }
    }
    /**Request to create a new webhook subscription with support for both traditional single-label
    and multi-label filtering formats.
    */
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request to create a new webhook subscription with support for both traditional single-label\nand multi-label filtering formats.\n",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "title": "Traditional single-label format",
    ///      "not": {
    ///        "required": [
    ///          "labels"
    ///        ]
    ///      },
    ///      "required": [
    ///        "eventTypes",
    ///        "isEnabled",
    ///        "labelKey",
    ///        "labelValue",
    ///        "target"
    ///      ]
    ///    },
    ///    {
    ///      "title": "Multi-label format with total overlap logic",
    ///      "not": {
    ///        "anyOf": [
    ///          {
    ///            "required": [
    ///              "labelKey"
    ///            ]
    ///          },
    ///          {
    ///            "required": [
    ///              "labelValue"
    ///            ]
    ///          }
    ///        ]
    ///      },
    ///      "required": [
    ///        "eventTypes",
    ///        "isEnabled",
    ///        "labels",
    ///        "target"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "Description of the webhook subscription.",
    ///      "examples": [
    ///        "Subscription for token transfer events"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "eventTypes": {
    ///      "description": "Types of events to subscribe to. Event types follow a three-part dot-separated format:\nservice.resource.verb (e.g., \"onchain.activity.detected\", \"wallet.activity.detected\", \"onramp.transaction.created\").\nThe subscription will only receive events matching these types AND the label filter(s).\n",
    ///      "examples": [
    ///        [
    ///          "onchain.activity.detected"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "isEnabled": {
    ///      "description": "Whether the subscription is enabled.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "labelKey": {
    ///      "description": "Label key for filtering events. Each subscription filters on exactly one (labelKey, labelValue) pair\nin addition to the event types. Only events matching both the event types AND this label filter will be delivered.\nNOTE: Use either (labelKey + labelValue) OR labels, not both.\n",
    ///      "examples": [
    ///        "contract_address"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "labelValue": {
    ///      "description": "Label value for filtering events. Must correspond to the labelKey (e.g., contract address for contract_address key).\nOnly events with this exact label value will be delivered.\nNOTE: Use either (labelKey + labelValue) OR labels, not both.\n",
    ///      "examples": [
    ///        "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "labels": {
    ///      "description": "Multi-label filters using total overlap logic. Total overlap means the subscription will only trigger when\nan event contains ALL the key-value pairs specified here. Additional labels on\nthe event are allowed and will not prevent matching.\nNOTE: Use either labels OR (labelKey + labelValue), not both.\n",
    ///      "examples": [
    ///        {
    ///          "contract_address": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    ///          "env": "dev",
    ///          "team": "payments"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "metadata": {
    ///      "description": "Additional metadata for the subscription.",
    ///      "examples": [
    ///        {
    ///          "custom_field": "custom_value",
    ///          "webhook_version": "v1"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": true
    ///    },
    ///    "target": {
    ///      "$ref": "#/components/schemas/WebhookTarget"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WebhookSubscriptionRequest {
        Variant0(WebhookSubscriptionRequestVariant0),
        Variant1(WebhookSubscriptionRequestVariant1),
    }
    impl ::std::convert::From<&Self> for WebhookSubscriptionRequest {
        fn from(value: &WebhookSubscriptionRequest) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<WebhookSubscriptionRequestVariant0> for WebhookSubscriptionRequest {
        fn from(value: WebhookSubscriptionRequestVariant0) -> Self {
            Self::Variant0(value)
        }
    }
    impl ::std::convert::From<WebhookSubscriptionRequestVariant1> for WebhookSubscriptionRequest {
        fn from(value: WebhookSubscriptionRequestVariant1) -> Self {
            Self::Variant1(value)
        }
    }
    ///`WebhookSubscriptionRequestVariant0`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "description": {
    ///          "description": "Description of the webhook subscription.",
    ///          "examples": [
    ///            "Subscription for token transfer events"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "eventTypes": {
    ///          "description": "Types of events to subscribe to. Event types follow a three-part dot-separated format:\nservice.resource.verb (e.g., \"onchain.activity.detected\", \"wallet.activity.detected\", \"onramp.transaction.created\").\nThe subscription will only receive events matching these types AND the label filter(s).\n",
    ///          "examples": [
    ///            [
    ///              "onchain.activity.detected"
    ///            ]
    ///          ],
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "isEnabled": {
    ///          "description": "Whether the subscription is enabled.",
    ///          "examples": [
    ///            true
    ///          ],
    ///          "type": "boolean"
    ///        },
    ///        "labelKey": {
    ///          "description": "Label key for filtering events. Each subscription filters on exactly one (labelKey, labelValue) pair\nin addition to the event types. Only events matching both the event types AND this label filter will be delivered.\nNOTE: Use either (labelKey + labelValue) OR labels, not both.\n",
    ///          "examples": [
    ///            "contract_address"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "labelValue": {
    ///          "description": "Label value for filtering events. Must correspond to the labelKey (e.g., contract address for contract_address key).\nOnly events with this exact label value will be delivered.\nNOTE: Use either (labelKey + labelValue) OR labels, not both.\n",
    ///          "examples": [
    ///            "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "labels": {
    ///          "description": "Multi-label filters using total overlap logic. Total overlap means the subscription will only trigger when\nan event contains ALL the key-value pairs specified here. Additional labels on\nthe event are allowed and will not prevent matching.\nNOTE: Use either labels OR (labelKey + labelValue), not both.\n",
    ///          "examples": [
    ///            {
    ///              "contract_address": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    ///              "env": "dev",
    ///              "team": "payments"
    ///            }
    ///          ],
    ///          "type": "object",
    ///          "additionalProperties": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "metadata": {
    ///          "description": "Additional metadata for the subscription.",
    ///          "examples": [
    ///            {
    ///              "custom_field": "custom_value",
    ///              "webhook_version": "v1"
    ///            }
    ///          ],
    ///          "type": "object",
    ///          "additionalProperties": true
    ///        },
    ///        "target": {
    ///          "$ref": "#/components/schemas/WebhookTarget"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "title": "Traditional single-label format",
    ///      "not": {
    ///        "required": [
    ///          "labels"
    ///        ]
    ///      },
    ///      "required": [
    ///        "eventTypes",
    ///        "isEnabled",
    ///        "labelKey",
    ///        "labelValue",
    ///        "target"
    ///      ]
    ///    },
    ///    {
    ///      "not": {
    ///        "title": "Multi-label format with total overlap logic",
    ///        "not": {
    ///          "anyOf": [
    ///            {
    ///              "required": [
    ///                "labelKey"
    ///              ]
    ///            },
    ///            {
    ///              "required": [
    ///                "labelValue"
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "required": [
    ///          "eventTypes",
    ///          "isEnabled",
    ///          "labels",
    ///          "target"
    ///        ]
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(deny_unknown_fields)]
    pub enum WebhookSubscriptionRequestVariant0 {}
    impl ::std::convert::From<&Self> for WebhookSubscriptionRequestVariant0 {
        fn from(value: &WebhookSubscriptionRequestVariant0) -> Self {
            value.clone()
        }
    }
    ///`WebhookSubscriptionRequestVariant1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "description": {
    ///          "description": "Description of the webhook subscription.",
    ///          "examples": [
    ///            "Subscription for token transfer events"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "eventTypes": {
    ///          "description": "Types of events to subscribe to. Event types follow a three-part dot-separated format:\nservice.resource.verb (e.g., \"onchain.activity.detected\", \"wallet.activity.detected\", \"onramp.transaction.created\").\nThe subscription will only receive events matching these types AND the label filter(s).\n",
    ///          "examples": [
    ///            [
    ///              "onchain.activity.detected"
    ///            ]
    ///          ],
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "isEnabled": {
    ///          "description": "Whether the subscription is enabled.",
    ///          "examples": [
    ///            true
    ///          ],
    ///          "type": "boolean"
    ///        },
    ///        "labelKey": {
    ///          "description": "Label key for filtering events. Each subscription filters on exactly one (labelKey, labelValue) pair\nin addition to the event types. Only events matching both the event types AND this label filter will be delivered.\nNOTE: Use either (labelKey + labelValue) OR labels, not both.\n",
    ///          "examples": [
    ///            "contract_address"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "labelValue": {
    ///          "description": "Label value for filtering events. Must correspond to the labelKey (e.g., contract address for contract_address key).\nOnly events with this exact label value will be delivered.\nNOTE: Use either (labelKey + labelValue) OR labels, not both.\n",
    ///          "examples": [
    ///            "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "labels": {
    ///          "description": "Multi-label filters using total overlap logic. Total overlap means the subscription will only trigger when\nan event contains ALL the key-value pairs specified here. Additional labels on\nthe event are allowed and will not prevent matching.\nNOTE: Use either labels OR (labelKey + labelValue), not both.\n",
    ///          "examples": [
    ///            {
    ///              "contract_address": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    ///              "env": "dev",
    ///              "team": "payments"
    ///            }
    ///          ],
    ///          "type": "object",
    ///          "additionalProperties": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "metadata": {
    ///          "description": "Additional metadata for the subscription.",
    ///          "examples": [
    ///            {
    ///              "custom_field": "custom_value",
    ///              "webhook_version": "v1"
    ///            }
    ///          ],
    ///          "type": "object",
    ///          "additionalProperties": true
    ///        },
    ///        "target": {
    ///          "$ref": "#/components/schemas/WebhookTarget"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "title": "Multi-label format with total overlap logic",
    ///      "not": {
    ///        "anyOf": [
    ///          {
    ///            "required": [
    ///              "labelKey"
    ///            ]
    ///          },
    ///          {
    ///            "required": [
    ///              "labelValue"
    ///            ]
    ///          }
    ///        ]
    ///      },
    ///      "required": [
    ///        "eventTypes",
    ///        "isEnabled",
    ///        "labels",
    ///        "target"
    ///      ]
    ///    },
    ///    {
    ///      "not": {
    ///        "title": "Traditional single-label format",
    ///        "not": {
    ///          "required": [
    ///            "labels"
    ///          ]
    ///        },
    ///        "required": [
    ///          "eventTypes",
    ///          "isEnabled",
    ///          "labelKey",
    ///          "labelValue",
    ///          "target"
    ///        ]
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(deny_unknown_fields)]
    pub enum WebhookSubscriptionRequestVariant1 {}
    impl ::std::convert::From<&Self> for WebhookSubscriptionRequestVariant1 {
        fn from(value: &WebhookSubscriptionRequestVariant1) -> Self {
            value.clone()
        }
    }
    ///Response containing webhook subscription details.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response containing webhook subscription details.",
    ///  "examples": [
    ///    {
    ///      "createdAt": "2025-11-12T09:19:52.051Z",
    ///      "description": "USDC Transfer events to specific address.",
    ///      "eventTypes": [
    ///        "onchain.activity.detected"
    ///      ],
    ///      "isEnabled": true,
    ///      "labelKey": "event_name",
    ///      "labelValue": "Transfer",
    ///      "labels": {
    ///        "contract_address": "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",
    ///        "event_name": "Transfer",
    ///        "network": "base-mainnet",
    ///        "transaction_to": "0xf5042e6ffac5a625d4e7848e0b01373d8eb9e222"
    ///      },
    ///      "metadata": {
    ///        "secret": "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
    ///      },
    ///      "secret": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    ///      "subscriptionId": "123e4567-e89b-12d3-a456-426614174000",
    ///      "target": {
    ///        "url": "https://api.example.com/webhooks"
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "createdAt",
    ///    "eventTypes",
    ///    "isEnabled",
    ///    "secret",
    ///    "subscriptionId",
    ///    "target"
    ///  ],
    ///  "properties": {
    ///    "createdAt": {
    ///      "description": "When the subscription was created.",
    ///      "examples": [
    ///        "2025-01-15T10:30:00Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "description": {
    ///      "description": "Description of the webhook subscription.",
    ///      "examples": [
    ///        "Subscription for token transfer events"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "eventTypes": {
    ///      "description": "Types of events to subscribe to. Event types follow a three-part dot-separated format:\nservice.resource.verb (e.g., \"onchain.activity.detected\", \"wallet.activity.detected\", \"onramp.transaction.created\").\n",
    ///      "examples": [
    ///        [
    ///          "onchain.activity.detected"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "isEnabled": {
    ///      "description": "Whether the subscription is enabled.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "labelKey": {
    ///      "description": "Label key for filtering events. Present when subscription uses traditional single-label format.\n",
    ///      "examples": [
    ///        "contract_address"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "labelValue": {
    ///      "description": "Label value for filtering events. Present when subscription uses traditional single-label format.\n",
    ///      "examples": [
    ///        "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "labels": {
    ///      "description": "Multi-label filters using total overlap logic. Total overlap means the subscription only triggers when events contain ALL these key-value pairs.\nPresent when subscription uses multi-label format.\n",
    ///      "examples": [
    ///        {
    ///          "contract_address": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    ///          "env": "dev",
    ///          "team": "payments"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "metadata": {
    ///      "description": "Additional metadata for the subscription.",
    ///      "examples": [
    ///        {
    ///          "secret": "123e4567-e89b-12d3-a456-426614174000"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "secret": {
    ///          "description": "Use the root-level `secret` field instead. Maintained for backward compatibility only.",
    ///          "deprecated": true,
    ///          "examples": [
    ///            "123e4567-e89b-12d3-a456-426614174000"
    ///          ],
    ///          "type": "string",
    ///          "format": "uuid"
    ///        }
    ///      }
    ///    },
    ///    "secret": {
    ///      "description": "Secret for webhook signature validation.",
    ///      "examples": [
    ///        "123e4567-e89b-12d3-a456-426614174000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "subscriptionId": {
    ///      "description": "Unique identifier for the subscription.",
    ///      "examples": [
    ///        "123e4567-e89b-12d3-a456-426614174000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "target": {
    ///      "$ref": "#/components/schemas/WebhookTarget"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct WebhookSubscriptionResponse {
        ///When the subscription was created.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        ///Description of the webhook subscription.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        /**Types of events to subscribe to. Event types follow a three-part dot-separated format:
        service.resource.verb (e.g., "onchain.activity.detected", "wallet.activity.detected", "onramp.transaction.created").
        */
        #[serde(rename = "eventTypes")]
        pub event_types: ::std::vec::Vec<::std::string::String>,
        ///Whether the subscription is enabled.
        #[serde(rename = "isEnabled")]
        pub is_enabled: bool,
        /**Label key for filtering events. Present when subscription uses traditional single-label format.
         */
        #[serde(
            rename = "labelKey",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub label_key: ::std::option::Option<::std::string::String>,
        /**Label value for filtering events. Present when subscription uses traditional single-label format.
         */
        #[serde(
            rename = "labelValue",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub label_value: ::std::option::Option<::std::string::String>,
        /**Multi-label filters using total overlap logic. Total overlap means the subscription only triggers when events contain ALL these key-value pairs.
        Present when subscription uses multi-label format.
        */
        #[serde(
            default,
            skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
        )]
        pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<WebhookSubscriptionResponseMetadata>,
        ///Secret for webhook signature validation.
        pub secret: ::uuid::Uuid,
        ///Unique identifier for the subscription.
        #[serde(rename = "subscriptionId")]
        pub subscription_id: ::uuid::Uuid,
        pub target: WebhookTarget,
    }
    impl ::std::convert::From<&WebhookSubscriptionResponse> for WebhookSubscriptionResponse {
        fn from(value: &WebhookSubscriptionResponse) -> Self {
            value.clone()
        }
    }
    impl WebhookSubscriptionResponse {
        pub fn builder() -> builder::WebhookSubscriptionResponse {
            Default::default()
        }
    }
    ///Additional metadata for the subscription.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Additional metadata for the subscription.",
    ///  "examples": [
    ///    {
    ///      "secret": "123e4567-e89b-12d3-a456-426614174000"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "secret": {
    ///      "description": "Use the root-level `secret` field instead. Maintained for backward compatibility only.",
    ///      "deprecated": true,
    ///      "examples": [
    ///        "123e4567-e89b-12d3-a456-426614174000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct WebhookSubscriptionResponseMetadata {
        ///Use the root-level `secret` field instead. Maintained for backward compatibility only.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub secret: ::std::option::Option<::uuid::Uuid>,
    }
    impl ::std::convert::From<&WebhookSubscriptionResponseMetadata>
        for WebhookSubscriptionResponseMetadata
    {
        fn from(value: &WebhookSubscriptionResponseMetadata) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for WebhookSubscriptionResponseMetadata {
        fn default() -> Self {
            Self {
                secret: Default::default(),
            }
        }
    }
    impl WebhookSubscriptionResponseMetadata {
        pub fn builder() -> builder::WebhookSubscriptionResponseMetadata {
            Default::default()
        }
    }
    /**Request to update an existing webhook subscription. The update format must match
    the original subscription format (traditional or multi-label).
    */
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request to update an existing webhook subscription. The update format must match\nthe original subscription format (traditional or multi-label).\n",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "title": "Traditional single-label update format",
    ///      "not": {
    ///        "required": [
    ///          "labels"
    ///        ]
    ///      },
    ///      "required": [
    ///        "eventTypes",
    ///        "isEnabled",
    ///        "labelKey",
    ///        "labelValue",
    ///        "target"
    ///      ]
    ///    },
    ///    {
    ///      "title": "Multi-label update format with total overlap logic",
    ///      "not": {
    ///        "anyOf": [
    ///          {
    ///            "required": [
    ///              "labelKey"
    ///            ]
    ///          },
    ///          {
    ///            "required": [
    ///              "labelValue"
    ///            ]
    ///          }
    ///        ]
    ///      },
    ///      "required": [
    ///        "eventTypes",
    ///        "isEnabled",
    ///        "labels",
    ///        "target"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "Description of the webhook subscription.",
    ///      "examples": [
    ///        "Updated subscription for token transfer events"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "eventTypes": {
    ///      "description": "Types of events to subscribe to. Event types follow a three-part dot-separated format:\nservice.resource.verb (e.g., \"onchain.activity.detected\", \"wallet.activity.detected\", \"onramp.transaction.created\").\n",
    ///      "examples": [
    ///        [
    ///          "onchain.activity.detected"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "isEnabled": {
    ///      "description": "Whether the subscription is enabled.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "labelKey": {
    ///      "description": "Label key for filtering events. Use either (labelKey + labelValue) OR labels, not both.\n",
    ///      "examples": [
    ///        "contract_address"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "labelValue": {
    ///      "description": "Label value for filtering events. Use either (labelKey + labelValue) OR labels, not both.\n",
    ///      "examples": [
    ///        "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "labels": {
    ///      "description": "Multi-label filters using total overlap logic. Total overlap means the subscription will only trigger when\nan event contains ALL the key-value pairs specified here. Use either labels OR (labelKey + labelValue), not both.\n",
    ///      "examples": [
    ///        {
    ///          "env": "prod",
    ///          "service": "api"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "metadata": {
    ///      "description": "Additional metadata for the subscription.",
    ///      "examples": [
    ///        {
    ///          "updated_field": "updated_value",
    ///          "webhook_version": "v2"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": true
    ///    },
    ///    "target": {
    ///      "$ref": "#/components/schemas/WebhookTarget"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WebhookSubscriptionUpdateRequest {
        Variant0(WebhookSubscriptionUpdateRequestVariant0),
        Variant1(WebhookSubscriptionUpdateRequestVariant1),
    }
    impl ::std::convert::From<&Self> for WebhookSubscriptionUpdateRequest {
        fn from(value: &WebhookSubscriptionUpdateRequest) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<WebhookSubscriptionUpdateRequestVariant0>
        for WebhookSubscriptionUpdateRequest
    {
        fn from(value: WebhookSubscriptionUpdateRequestVariant0) -> Self {
            Self::Variant0(value)
        }
    }
    impl ::std::convert::From<WebhookSubscriptionUpdateRequestVariant1>
        for WebhookSubscriptionUpdateRequest
    {
        fn from(value: WebhookSubscriptionUpdateRequestVariant1) -> Self {
            Self::Variant1(value)
        }
    }
    ///`WebhookSubscriptionUpdateRequestVariant0`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "description": {
    ///          "description": "Description of the webhook subscription.",
    ///          "examples": [
    ///            "Updated subscription for token transfer events"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "eventTypes": {
    ///          "description": "Types of events to subscribe to. Event types follow a three-part dot-separated format:\nservice.resource.verb (e.g., \"onchain.activity.detected\", \"wallet.activity.detected\", \"onramp.transaction.created\").\n",
    ///          "examples": [
    ///            [
    ///              "onchain.activity.detected"
    ///            ]
    ///          ],
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "isEnabled": {
    ///          "description": "Whether the subscription is enabled.",
    ///          "examples": [
    ///            false
    ///          ],
    ///          "type": "boolean"
    ///        },
    ///        "labelKey": {
    ///          "description": "Label key for filtering events. Use either (labelKey + labelValue) OR labels, not both.\n",
    ///          "examples": [
    ///            "contract_address"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "labelValue": {
    ///          "description": "Label value for filtering events. Use either (labelKey + labelValue) OR labels, not both.\n",
    ///          "examples": [
    ///            "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "labels": {
    ///          "description": "Multi-label filters using total overlap logic. Total overlap means the subscription will only trigger when\nan event contains ALL the key-value pairs specified here. Use either labels OR (labelKey + labelValue), not both.\n",
    ///          "examples": [
    ///            {
    ///              "env": "prod",
    ///              "service": "api"
    ///            }
    ///          ],
    ///          "type": "object",
    ///          "additionalProperties": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "metadata": {
    ///          "description": "Additional metadata for the subscription.",
    ///          "examples": [
    ///            {
    ///              "updated_field": "updated_value",
    ///              "webhook_version": "v2"
    ///            }
    ///          ],
    ///          "type": "object",
    ///          "additionalProperties": true
    ///        },
    ///        "target": {
    ///          "$ref": "#/components/schemas/WebhookTarget"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "title": "Traditional single-label update format",
    ///      "not": {
    ///        "required": [
    ///          "labels"
    ///        ]
    ///      },
    ///      "required": [
    ///        "eventTypes",
    ///        "isEnabled",
    ///        "labelKey",
    ///        "labelValue",
    ///        "target"
    ///      ]
    ///    },
    ///    {
    ///      "not": {
    ///        "title": "Multi-label update format with total overlap logic",
    ///        "not": {
    ///          "anyOf": [
    ///            {
    ///              "required": [
    ///                "labelKey"
    ///              ]
    ///            },
    ///            {
    ///              "required": [
    ///                "labelValue"
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "required": [
    ///          "eventTypes",
    ///          "isEnabled",
    ///          "labels",
    ///          "target"
    ///        ]
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(deny_unknown_fields)]
    pub enum WebhookSubscriptionUpdateRequestVariant0 {}
    impl ::std::convert::From<&Self> for WebhookSubscriptionUpdateRequestVariant0 {
        fn from(value: &WebhookSubscriptionUpdateRequestVariant0) -> Self {
            value.clone()
        }
    }
    ///`WebhookSubscriptionUpdateRequestVariant1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "description": {
    ///          "description": "Description of the webhook subscription.",
    ///          "examples": [
    ///            "Updated subscription for token transfer events"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "eventTypes": {
    ///          "description": "Types of events to subscribe to. Event types follow a three-part dot-separated format:\nservice.resource.verb (e.g., \"onchain.activity.detected\", \"wallet.activity.detected\", \"onramp.transaction.created\").\n",
    ///          "examples": [
    ///            [
    ///              "onchain.activity.detected"
    ///            ]
    ///          ],
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "isEnabled": {
    ///          "description": "Whether the subscription is enabled.",
    ///          "examples": [
    ///            false
    ///          ],
    ///          "type": "boolean"
    ///        },
    ///        "labelKey": {
    ///          "description": "Label key for filtering events. Use either (labelKey + labelValue) OR labels, not both.\n",
    ///          "examples": [
    ///            "contract_address"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "labelValue": {
    ///          "description": "Label value for filtering events. Use either (labelKey + labelValue) OR labels, not both.\n",
    ///          "examples": [
    ///            "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "labels": {
    ///          "description": "Multi-label filters using total overlap logic. Total overlap means the subscription will only trigger when\nan event contains ALL the key-value pairs specified here. Use either labels OR (labelKey + labelValue), not both.\n",
    ///          "examples": [
    ///            {
    ///              "env": "prod",
    ///              "service": "api"
    ///            }
    ///          ],
    ///          "type": "object",
    ///          "additionalProperties": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "metadata": {
    ///          "description": "Additional metadata for the subscription.",
    ///          "examples": [
    ///            {
    ///              "updated_field": "updated_value",
    ///              "webhook_version": "v2"
    ///            }
    ///          ],
    ///          "type": "object",
    ///          "additionalProperties": true
    ///        },
    ///        "target": {
    ///          "$ref": "#/components/schemas/WebhookTarget"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "title": "Multi-label update format with total overlap logic",
    ///      "not": {
    ///        "anyOf": [
    ///          {
    ///            "required": [
    ///              "labelKey"
    ///            ]
    ///          },
    ///          {
    ///            "required": [
    ///              "labelValue"
    ///            ]
    ///          }
    ///        ]
    ///      },
    ///      "required": [
    ///        "eventTypes",
    ///        "isEnabled",
    ///        "labels",
    ///        "target"
    ///      ]
    ///    },
    ///    {
    ///      "not": {
    ///        "title": "Traditional single-label update format",
    ///        "not": {
    ///          "required": [
    ///            "labels"
    ///          ]
    ///        },
    ///        "required": [
    ///          "eventTypes",
    ///          "isEnabled",
    ///          "labelKey",
    ///          "labelValue",
    ///          "target"
    ///        ]
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(deny_unknown_fields)]
    pub enum WebhookSubscriptionUpdateRequestVariant1 {}
    impl ::std::convert::From<&Self> for WebhookSubscriptionUpdateRequestVariant1 {
        fn from(value: &WebhookSubscriptionUpdateRequestVariant1) -> Self {
            value.clone()
        }
    }
    /**Target configuration for webhook delivery.
    Specifies the destination URL and any custom headers to include in webhook requests.
    */
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Target configuration for webhook delivery.\nSpecifies the destination URL and any custom headers to include in webhook requests.\n",
    ///  "examples": [
    ///    {
    ///      "headers": {
    ///        "Authorization": "Bearer token123",
    ///        "Content-Type": "application/json"
    ///      },
    ///      "url": "https://api.example.com/webhooks"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "url"
    ///  ],
    ///  "properties": {
    ///    "headers": {
    ///      "description": "Additional headers to include in webhook requests.",
    ///      "examples": [
    ///        {
    ///          "Authorization": "Bearer token123",
    ///          "Content-Type": "application/json"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "url": {
    ///      "description": "The webhook URL to deliver events to.",
    ///      "examples": [
    ///        "https://api.example.com/webhooks"
    ///      ],
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Url"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct WebhookTarget {
        ///Additional headers to include in webhook requests.
        #[serde(
            default,
            skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
        )]
        pub headers: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        ///The webhook URL to deliver events to.
        pub url: Url,
    }
    impl ::std::convert::From<&WebhookTarget> for WebhookTarget {
        fn from(value: &WebhookTarget) -> Self {
            value.clone()
        }
    }
    impl WebhookTarget {
        pub fn builder() -> builder::WebhookTarget {
            Default::default()
        }
    }
    ///The x402 protocol exact scheme payload for EVM networks. The scheme is implemented using ERC-3009. For more details, please see [EVM Exact Scheme Details](https://github.com/coinbase/x402/blob/main/specs/schemes/exact/scheme_exact_evm.md).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "x402ExactEvmPayload",
    ///  "description": "The x402 protocol exact scheme payload for EVM networks. The scheme is implemented using ERC-3009. For more details, please see [EVM Exact Scheme Details](https://github.com/coinbase/x402/blob/main/specs/schemes/exact/scheme_exact_evm.md).",
    ///  "examples": [
    ///    {
    ///      "authorization": {
    ///        "from": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///        "nonce": "0x1234567890abcdef1234567890abcdef12345678",
    ///        "to": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///        "validAfter": "1716150000",
    ///        "validBefore": "1716150000",
    ///        "value": "1000000000000000000"
    ///      },
    ///      "signature": "0xf3746613c2d920b5fdabc0856f2aeb2d4f88ee6037b8cc5d04a71a4462f13480"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "authorization",
    ///    "signature"
    ///  ],
    ///  "properties": {
    ///    "authorization": {
    ///      "description": "The authorization data for the ERC-3009 authorization message.",
    ///      "examples": [
    ///        {
    ///          "from": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///          "nonce": "0x1234567890abcdef1234567890abcdef12345678",
    ///          "to": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///          "validAfter": "1716150000",
    ///          "validBefore": "1716150000",
    ///          "value": "1000000000000000000"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "required": [
    ///        "from",
    ///        "nonce",
    ///        "to",
    ///        "validAfter",
    ///        "validBefore",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "from": {
    ///          "description": "The 0x-prefixed, checksum EVM address of the sender of the payment.",
    ///          "examples": [
    ///            "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^0x[0-9a-fA-F]{40}$"
    ///        },
    ///        "nonce": {
    ///          "description": "The hex-encoded nonce of the payment.",
    ///          "examples": [
    ///            "0x1234567890abcdef1234567890abcdef12345678"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "to": {
    ///          "description": "The 0x-prefixed, checksum EVM address of the recipient of the payment.",
    ///          "examples": [
    ///            "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///          ],
    ///          "type": "string",
    ///          "pattern": "^0x[0-9a-fA-F]{40}$"
    ///        },
    ///        "validAfter": {
    ///          "description": "The unix timestamp after which the payment is valid.",
    ///          "examples": [
    ///            "1716150000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "validBefore": {
    ///          "description": "The unix timestamp before which the payment is valid.",
    ///          "examples": [
    ///            "1716150000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "value": {
    ///          "description": "The value of the payment, in atomic units of the payment asset.",
    ///          "examples": [
    ///            "1000000000000000000"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "signature": {
    ///      "description": "The EIP-712 hex-encoded signature of the ERC-3009 authorization message.",
    ///      "examples": [
    ///        "0xf3746613c2d920b5fdabc0856f2aeb2d4f88ee6037b8cc5d04a71a4462f13480"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct X402ExactEvmPayload {
        pub authorization: X402ExactEvmPayloadAuthorization,
        ///The EIP-712 hex-encoded signature of the ERC-3009 authorization message.
        pub signature: ::std::string::String,
    }
    impl ::std::convert::From<&X402ExactEvmPayload> for X402ExactEvmPayload {
        fn from(value: &X402ExactEvmPayload) -> Self {
            value.clone()
        }
    }
    impl X402ExactEvmPayload {
        pub fn builder() -> builder::X402ExactEvmPayload {
            Default::default()
        }
    }
    ///The authorization data for the ERC-3009 authorization message.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The authorization data for the ERC-3009 authorization message.",
    ///  "examples": [
    ///    {
    ///      "from": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///      "nonce": "0x1234567890abcdef1234567890abcdef12345678",
    ///      "to": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///      "validAfter": "1716150000",
    ///      "validBefore": "1716150000",
    ///      "value": "1000000000000000000"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "from",
    ///    "nonce",
    ///    "to",
    ///    "validAfter",
    ///    "validBefore",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "from": {
    ///      "description": "The 0x-prefixed, checksum EVM address of the sender of the payment.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]{40}$"
    ///    },
    ///    "nonce": {
    ///      "description": "The hex-encoded nonce of the payment.",
    ///      "examples": [
    ///        "0x1234567890abcdef1234567890abcdef12345678"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "to": {
    ///      "description": "The 0x-prefixed, checksum EVM address of the recipient of the payment.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^0x[0-9a-fA-F]{40}$"
    ///    },
    ///    "validAfter": {
    ///      "description": "The unix timestamp after which the payment is valid.",
    ///      "examples": [
    ///        "1716150000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "validBefore": {
    ///      "description": "The unix timestamp before which the payment is valid.",
    ///      "examples": [
    ///        "1716150000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "value": {
    ///      "description": "The value of the payment, in atomic units of the payment asset.",
    ///      "examples": [
    ///        "1000000000000000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct X402ExactEvmPayloadAuthorization {
        ///The 0x-prefixed, checksum EVM address of the sender of the payment.
        pub from: X402ExactEvmPayloadAuthorizationFrom,
        ///The hex-encoded nonce of the payment.
        pub nonce: ::std::string::String,
        ///The 0x-prefixed, checksum EVM address of the recipient of the payment.
        pub to: X402ExactEvmPayloadAuthorizationTo,
        ///The unix timestamp after which the payment is valid.
        #[serde(rename = "validAfter")]
        pub valid_after: ::std::string::String,
        ///The unix timestamp before which the payment is valid.
        #[serde(rename = "validBefore")]
        pub valid_before: ::std::string::String,
        ///The value of the payment, in atomic units of the payment asset.
        pub value: ::std::string::String,
    }
    impl ::std::convert::From<&X402ExactEvmPayloadAuthorization> for X402ExactEvmPayloadAuthorization {
        fn from(value: &X402ExactEvmPayloadAuthorization) -> Self {
            value.clone()
        }
    }
    impl X402ExactEvmPayloadAuthorization {
        pub fn builder() -> builder::X402ExactEvmPayloadAuthorization {
            Default::default()
        }
    }
    ///The 0x-prefixed, checksum EVM address of the sender of the payment.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed, checksum EVM address of the sender of the payment.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct X402ExactEvmPayloadAuthorizationFrom(::std::string::String);
    impl ::std::ops::Deref for X402ExactEvmPayloadAuthorizationFrom {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<X402ExactEvmPayloadAuthorizationFrom> for ::std::string::String {
        fn from(value: X402ExactEvmPayloadAuthorizationFrom) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&X402ExactEvmPayloadAuthorizationFrom>
        for X402ExactEvmPayloadAuthorizationFrom
    {
        fn from(value: &X402ExactEvmPayloadAuthorizationFrom) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for X402ExactEvmPayloadAuthorizationFrom {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for X402ExactEvmPayloadAuthorizationFrom {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402ExactEvmPayloadAuthorizationFrom {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402ExactEvmPayloadAuthorizationFrom {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for X402ExactEvmPayloadAuthorizationFrom {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The 0x-prefixed, checksum EVM address of the recipient of the payment.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The 0x-prefixed, checksum EVM address of the recipient of the payment.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^0x[0-9a-fA-F]{40}$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct X402ExactEvmPayloadAuthorizationTo(::std::string::String);
    impl ::std::ops::Deref for X402ExactEvmPayloadAuthorizationTo {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<X402ExactEvmPayloadAuthorizationTo> for ::std::string::String {
        fn from(value: X402ExactEvmPayloadAuthorizationTo) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&X402ExactEvmPayloadAuthorizationTo>
        for X402ExactEvmPayloadAuthorizationTo
    {
        fn from(value: &X402ExactEvmPayloadAuthorizationTo) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for X402ExactEvmPayloadAuthorizationTo {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^0x[0-9a-fA-F]{40}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^0x[0-9a-fA-F]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for X402ExactEvmPayloadAuthorizationTo {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402ExactEvmPayloadAuthorizationTo {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402ExactEvmPayloadAuthorizationTo {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for X402ExactEvmPayloadAuthorizationTo {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The x402 protocol exact scheme payload for Solana networks. For more details, please see [Solana Exact Scheme Details](https://github.com/coinbase/x402/blob/main/specs/schemes/exact/scheme_exact_svm.md).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "x402ExactSolanaPayload",
    ///  "description": "The x402 protocol exact scheme payload for Solana networks. For more details, please see [Solana Exact Scheme Details](https://github.com/coinbase/x402/blob/main/specs/schemes/exact/scheme_exact_svm.md).",
    ///  "examples": [
    ///    {
    ///      "transaction": "AQABAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAQECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8CBgMBAQAAAAIBAwQAAAAABgIAAAAAAAYDBQEBAAAGBAgAAAAABgUAAAAA6AMAAAAAAAAGBgUBAQEBBgcEAQAAAAYICgMBAQIDBgkCBgAAAAYKAwABAQEGCwMGAQEBBgwDAAABAQAAAAA="
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "transaction"
    ///  ],
    ///  "properties": {
    ///    "transaction": {
    ///      "description": "The base64-encoded Solana transaction.",
    ///      "examples": [
    ///        "AQABAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAQECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8CBgMBAQAAAAIBAwQAAAAABgIAAAAAAAYDBQEBAAAGBAgAAAAABgUAAAAA6AMAAAAAAAAGBgUBAQEBBgcEAQAAAAYICgMBAQIDBgkCBgAAAAYKAwABAQEGCwMGAQEBBgwDAAABAQAAAAA="
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct X402ExactSolanaPayload {
        ///The base64-encoded Solana transaction.
        pub transaction: ::std::string::String,
    }
    impl ::std::convert::From<&X402ExactSolanaPayload> for X402ExactSolanaPayload {
        fn from(value: &X402ExactSolanaPayload) -> Self {
            value.clone()
        }
    }
    impl X402ExactSolanaPayload {
        pub fn builder() -> builder::X402ExactSolanaPayload {
            Default::default()
        }
    }
    ///The x402 protocol payment payload that the client attaches to x402-paid API requests to the resource server in the X-PAYMENT header.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The x402 protocol payment payload that the client attaches to x402-paid API requests to the resource server in the X-PAYMENT header.",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/x402V1PaymentPayload"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/x402V2PaymentPayload"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum X402PaymentPayload {
        #[serde(rename = "X402V1PaymentPayload")]
        X402v1PaymentPayload(X402V1PaymentPayload),
        #[serde(rename = "X402V2PaymentPayload")]
        X402v2PaymentPayload(X402V2PaymentPayload),
    }
    impl ::std::convert::From<&Self> for X402PaymentPayload {
        fn from(value: &X402PaymentPayload) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<X402V1PaymentPayload> for X402PaymentPayload {
        fn from(value: X402V1PaymentPayload) -> Self {
            Self::X402v1PaymentPayload(value)
        }
    }
    impl ::std::convert::From<X402V2PaymentPayload> for X402PaymentPayload {
        fn from(value: X402V2PaymentPayload) -> Self {
            Self::X402v2PaymentPayload(value)
        }
    }
    ///The x402 protocol payment requirements that the resource server expects the client's payment payload to meet.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The x402 protocol payment requirements that the resource server expects the client's payment payload to meet.",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/x402V1PaymentRequirements"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/x402V2PaymentRequirements"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum X402PaymentRequirements {
        #[serde(rename = "X402V1PaymentRequirements")]
        X402v1PaymentRequirements(X402V1PaymentRequirements),
        #[serde(rename = "X402V2PaymentRequirements")]
        X402v2PaymentRequirements(X402V2PaymentRequirements),
    }
    impl ::std::convert::From<&Self> for X402PaymentRequirements {
        fn from(value: &X402PaymentRequirements) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<X402V1PaymentRequirements> for X402PaymentRequirements {
        fn from(value: X402V1PaymentRequirements) -> Self {
            Self::X402v1PaymentRequirements(value)
        }
    }
    impl ::std::convert::From<X402V2PaymentRequirements> for X402PaymentRequirements {
        fn from(value: X402V2PaymentRequirements) -> Self {
            Self::X402v2PaymentRequirements(value)
        }
    }
    ///Describes the resource being accessed in x402 protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the resource being accessed in x402 protocol.",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "description": "The description of the resource.",
    ///      "examples": [
    ///        "Premium API access for data analysis"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "mimeType": {
    ///      "description": "The MIME type of the resource response.",
    ///      "examples": [
    ///        "application/json"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "url": {
    ///      "description": "The URL of the resource.",
    ///      "examples": [
    ///        "https://api.example.com/premium/resource/123"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct X402ResourceInfo {
        ///The description of the resource.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        ///The MIME type of the resource response.
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<::std::string::String>,
        ///The URL of the resource.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub url: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&X402ResourceInfo> for X402ResourceInfo {
        fn from(value: &X402ResourceInfo) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for X402ResourceInfo {
        fn default() -> Self {
            Self {
                description: Default::default(),
                mime_type: Default::default(),
                url: Default::default(),
            }
        }
    }
    impl X402ResourceInfo {
        pub fn builder() -> builder::X402ResourceInfo {
            Default::default()
        }
    }
    ///The reason the payment settlement errored on the x402 protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The reason the payment settlement errored on the x402 protocol.",
    ///  "examples": [
    ///    "insufficient_funds"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "insufficient_funds",
    ///    "invalid_scheme",
    ///    "invalid_network",
    ///    "invalid_x402_version",
    ///    "invalid_payment_requirements",
    ///    "invalid_payload",
    ///    "invalid_exact_evm_payload_authorization_value",
    ///    "invalid_exact_evm_payload_authorization_valid_after",
    ///    "invalid_exact_evm_payload_authorization_valid_before",
    ///    "invalid_exact_evm_payload_authorization_typed_data_message",
    ///    "invalid_exact_evm_payload_authorization_from_address_kyt",
    ///    "invalid_exact_evm_payload_authorization_to_address_kyt",
    ///    "invalid_exact_evm_payload_signature_address",
    ///    "settle_exact_svm_block_height_exceeded",
    ///    "settle_exact_svm_transaction_confirmation_timed_out"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum X402SettleErrorReason {
        #[serde(rename = "insufficient_funds")]
        InsufficientFunds,
        #[serde(rename = "invalid_scheme")]
        InvalidScheme,
        #[serde(rename = "invalid_network")]
        InvalidNetwork,
        #[serde(rename = "invalid_x402_version")]
        InvalidX402Version,
        #[serde(rename = "invalid_payment_requirements")]
        InvalidPaymentRequirements,
        #[serde(rename = "invalid_payload")]
        InvalidPayload,
        #[serde(rename = "invalid_exact_evm_payload_authorization_value")]
        InvalidExactEvmPayloadAuthorizationValue,
        #[serde(rename = "invalid_exact_evm_payload_authorization_valid_after")]
        InvalidExactEvmPayloadAuthorizationValidAfter,
        #[serde(rename = "invalid_exact_evm_payload_authorization_valid_before")]
        InvalidExactEvmPayloadAuthorizationValidBefore,
        #[serde(rename = "invalid_exact_evm_payload_authorization_typed_data_message")]
        InvalidExactEvmPayloadAuthorizationTypedDataMessage,
        #[serde(rename = "invalid_exact_evm_payload_authorization_from_address_kyt")]
        InvalidExactEvmPayloadAuthorizationFromAddressKyt,
        #[serde(rename = "invalid_exact_evm_payload_authorization_to_address_kyt")]
        InvalidExactEvmPayloadAuthorizationToAddressKyt,
        #[serde(rename = "invalid_exact_evm_payload_signature_address")]
        InvalidExactEvmPayloadSignatureAddress,
        #[serde(rename = "settle_exact_svm_block_height_exceeded")]
        SettleExactSvmBlockHeightExceeded,
        #[serde(rename = "settle_exact_svm_transaction_confirmation_timed_out")]
        SettleExactSvmTransactionConfirmationTimedOut,
    }
    impl ::std::convert::From<&Self> for X402SettleErrorReason {
        fn from(value: &X402SettleErrorReason) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for X402SettleErrorReason {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InsufficientFunds => f.write_str("insufficient_funds"),
                Self::InvalidScheme => f.write_str("invalid_scheme"),
                Self::InvalidNetwork => f.write_str("invalid_network"),
                Self::InvalidX402Version => f.write_str("invalid_x402_version"),
                Self::InvalidPaymentRequirements => f.write_str("invalid_payment_requirements"),
                Self::InvalidPayload => f.write_str("invalid_payload"),
                Self::InvalidExactEvmPayloadAuthorizationValue => {
                    f.write_str("invalid_exact_evm_payload_authorization_value")
                }
                Self::InvalidExactEvmPayloadAuthorizationValidAfter => {
                    f.write_str("invalid_exact_evm_payload_authorization_valid_after")
                }
                Self::InvalidExactEvmPayloadAuthorizationValidBefore => {
                    f.write_str("invalid_exact_evm_payload_authorization_valid_before")
                }
                Self::InvalidExactEvmPayloadAuthorizationTypedDataMessage => {
                    f.write_str("invalid_exact_evm_payload_authorization_typed_data_message")
                }
                Self::InvalidExactEvmPayloadAuthorizationFromAddressKyt => {
                    f.write_str("invalid_exact_evm_payload_authorization_from_address_kyt")
                }
                Self::InvalidExactEvmPayloadAuthorizationToAddressKyt => {
                    f.write_str("invalid_exact_evm_payload_authorization_to_address_kyt")
                }
                Self::InvalidExactEvmPayloadSignatureAddress => {
                    f.write_str("invalid_exact_evm_payload_signature_address")
                }
                Self::SettleExactSvmBlockHeightExceeded => {
                    f.write_str("settle_exact_svm_block_height_exceeded")
                }
                Self::SettleExactSvmTransactionConfirmationTimedOut => {
                    f.write_str("settle_exact_svm_transaction_confirmation_timed_out")
                }
            }
        }
    }
    impl ::std::str::FromStr for X402SettleErrorReason {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "insufficient_funds" => Ok(Self::InsufficientFunds),
                "invalid_scheme" => Ok(Self::InvalidScheme),
                "invalid_network" => Ok(Self::InvalidNetwork),
                "invalid_x402_version" => Ok(Self::InvalidX402Version),
                "invalid_payment_requirements" => Ok(Self::InvalidPaymentRequirements),
                "invalid_payload" => Ok(Self::InvalidPayload),
                "invalid_exact_evm_payload_authorization_value" => {
                    Ok(Self::InvalidExactEvmPayloadAuthorizationValue)
                }
                "invalid_exact_evm_payload_authorization_valid_after" => {
                    Ok(Self::InvalidExactEvmPayloadAuthorizationValidAfter)
                }
                "invalid_exact_evm_payload_authorization_valid_before" => {
                    Ok(Self::InvalidExactEvmPayloadAuthorizationValidBefore)
                }
                "invalid_exact_evm_payload_authorization_typed_data_message" => {
                    Ok(Self::InvalidExactEvmPayloadAuthorizationTypedDataMessage)
                }
                "invalid_exact_evm_payload_authorization_from_address_kyt" => {
                    Ok(Self::InvalidExactEvmPayloadAuthorizationFromAddressKyt)
                }
                "invalid_exact_evm_payload_authorization_to_address_kyt" => {
                    Ok(Self::InvalidExactEvmPayloadAuthorizationToAddressKyt)
                }
                "invalid_exact_evm_payload_signature_address" => {
                    Ok(Self::InvalidExactEvmPayloadSignatureAddress)
                }
                "settle_exact_svm_block_height_exceeded" => {
                    Ok(Self::SettleExactSvmBlockHeightExceeded)
                }
                "settle_exact_svm_transaction_confirmation_timed_out" => {
                    Ok(Self::SettleExactSvmTransactionConfirmationTimedOut)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for X402SettleErrorReason {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402SettleErrorReason {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402SettleErrorReason {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The supported payment kind for the x402 protocol. A kind is comprised of a scheme and a network, which together uniquely identify a way to move money on the x402 protocol. For more details, please see [x402 Schemes](https://github.com/coinbase/x402?tab=readme-ov-file#schemes).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The supported payment kind for the x402 protocol. A kind is comprised of a scheme and a network, which together uniquely identify a way to move money on the x402 protocol. For more details, please see [x402 Schemes](https://github.com/coinbase/x402?tab=readme-ov-file#schemes).",
    ///  "type": "object",
    ///  "required": [
    ///    "network",
    ///    "scheme",
    ///    "x402Version"
    ///  ],
    ///  "properties": {
    ///    "extra": {
    ///      "description": "The optional additional scheme-specific payment info.",
    ///      "examples": [
    ///        {
    ///          "feePayer": "HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": true
    ///    },
    ///    "network": {
    ///      "description": "The network of the blockchain.",
    ///      "examples": [
    ///        "base"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "scheme": {
    ///      "description": "The scheme of the payment protocol.",
    ///      "examples": [
    ///        "exact"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "exact"
    ///      ]
    ///    },
    ///    "x402Version": {
    ///      "$ref": "#/components/schemas/X402Version"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct X402SupportedPaymentKind {
        ///The optional additional scheme-specific payment info.
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub extra: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        ///The network of the blockchain.
        pub network: ::std::string::String,
        ///The scheme of the payment protocol.
        pub scheme: X402SupportedPaymentKindScheme,
        #[serde(rename = "x402Version")]
        pub x402_version: X402Version,
    }
    impl ::std::convert::From<&X402SupportedPaymentKind> for X402SupportedPaymentKind {
        fn from(value: &X402SupportedPaymentKind) -> Self {
            value.clone()
        }
    }
    impl X402SupportedPaymentKind {
        pub fn builder() -> builder::X402SupportedPaymentKind {
            Default::default()
        }
    }
    ///The network of the blockchain.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The network of the blockchain.",
    ///  "examples": [
    ///    "base"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "base-sepolia",
    ///    "base",
    ///    "solana-devnet",
    ///    "solana"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum X402SupportedPaymentKindNetwork {
        #[serde(rename = "base-sepolia")]
        BaseSepolia,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "solana-devnet")]
        SolanaDevnet,
        #[serde(rename = "solana")]
        Solana,
    }
    impl ::std::convert::From<&Self> for X402SupportedPaymentKindNetwork {
        fn from(value: &X402SupportedPaymentKindNetwork) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for X402SupportedPaymentKindNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BaseSepolia => f.write_str("base-sepolia"),
                Self::Base => f.write_str("base"),
                Self::SolanaDevnet => f.write_str("solana-devnet"),
                Self::Solana => f.write_str("solana"),
            }
        }
    }
    impl ::std::str::FromStr for X402SupportedPaymentKindNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base-sepolia" => Ok(Self::BaseSepolia),
                "base" => Ok(Self::Base),
                "solana-devnet" => Ok(Self::SolanaDevnet),
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for X402SupportedPaymentKindNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402SupportedPaymentKindNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402SupportedPaymentKindNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The scheme of the payment protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The scheme of the payment protocol.",
    ///  "examples": [
    ///    "exact"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "exact"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum X402SupportedPaymentKindScheme {
        #[serde(rename = "exact")]
        Exact,
    }
    impl ::std::convert::From<&Self> for X402SupportedPaymentKindScheme {
        fn from(value: &X402SupportedPaymentKindScheme) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for X402SupportedPaymentKindScheme {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Exact => f.write_str("exact"),
            }
        }
    }
    impl ::std::str::FromStr for X402SupportedPaymentKindScheme {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "exact" => Ok(Self::Exact),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for X402SupportedPaymentKindScheme {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402SupportedPaymentKindScheme {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402SupportedPaymentKindScheme {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The x402 protocol payment payload that the client attaches to x402-paid API requests to the resource server in the X-PAYMENT header.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The x402 protocol payment payload that the client attaches to x402-paid API requests to the resource server in the X-PAYMENT header.",
    ///  "examples": [
    ///    {
    ///      "network": "base",
    ///      "payload": {
    ///        "authorization": {
    ///          "from": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///          "nonce": "0x1234567890abcdef1234567890abcdef12345678",
    ///          "to": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///          "validAfter": "1716150000",
    ///          "validBefore": "1716150000",
    ///          "value": "1000000000000000000"
    ///        },
    ///        "signature": "0xf3746613c2d920b5fdabc0856f2aeb2d4f88ee6037b8cc5d04a71a4462f13480"
    ///      },
    ///      "scheme": "exact",
    ///      "x402Version": 1
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "network",
    ///    "payload",
    ///    "scheme",
    ///    "x402Version"
    ///  ],
    ///  "properties": {
    ///    "network": {
    ///      "description": "The network of the blockchain to send payment on.",
    ///      "examples": [
    ///        "base"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "base-sepolia",
    ///        "base",
    ///        "solana-devnet",
    ///        "solana"
    ///      ]
    ///    },
    ///    "payload": {
    ///      "description": "The payload of the payment depending on the x402Version, scheme, and network.",
    ///      "examples": [
    ///        {
    ///          "authorization": {
    ///            "from": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///            "nonce": "0x1234567890abcdef1234567890abcdef12345678",
    ///            "to": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///            "validAfter": "1716150000",
    ///            "validBefore": "1716150000",
    ///            "value": "1000000000000000000"
    ///          },
    ///          "signature": "0xf3746613c2d920b5fdabc0856f2aeb2d4f88ee6037b8cc5d04a71a4462f13480"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "oneOf": [
    ///        {
    ///          "$ref": "#/components/schemas/x402ExactEvmPayload"
    ///        },
    ///        {
    ///          "$ref": "#/components/schemas/x402ExactSolanaPayload"
    ///        }
    ///      ]
    ///    },
    ///    "scheme": {
    ///      "description": "The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.",
    ///      "examples": [
    ///        "exact"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "exact"
    ///      ]
    ///    },
    ///    "x402Version": {
    ///      "$ref": "#/components/schemas/X402Version"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct X402V1PaymentPayload {
        ///The network of the blockchain to send payment on.
        pub network: X402v1PaymentPayloadNetwork,
        ///The payload of the payment depending on the x402Version, scheme, and network.
        pub payload: X402v1PaymentPayloadPayload,
        ///The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.
        pub scheme: X402v1PaymentPayloadScheme,
        #[serde(rename = "x402Version")]
        pub x402_version: X402Version,
    }
    impl ::std::convert::From<&X402V1PaymentPayload> for X402V1PaymentPayload {
        fn from(value: &X402V1PaymentPayload) -> Self {
            value.clone()
        }
    }
    impl X402V1PaymentPayload {
        pub fn builder() -> builder::X402V1PaymentPayload {
            Default::default()
        }
    }
    ///The x402 protocol payment requirements that the resource server expects the client's payment payload to meet.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The x402 protocol payment requirements that the resource server expects the client's payment payload to meet.",
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "description",
    ///    "maxAmountRequired",
    ///    "maxTimeoutSeconds",
    ///    "mimeType",
    ///    "network",
    ///    "payTo",
    ///    "resource",
    ///    "scheme"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "description": "The asset to pay with.\n\nFor EVM networks, the asset will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, the asset will be a base58-encoded Solana address.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$"
    ///    },
    ///    "description": {
    ///      "description": "The description of the resource.",
    ///      "examples": [
    ///        "Premium API access for data analysis"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "extra": {
    ///      "description": "The optional additional scheme-specific payment info.",
    ///      "examples": [
    ///        {
    ///          "gasLimit": "1000000"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": true
    ///    },
    ///    "maxAmountRequired": {
    ///      "description": "The maximum amount required to pay for the resource in atomic units of the payment asset.",
    ///      "examples": [
    ///        "1000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maxTimeoutSeconds": {
    ///      "description": "The maximum time in seconds for the resource server to respond.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "mimeType": {
    ///      "description": "The MIME type of the resource response.",
    ///      "examples": [
    ///        "application/json"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "network": {
    ///      "description": "The network of the blockchain to send payment on.",
    ///      "examples": [
    ///        "base"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "base-sepolia",
    ///        "base",
    ///        "solana-devnet",
    ///        "solana"
    ///      ]
    ///    },
    ///    "outputSchema": {
    ///      "description": "The optional JSON schema describing the resource output.",
    ///      "examples": [
    ///        {
    ///          "data": "string"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": true
    ///    },
    ///    "payTo": {
    ///      "description": "The destination to pay value to.\n\nFor EVM networks, payTo will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, payTo will be a base58-encoded Solana address.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$"
    ///    },
    ///    "resource": {
    ///      "description": "The URL of the resource to pay for.",
    ///      "examples": [
    ///        "https://api.example.com/premium/resource/123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "scheme": {
    ///      "description": "The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.",
    ///      "examples": [
    ///        "exact"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "exact"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct X402V1PaymentRequirements {
        /**The asset to pay with.

        For EVM networks, the asset will be a 0x-prefixed, checksum EVM address.

        For Solana-based networks, the asset will be a base58-encoded Solana address.*/
        pub asset: X402v1PaymentRequirementsAsset,
        ///The description of the resource.
        pub description: ::std::string::String,
        ///The optional additional scheme-specific payment info.
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub extra: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        ///The maximum amount required to pay for the resource in atomic units of the payment asset.
        #[serde(rename = "maxAmountRequired")]
        pub max_amount_required: ::std::string::String,
        ///The maximum time in seconds for the resource server to respond.
        #[serde(rename = "maxTimeoutSeconds")]
        pub max_timeout_seconds: i64,
        ///The MIME type of the resource response.
        #[serde(rename = "mimeType")]
        pub mime_type: ::std::string::String,
        ///The network of the blockchain to send payment on.
        pub network: X402v1PaymentRequirementsNetwork,
        ///The optional JSON schema describing the resource output.
        #[serde(
            rename = "outputSchema",
            default,
            skip_serializing_if = "::serde_json::Map::is_empty"
        )]
        pub output_schema: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        /**The destination to pay value to.

        For EVM networks, payTo will be a 0x-prefixed, checksum EVM address.

        For Solana-based networks, payTo will be a base58-encoded Solana address.*/
        #[serde(rename = "payTo")]
        pub pay_to: X402v1PaymentRequirementsPayTo,
        ///The URL of the resource to pay for.
        pub resource: ::std::string::String,
        ///The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.
        pub scheme: X402v1PaymentRequirementsScheme,
    }
    impl ::std::convert::From<&X402V1PaymentRequirements> for X402V1PaymentRequirements {
        fn from(value: &X402V1PaymentRequirements) -> Self {
            value.clone()
        }
    }
    impl X402V1PaymentRequirements {
        pub fn builder() -> builder::X402V1PaymentRequirements {
            Default::default()
        }
    }
    ///The x402 protocol payment payload that the client attaches to x402-paid API requests to the resource server in the X-PAYMENT header.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The x402 protocol payment payload that the client attaches to x402-paid API requests to the resource server in the X-PAYMENT header.",
    ///  "examples": [
    ///    {
    ///      "accepted": {
    ///        "amount": "1000",
    ///        "asset": "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
    ///        "extra": {
    ///          "name": "USDC",
    ///          "version": "2"
    ///        },
    ///        "maxTimeoutSeconds": 60,
    ///        "network": "eip155:84532",
    ///        "payTo": "0x122F8Fcaf2152420445Aa424E1D8C0306935B5c9",
    ///        "scheme": "exact"
    ///      },
    ///      "payload": {
    ///        "authorization": {
    ///          "from": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///          "nonce": "0x1234567890abcdef1234567890abcdef12345678",
    ///          "to": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///          "validAfter": "1716150000",
    ///          "validBefore": "1716150000",
    ///          "value": "1000000000000000000"
    ///        },
    ///        "signature": "0xf3746613c2d920b5fdabc0856f2aeb2d4f88ee6037b8cc5d04a71a4462f13480"
    ///      },
    ///      "resource": {
    ///        "description": "Premium API access for data analysis.",
    ///        "mimeType": "application/json",
    ///        "url": "https://api.example.com/premium/resource/123"
    ///      },
    ///      "x402Version": 2
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "accepted",
    ///    "payload",
    ///    "x402Version"
    ///  ],
    ///  "properties": {
    ///    "accepted": {
    ///      "$ref": "#/components/schemas/x402V2PaymentRequirements"
    ///    },
    ///    "extensions": {
    ///      "description": "Optional protocol extensions.",
    ///      "examples": [
    ///        {
    ///          "bazaar": {
    ///            "discoveryEnabled": true
    ///          }
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": true
    ///    },
    ///    "payload": {
    ///      "description": "The payload of the payment depending on the x402Version, scheme, and network.",
    ///      "examples": [
    ///        {
    ///          "authorization": {
    ///            "from": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///            "nonce": "0x1234567890abcdef1234567890abcdef12345678",
    ///            "to": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///            "validAfter": "1716150000",
    ///            "validBefore": "1716150000",
    ///            "value": "1000000000000000000"
    ///          },
    ///          "signature": "0xf3746613c2d920b5fdabc0856f2aeb2d4f88ee6037b8cc5d04a71a4462f13480"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "oneOf": [
    ///        {
    ///          "$ref": "#/components/schemas/x402ExactEvmPayload"
    ///        },
    ///        {
    ///          "$ref": "#/components/schemas/x402ExactSolanaPayload"
    ///        }
    ///      ]
    ///    },
    ///    "resource": {
    ///      "$ref": "#/components/schemas/x402ResourceInfo"
    ///    },
    ///    "x402Version": {
    ///      "$ref": "#/components/schemas/X402Version"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct X402V2PaymentPayload {
        pub accepted: X402V2PaymentRequirements,
        ///Optional protocol extensions.
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub extensions: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        ///The payload of the payment depending on the x402Version, scheme, and network.
        pub payload: X402v2PaymentPayloadPayload,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resource: ::std::option::Option<X402ResourceInfo>,
        #[serde(rename = "x402Version")]
        pub x402_version: X402Version,
    }
    impl ::std::convert::From<&X402V2PaymentPayload> for X402V2PaymentPayload {
        fn from(value: &X402V2PaymentPayload) -> Self {
            value.clone()
        }
    }
    impl X402V2PaymentPayload {
        pub fn builder() -> builder::X402V2PaymentPayload {
            Default::default()
        }
    }
    ///The x402 protocol payment requirements that the resource server expects the client's payment payload to meet.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The x402 protocol payment requirements that the resource server expects the client's payment payload to meet.",
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "maxTimeoutSeconds",
    ///    "network",
    ///    "payTo",
    ///    "scheme"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "The amount to pay for the resource in atomic units of the payment asset.",
    ///      "examples": [
    ///        "1000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "description": "The asset to pay with.\n\nFor EVM networks, the asset will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, the asset will be a base58-encoded Solana address.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$"
    ///    },
    ///    "extra": {
    ///      "description": "The optional additional scheme-specific payment info.",
    ///      "examples": [
    ///        {
    ///          "name": "USDC",
    ///          "version": "2"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": true
    ///    },
    ///    "maxTimeoutSeconds": {
    ///      "description": "The maximum time in seconds for the resource server to respond.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "network": {
    ///      "description": "The network of the blockchain to send payment on in caip2 format.",
    ///      "examples": [
    ///        "eip155:1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "payTo": {
    ///      "description": "The destination to pay value to.\n\nFor EVM networks, payTo will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, payTo will be a base58-encoded Solana address.",
    ///      "examples": [
    ///        "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///      ],
    ///      "type": "string",
    ///      "pattern": "^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$"
    ///    },
    ///    "scheme": {
    ///      "description": "The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.",
    ///      "examples": [
    ///        "exact"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "exact"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct X402V2PaymentRequirements {
        ///The amount to pay for the resource in atomic units of the payment asset.
        pub amount: ::std::string::String,
        /**The asset to pay with.

        For EVM networks, the asset will be a 0x-prefixed, checksum EVM address.

        For Solana-based networks, the asset will be a base58-encoded Solana address.*/
        pub asset: X402v2PaymentRequirementsAsset,
        ///The optional additional scheme-specific payment info.
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub extra: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        ///The maximum time in seconds for the resource server to respond.
        #[serde(rename = "maxTimeoutSeconds")]
        pub max_timeout_seconds: i64,
        ///The network of the blockchain to send payment on in caip2 format.
        pub network: ::std::string::String,
        /**The destination to pay value to.

        For EVM networks, payTo will be a 0x-prefixed, checksum EVM address.

        For Solana-based networks, payTo will be a base58-encoded Solana address.*/
        #[serde(rename = "payTo")]
        pub pay_to: X402v2PaymentRequirementsPayTo,
        ///The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.
        pub scheme: X402v2PaymentRequirementsScheme,
    }
    impl ::std::convert::From<&X402V2PaymentRequirements> for X402V2PaymentRequirements {
        fn from(value: &X402V2PaymentRequirements) -> Self {
            value.clone()
        }
    }
    impl X402V2PaymentRequirements {
        pub fn builder() -> builder::X402V2PaymentRequirements {
            Default::default()
        }
    }
    ///The reason the payment is invalid on the x402 protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The reason the payment is invalid on the x402 protocol.",
    ///  "examples": [
    ///    "insufficient_funds"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "insufficient_funds",
    ///    "invalid_scheme",
    ///    "invalid_network",
    ///    "invalid_x402_version",
    ///    "invalid_payment_requirements",
    ///    "invalid_payload",
    ///    "invalid_exact_evm_payload_authorization_value",
    ///    "invalid_exact_evm_payload_authorization_value_too_low",
    ///    "invalid_exact_evm_payload_authorization_valid_after",
    ///    "invalid_exact_evm_payload_authorization_valid_before",
    ///    "invalid_exact_evm_payload_authorization_typed_data_message",
    ///    "invalid_exact_evm_payload_authorization_from_address_kyt",
    ///    "invalid_exact_evm_payload_authorization_to_address_kyt",
    ///    "invalid_exact_evm_payload_signature",
    ///    "invalid_exact_evm_payload_signature_address",
    ///    "invalid_exact_svm_payload_transaction",
    ///    "invalid_exact_svm_payload_transaction_amount_mismatch",
    ///    "invalid_exact_svm_payload_transaction_create_ata_instruction",
    ///    "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee",
    ///    "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset",
    ///    "invalid_exact_svm_payload_transaction_instructions",
    ///    "invalid_exact_svm_payload_transaction_instructions_length",
    ///    "invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction",
    ///    "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction",
    ///    "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high",
    ///    "invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked",
    ///    "invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked",
    ///    "invalid_exact_svm_payload_transaction_not_a_transfer_instruction",
    ///    "invalid_exact_svm_payload_transaction_cannot_derive_receiver_ata",
    ///    "invalid_exact_svm_payload_transaction_receiver_ata_not_found",
    ///    "invalid_exact_svm_payload_transaction_sender_ata_not_found",
    ///    "invalid_exact_svm_payload_transaction_simulation_failed",
    ///    "invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata",
    ///    "invalid_exact_svm_payload_transaction_fee_payer_included_in_instruction_accounts",
    ///    "invalid_exact_svm_payload_transaction_fee_payer_transferring_funds"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum X402VerifyInvalidReason {
        #[serde(rename = "insufficient_funds")]
        InsufficientFunds,
        #[serde(rename = "invalid_scheme")]
        InvalidScheme,
        #[serde(rename = "invalid_network")]
        InvalidNetwork,
        #[serde(rename = "invalid_x402_version")]
        InvalidX402Version,
        #[serde(rename = "invalid_payment_requirements")]
        InvalidPaymentRequirements,
        #[serde(rename = "invalid_payload")]
        InvalidPayload,
        #[serde(rename = "invalid_exact_evm_payload_authorization_value")]
        InvalidExactEvmPayloadAuthorizationValue,
        #[serde(rename = "invalid_exact_evm_payload_authorization_value_too_low")]
        InvalidExactEvmPayloadAuthorizationValueTooLow,
        #[serde(rename = "invalid_exact_evm_payload_authorization_valid_after")]
        InvalidExactEvmPayloadAuthorizationValidAfter,
        #[serde(rename = "invalid_exact_evm_payload_authorization_valid_before")]
        InvalidExactEvmPayloadAuthorizationValidBefore,
        #[serde(rename = "invalid_exact_evm_payload_authorization_typed_data_message")]
        InvalidExactEvmPayloadAuthorizationTypedDataMessage,
        #[serde(rename = "invalid_exact_evm_payload_authorization_from_address_kyt")]
        InvalidExactEvmPayloadAuthorizationFromAddressKyt,
        #[serde(rename = "invalid_exact_evm_payload_authorization_to_address_kyt")]
        InvalidExactEvmPayloadAuthorizationToAddressKyt,
        #[serde(rename = "invalid_exact_evm_payload_signature")]
        InvalidExactEvmPayloadSignature,
        #[serde(rename = "invalid_exact_evm_payload_signature_address")]
        InvalidExactEvmPayloadSignatureAddress,
        #[serde(rename = "invalid_exact_svm_payload_transaction")]
        InvalidExactSvmPayloadTransaction,
        #[serde(rename = "invalid_exact_svm_payload_transaction_amount_mismatch")]
        InvalidExactSvmPayloadTransactionAmountMismatch,
        #[serde(rename = "invalid_exact_svm_payload_transaction_create_ata_instruction")]
        InvalidExactSvmPayloadTransactionCreateAtaInstruction,
        #[serde(
            rename = "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee"
        )]
        InvalidExactSvmPayloadTransactionCreateAtaInstructionIncorrectPayee,
        #[serde(
            rename = "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset"
        )]
        InvalidExactSvmPayloadTransactionCreateAtaInstructionIncorrectAsset,
        #[serde(rename = "invalid_exact_svm_payload_transaction_instructions")]
        InvalidExactSvmPayloadTransactionInstructions,
        #[serde(rename = "invalid_exact_svm_payload_transaction_instructions_length")]
        InvalidExactSvmPayloadTransactionInstructionsLength,
        #[serde(
            rename = "invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction"
        )]
        InvalidExactSvmPayloadTransactionInstructionsComputeLimitInstruction,
        #[serde(
            rename = "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction"
        )]
        InvalidExactSvmPayloadTransactionInstructionsComputePriceInstruction,
        #[serde(
            rename = "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high"
        )]
        InvalidExactSvmPayloadTransactionInstructionsComputePriceInstructionTooHigh,
        #[serde(
            rename = "invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked"
        )]
        InvalidExactSvmPayloadTransactionInstructionNotSplTokenTransferChecked,
        #[serde(
            rename = "invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked"
        )]
        InvalidExactSvmPayloadTransactionInstructionNotToken2022TransferChecked,
        #[serde(rename = "invalid_exact_svm_payload_transaction_not_a_transfer_instruction")]
        InvalidExactSvmPayloadTransactionNotATransferInstruction,
        #[serde(rename = "invalid_exact_svm_payload_transaction_cannot_derive_receiver_ata")]
        InvalidExactSvmPayloadTransactionCannotDeriveReceiverAta,
        #[serde(rename = "invalid_exact_svm_payload_transaction_receiver_ata_not_found")]
        InvalidExactSvmPayloadTransactionReceiverAtaNotFound,
        #[serde(rename = "invalid_exact_svm_payload_transaction_sender_ata_not_found")]
        InvalidExactSvmPayloadTransactionSenderAtaNotFound,
        #[serde(rename = "invalid_exact_svm_payload_transaction_simulation_failed")]
        InvalidExactSvmPayloadTransactionSimulationFailed,
        #[serde(rename = "invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata")]
        InvalidExactSvmPayloadTransactionTransferToIncorrectAta,
        #[serde(
            rename = "invalid_exact_svm_payload_transaction_fee_payer_included_in_instruction_accounts"
        )]
        InvalidExactSvmPayloadTransactionFeePayerIncludedInInstructionAccounts,
        #[serde(rename = "invalid_exact_svm_payload_transaction_fee_payer_transferring_funds")]
        InvalidExactSvmPayloadTransactionFeePayerTransferringFunds,
    }
    impl ::std::convert::From<&Self> for X402VerifyInvalidReason {
        fn from(value: &X402VerifyInvalidReason) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for X402VerifyInvalidReason {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InsufficientFunds => f.write_str("insufficient_funds"),
                Self::InvalidScheme => f.write_str("invalid_scheme"),
                Self::InvalidNetwork => f.write_str("invalid_network"),
                Self::InvalidX402Version => f.write_str("invalid_x402_version"),
                Self::InvalidPaymentRequirements => {
                    f.write_str("invalid_payment_requirements")
                }
                Self::InvalidPayload => f.write_str("invalid_payload"),
                Self::InvalidExactEvmPayloadAuthorizationValue => {
                    f.write_str("invalid_exact_evm_payload_authorization_value")
                }
                Self::InvalidExactEvmPayloadAuthorizationValueTooLow => {
                    f.write_str("invalid_exact_evm_payload_authorization_value_too_low")
                }
                Self::InvalidExactEvmPayloadAuthorizationValidAfter => {
                    f.write_str("invalid_exact_evm_payload_authorization_valid_after")
                }
                Self::InvalidExactEvmPayloadAuthorizationValidBefore => {
                    f.write_str("invalid_exact_evm_payload_authorization_valid_before")
                }
                Self::InvalidExactEvmPayloadAuthorizationTypedDataMessage => {
                    f.write_str(
                        "invalid_exact_evm_payload_authorization_typed_data_message",
                    )
                }
                Self::InvalidExactEvmPayloadAuthorizationFromAddressKyt => {
                    f.write_str(
                        "invalid_exact_evm_payload_authorization_from_address_kyt",
                    )
                }
                Self::InvalidExactEvmPayloadAuthorizationToAddressKyt => {
                    f.write_str("invalid_exact_evm_payload_authorization_to_address_kyt")
                }
                Self::InvalidExactEvmPayloadSignature => {
                    f.write_str("invalid_exact_evm_payload_signature")
                }
                Self::InvalidExactEvmPayloadSignatureAddress => {
                    f.write_str("invalid_exact_evm_payload_signature_address")
                }
                Self::InvalidExactSvmPayloadTransaction => {
                    f.write_str("invalid_exact_svm_payload_transaction")
                }
                Self::InvalidExactSvmPayloadTransactionAmountMismatch => {
                    f.write_str("invalid_exact_svm_payload_transaction_amount_mismatch")
                }
                Self::InvalidExactSvmPayloadTransactionCreateAtaInstruction => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_create_ata_instruction",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionCreateAtaInstructionIncorrectPayee => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionCreateAtaInstructionIncorrectAsset => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionInstructions => {
                    f.write_str("invalid_exact_svm_payload_transaction_instructions")
                }
                Self::InvalidExactSvmPayloadTransactionInstructionsLength => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_instructions_length",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionInstructionsComputeLimitInstruction => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionInstructionsComputePriceInstruction => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionInstructionsComputePriceInstructionTooHigh => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionInstructionNotSplTokenTransferChecked => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionInstructionNotToken2022TransferChecked => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionNotATransferInstruction => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_not_a_transfer_instruction",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionCannotDeriveReceiverAta => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_cannot_derive_receiver_ata",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionReceiverAtaNotFound => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_receiver_ata_not_found",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionSenderAtaNotFound => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_sender_ata_not_found",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionSimulationFailed => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_simulation_failed",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionTransferToIncorrectAta => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionFeePayerIncludedInInstructionAccounts => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_fee_payer_included_in_instruction_accounts",
                    )
                }
                Self::InvalidExactSvmPayloadTransactionFeePayerTransferringFunds => {
                    f.write_str(
                        "invalid_exact_svm_payload_transaction_fee_payer_transferring_funds",
                    )
                }
            }
        }
    }
    impl ::std::str::FromStr for X402VerifyInvalidReason {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "insufficient_funds" => Ok(Self::InsufficientFunds),
                "invalid_scheme" => Ok(Self::InvalidScheme),
                "invalid_network" => Ok(Self::InvalidNetwork),
                "invalid_x402_version" => Ok(Self::InvalidX402Version),
                "invalid_payment_requirements" => Ok(Self::InvalidPaymentRequirements),
                "invalid_payload" => Ok(Self::InvalidPayload),
                "invalid_exact_evm_payload_authorization_value" => {
                    Ok(Self::InvalidExactEvmPayloadAuthorizationValue)
                }
                "invalid_exact_evm_payload_authorization_value_too_low" => {
                    Ok(Self::InvalidExactEvmPayloadAuthorizationValueTooLow)
                }
                "invalid_exact_evm_payload_authorization_valid_after" => {
                    Ok(Self::InvalidExactEvmPayloadAuthorizationValidAfter)
                }
                "invalid_exact_evm_payload_authorization_valid_before" => {
                    Ok(Self::InvalidExactEvmPayloadAuthorizationValidBefore)
                }
                "invalid_exact_evm_payload_authorization_typed_data_message" => {
                    Ok(Self::InvalidExactEvmPayloadAuthorizationTypedDataMessage)
                }
                "invalid_exact_evm_payload_authorization_from_address_kyt" => {
                    Ok(Self::InvalidExactEvmPayloadAuthorizationFromAddressKyt)
                }
                "invalid_exact_evm_payload_authorization_to_address_kyt" => {
                    Ok(Self::InvalidExactEvmPayloadAuthorizationToAddressKyt)
                }
                "invalid_exact_evm_payload_signature" => {
                    Ok(Self::InvalidExactEvmPayloadSignature)
                }
                "invalid_exact_evm_payload_signature_address" => {
                    Ok(Self::InvalidExactEvmPayloadSignatureAddress)
                }
                "invalid_exact_svm_payload_transaction" => {
                    Ok(Self::InvalidExactSvmPayloadTransaction)
                }
                "invalid_exact_svm_payload_transaction_amount_mismatch" => {
                    Ok(Self::InvalidExactSvmPayloadTransactionAmountMismatch)
                }
                "invalid_exact_svm_payload_transaction_create_ata_instruction" => {
                    Ok(Self::InvalidExactSvmPayloadTransactionCreateAtaInstruction)
                }
                "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee" => {
                    Ok(
                        Self::InvalidExactSvmPayloadTransactionCreateAtaInstructionIncorrectPayee,
                    )
                }
                "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset" => {
                    Ok(
                        Self::InvalidExactSvmPayloadTransactionCreateAtaInstructionIncorrectAsset,
                    )
                }
                "invalid_exact_svm_payload_transaction_instructions" => {
                    Ok(Self::InvalidExactSvmPayloadTransactionInstructions)
                }
                "invalid_exact_svm_payload_transaction_instructions_length" => {
                    Ok(Self::InvalidExactSvmPayloadTransactionInstructionsLength)
                }
                "invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction" => {
                    Ok(
                        Self::InvalidExactSvmPayloadTransactionInstructionsComputeLimitInstruction,
                    )
                }
                "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction" => {
                    Ok(
                        Self::InvalidExactSvmPayloadTransactionInstructionsComputePriceInstruction,
                    )
                }
                "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high" => {
                    Ok(
                        Self::InvalidExactSvmPayloadTransactionInstructionsComputePriceInstructionTooHigh,
                    )
                }
                "invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked" => {
                    Ok(
                        Self::InvalidExactSvmPayloadTransactionInstructionNotSplTokenTransferChecked,
                    )
                }
                "invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked" => {
                    Ok(
                        Self::InvalidExactSvmPayloadTransactionInstructionNotToken2022TransferChecked,
                    )
                }
                "invalid_exact_svm_payload_transaction_not_a_transfer_instruction" => {
                    Ok(Self::InvalidExactSvmPayloadTransactionNotATransferInstruction)
                }
                "invalid_exact_svm_payload_transaction_cannot_derive_receiver_ata" => {
                    Ok(Self::InvalidExactSvmPayloadTransactionCannotDeriveReceiverAta)
                }
                "invalid_exact_svm_payload_transaction_receiver_ata_not_found" => {
                    Ok(Self::InvalidExactSvmPayloadTransactionReceiverAtaNotFound)
                }
                "invalid_exact_svm_payload_transaction_sender_ata_not_found" => {
                    Ok(Self::InvalidExactSvmPayloadTransactionSenderAtaNotFound)
                }
                "invalid_exact_svm_payload_transaction_simulation_failed" => {
                    Ok(Self::InvalidExactSvmPayloadTransactionSimulationFailed)
                }
                "invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata" => {
                    Ok(Self::InvalidExactSvmPayloadTransactionTransferToIncorrectAta)
                }
                "invalid_exact_svm_payload_transaction_fee_payer_included_in_instruction_accounts" => {
                    Ok(
                        Self::InvalidExactSvmPayloadTransactionFeePayerIncludedInInstructionAccounts,
                    )
                }
                "invalid_exact_svm_payload_transaction_fee_payer_transferring_funds" => {
                    Ok(Self::InvalidExactSvmPayloadTransactionFeePayerTransferringFunds)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for X402VerifyInvalidReason {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402VerifyInvalidReason {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402VerifyInvalidReason {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the x402 protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the x402 protocol.",
    ///  "examples": [
    ///    1
    ///  ],
    ///  "type": "integer",
    ///  "enum": [
    ///    1,
    ///    2
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct X402Version(i64);
    impl ::std::ops::Deref for X402Version {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }
    impl ::std::convert::From<X402Version> for i64 {
        fn from(value: X402Version) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&X402Version> for X402Version {
        fn from(value: &X402Version) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::TryFrom<i64> for X402Version {
        type Error = self::error::ConversionError;
        fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![1_i64, 2_i64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }
    impl<'de> ::serde::Deserialize<'de> for X402Version {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<i64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }
    ///The network of the blockchain to send payment on.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The network of the blockchain to send payment on.",
    ///  "examples": [
    ///    "base"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "base-sepolia",
    ///    "base",
    ///    "solana-devnet",
    ///    "solana"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum X402v1PaymentPayloadNetwork {
        #[serde(rename = "base-sepolia")]
        BaseSepolia,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "solana-devnet")]
        SolanaDevnet,
        #[serde(rename = "solana")]
        Solana,
    }
    impl ::std::convert::From<&Self> for X402v1PaymentPayloadNetwork {
        fn from(value: &X402v1PaymentPayloadNetwork) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for X402v1PaymentPayloadNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BaseSepolia => f.write_str("base-sepolia"),
                Self::Base => f.write_str("base"),
                Self::SolanaDevnet => f.write_str("solana-devnet"),
                Self::Solana => f.write_str("solana"),
            }
        }
    }
    impl ::std::str::FromStr for X402v1PaymentPayloadNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base-sepolia" => Ok(Self::BaseSepolia),
                "base" => Ok(Self::Base),
                "solana-devnet" => Ok(Self::SolanaDevnet),
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for X402v1PaymentPayloadNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402v1PaymentPayloadNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402v1PaymentPayloadNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The payload of the payment depending on the x402Version, scheme, and network.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The payload of the payment depending on the x402Version, scheme, and network.",
    ///  "examples": [
    ///    {
    ///      "authorization": {
    ///        "from": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///        "nonce": "0x1234567890abcdef1234567890abcdef12345678",
    ///        "to": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///        "validAfter": "1716150000",
    ///        "validBefore": "1716150000",
    ///        "value": "1000000000000000000"
    ///      },
    ///      "signature": "0xf3746613c2d920b5fdabc0856f2aeb2d4f88ee6037b8cc5d04a71a4462f13480"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/x402ExactEvmPayload"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/x402ExactSolanaPayload"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum X402v1PaymentPayloadPayload {
        EvmPayload(X402ExactEvmPayload),
        SolanaPayload(X402ExactSolanaPayload),
    }
    impl ::std::convert::From<&Self> for X402v1PaymentPayloadPayload {
        fn from(value: &X402v1PaymentPayloadPayload) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<X402ExactEvmPayload> for X402v1PaymentPayloadPayload {
        fn from(value: X402ExactEvmPayload) -> Self {
            Self::EvmPayload(value)
        }
    }
    impl ::std::convert::From<X402ExactSolanaPayload> for X402v1PaymentPayloadPayload {
        fn from(value: X402ExactSolanaPayload) -> Self {
            Self::SolanaPayload(value)
        }
    }
    ///The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.",
    ///  "examples": [
    ///    "exact"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "exact"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum X402v1PaymentPayloadScheme {
        #[serde(rename = "exact")]
        Exact,
    }
    impl ::std::convert::From<&Self> for X402v1PaymentPayloadScheme {
        fn from(value: &X402v1PaymentPayloadScheme) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for X402v1PaymentPayloadScheme {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Exact => f.write_str("exact"),
            }
        }
    }
    impl ::std::str::FromStr for X402v1PaymentPayloadScheme {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "exact" => Ok(Self::Exact),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for X402v1PaymentPayloadScheme {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402v1PaymentPayloadScheme {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402v1PaymentPayloadScheme {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    /**The asset to pay with.

    For EVM networks, the asset will be a 0x-prefixed, checksum EVM address.

    For Solana-based networks, the asset will be a base58-encoded Solana address.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The asset to pay with.\n\nFor EVM networks, the asset will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, the asset will be a base58-encoded Solana address.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct X402v1PaymentRequirementsAsset(::std::string::String);
    impl ::std::ops::Deref for X402v1PaymentRequirementsAsset {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<X402v1PaymentRequirementsAsset> for ::std::string::String {
        fn from(value: X402v1PaymentRequirementsAsset) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&X402v1PaymentRequirementsAsset> for X402v1PaymentRequirementsAsset {
        fn from(value: &X402v1PaymentRequirementsAsset) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for X402v1PaymentRequirementsAsset {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$")
                        .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for X402v1PaymentRequirementsAsset {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402v1PaymentRequirementsAsset {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402v1PaymentRequirementsAsset {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for X402v1PaymentRequirementsAsset {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The network of the blockchain to send payment on.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The network of the blockchain to send payment on.",
    ///  "examples": [
    ///    "base"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "base-sepolia",
    ///    "base",
    ///    "solana-devnet",
    ///    "solana"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum X402v1PaymentRequirementsNetwork {
        #[serde(rename = "base-sepolia")]
        BaseSepolia,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "solana-devnet")]
        SolanaDevnet,
        #[serde(rename = "solana")]
        Solana,
    }
    impl ::std::convert::From<&Self> for X402v1PaymentRequirementsNetwork {
        fn from(value: &X402v1PaymentRequirementsNetwork) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for X402v1PaymentRequirementsNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BaseSepolia => f.write_str("base-sepolia"),
                Self::Base => f.write_str("base"),
                Self::SolanaDevnet => f.write_str("solana-devnet"),
                Self::Solana => f.write_str("solana"),
            }
        }
    }
    impl ::std::str::FromStr for X402v1PaymentRequirementsNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base-sepolia" => Ok(Self::BaseSepolia),
                "base" => Ok(Self::Base),
                "solana-devnet" => Ok(Self::SolanaDevnet),
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for X402v1PaymentRequirementsNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402v1PaymentRequirementsNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402v1PaymentRequirementsNetwork {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    /**The destination to pay value to.

    For EVM networks, payTo will be a 0x-prefixed, checksum EVM address.

    For Solana-based networks, payTo will be a base58-encoded Solana address.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The destination to pay value to.\n\nFor EVM networks, payTo will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, payTo will be a base58-encoded Solana address.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct X402v1PaymentRequirementsPayTo(::std::string::String);
    impl ::std::ops::Deref for X402v1PaymentRequirementsPayTo {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<X402v1PaymentRequirementsPayTo> for ::std::string::String {
        fn from(value: X402v1PaymentRequirementsPayTo) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&X402v1PaymentRequirementsPayTo> for X402v1PaymentRequirementsPayTo {
        fn from(value: &X402v1PaymentRequirementsPayTo) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for X402v1PaymentRequirementsPayTo {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$")
                        .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for X402v1PaymentRequirementsPayTo {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402v1PaymentRequirementsPayTo {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402v1PaymentRequirementsPayTo {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for X402v1PaymentRequirementsPayTo {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.",
    ///  "examples": [
    ///    "exact"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "exact"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum X402v1PaymentRequirementsScheme {
        #[serde(rename = "exact")]
        Exact,
    }
    impl ::std::convert::From<&Self> for X402v1PaymentRequirementsScheme {
        fn from(value: &X402v1PaymentRequirementsScheme) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for X402v1PaymentRequirementsScheme {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Exact => f.write_str("exact"),
            }
        }
    }
    impl ::std::str::FromStr for X402v1PaymentRequirementsScheme {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "exact" => Ok(Self::Exact),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for X402v1PaymentRequirementsScheme {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402v1PaymentRequirementsScheme {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402v1PaymentRequirementsScheme {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The payload of the payment depending on the x402Version, scheme, and network.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The payload of the payment depending on the x402Version, scheme, and network.",
    ///  "examples": [
    ///    {
    ///      "authorization": {
    ///        "from": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///        "nonce": "0x1234567890abcdef1234567890abcdef12345678",
    ///        "to": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
    ///        "validAfter": "1716150000",
    ///        "validBefore": "1716150000",
    ///        "value": "1000000000000000000"
    ///      },
    ///      "signature": "0xf3746613c2d920b5fdabc0856f2aeb2d4f88ee6037b8cc5d04a71a4462f13480"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/x402ExactEvmPayload"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/x402ExactSolanaPayload"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum X402v2PaymentPayloadPayload {
        EvmPayload(X402ExactEvmPayload),
        SolanaPayload(X402ExactSolanaPayload),
    }
    impl ::std::convert::From<&Self> for X402v2PaymentPayloadPayload {
        fn from(value: &X402v2PaymentPayloadPayload) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<X402ExactEvmPayload> for X402v2PaymentPayloadPayload {
        fn from(value: X402ExactEvmPayload) -> Self {
            Self::EvmPayload(value)
        }
    }
    impl ::std::convert::From<X402ExactSolanaPayload> for X402v2PaymentPayloadPayload {
        fn from(value: X402ExactSolanaPayload) -> Self {
            Self::SolanaPayload(value)
        }
    }
    /**The asset to pay with.

    For EVM networks, the asset will be a 0x-prefixed, checksum EVM address.

    For Solana-based networks, the asset will be a base58-encoded Solana address.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The asset to pay with.\n\nFor EVM networks, the asset will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, the asset will be a base58-encoded Solana address.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct X402v2PaymentRequirementsAsset(::std::string::String);
    impl ::std::ops::Deref for X402v2PaymentRequirementsAsset {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<X402v2PaymentRequirementsAsset> for ::std::string::String {
        fn from(value: X402v2PaymentRequirementsAsset) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&X402v2PaymentRequirementsAsset> for X402v2PaymentRequirementsAsset {
        fn from(value: &X402v2PaymentRequirementsAsset) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for X402v2PaymentRequirementsAsset {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$")
                        .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for X402v2PaymentRequirementsAsset {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402v2PaymentRequirementsAsset {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402v2PaymentRequirementsAsset {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for X402v2PaymentRequirementsAsset {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    /**The destination to pay value to.

    For EVM networks, payTo will be a 0x-prefixed, checksum EVM address.

    For Solana-based networks, payTo will be a base58-encoded Solana address.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The destination to pay value to.\n\nFor EVM networks, payTo will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, payTo will be a base58-encoded Solana address.",
    ///  "examples": [
    ///    "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    ///  ],
    ///  "type": "string",
    ///  "pattern": "^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct X402v2PaymentRequirementsPayTo(::std::string::String);
    impl ::std::ops::Deref for X402v2PaymentRequirementsPayTo {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<X402v2PaymentRequirementsPayTo> for ::std::string::String {
        fn from(value: X402v2PaymentRequirementsPayTo) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&X402v2PaymentRequirementsPayTo> for X402v2PaymentRequirementsPayTo {
        fn from(value: &X402v2PaymentRequirementsPayTo) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for X402v2PaymentRequirementsPayTo {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$")
                        .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^(0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44})$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for X402v2PaymentRequirementsPayTo {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402v2PaymentRequirementsPayTo {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402v2PaymentRequirementsPayTo {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for X402v2PaymentRequirementsPayTo {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.",
    ///  "examples": [
    ///    "exact"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "exact"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum X402v2PaymentRequirementsScheme {
        #[serde(rename = "exact")]
        Exact,
    }
    impl ::std::convert::From<&Self> for X402v2PaymentRequirementsScheme {
        fn from(value: &X402v2PaymentRequirementsScheme) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for X402v2PaymentRequirementsScheme {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Exact => f.write_str("exact"),
            }
        }
    }
    impl ::std::str::FromStr for X402v2PaymentRequirementsScheme {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "exact" => Ok(Self::Exact),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for X402v2PaymentRequirementsScheme {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for X402v2PaymentRequirementsScheme {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for X402v2PaymentRequirementsScheme {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    /// Types for composing complex structures.
    pub mod builder {
        #[derive(Clone, Debug)]
        pub struct AbiFunction {
            constant: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            gas: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            inputs:
                ::std::result::Result<::std::vec::Vec<super::AbiParameter>, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            outputs:
                ::std::result::Result<::std::vec::Vec<super::AbiParameter>, ::std::string::String>,
            payable: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            state_mutability:
                ::std::result::Result<super::AbiStateMutability, ::std::string::String>,
            type_: ::std::result::Result<super::AbiFunctionType, ::std::string::String>,
        }
        impl ::std::default::Default for AbiFunction {
            fn default() -> Self {
                Self {
                    constant: Ok(Default::default()),
                    gas: Ok(Default::default()),
                    inputs: Err("no value supplied for inputs".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    outputs: Err("no value supplied for outputs".to_string()),
                    payable: Ok(Default::default()),
                    state_mutability: Err("no value supplied for state_mutability".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl AbiFunction {
            pub fn constant<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.constant = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for constant: {}", e));
                self
            }
            pub fn gas<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.gas = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas: {}", e));
                self
            }
            pub fn inputs<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AbiParameter>>,
                T::Error: ::std::fmt::Display,
            {
                self.inputs = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for inputs: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn outputs<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AbiParameter>>,
                T::Error: ::std::fmt::Display,
            {
                self.outputs = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for outputs: {}", e));
                self
            }
            pub fn payable<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.payable = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for payable: {}", e));
                self
            }
            pub fn state_mutability<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AbiStateMutability>,
                T::Error: ::std::fmt::Display,
            {
                self.state_mutability = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for state_mutability: {}",
                        e
                    )
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AbiFunctionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<AbiFunction> for super::AbiFunction {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AbiFunction,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    constant: value.constant?,
                    gas: value.gas?,
                    inputs: value.inputs?,
                    name: value.name?,
                    outputs: value.outputs?,
                    payable: value.payable?,
                    state_mutability: value.state_mutability?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::AbiFunction> for AbiFunction {
            fn from(value: super::AbiFunction) -> Self {
                Self {
                    constant: Ok(value.constant),
                    gas: Ok(value.gas),
                    inputs: Ok(value.inputs),
                    name: Ok(value.name),
                    outputs: Ok(value.outputs),
                    payable: Ok(value.payable),
                    state_mutability: Ok(value.state_mutability),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AbiInput {
            additional_properties: ::std::result::Result<
                ::std::option::Option<::serde_json::Value>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<super::AbiInputType, ::std::string::String>,
        }
        impl ::std::default::Default for AbiInput {
            fn default() -> Self {
                Self {
                    additional_properties: Ok(Default::default()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl AbiInput {
            pub fn additional_properties<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::serde_json::Value>>,
                T::Error: ::std::fmt::Display,
            {
                self.additional_properties = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for additional_properties: {}",
                        e
                    )
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AbiInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<AbiInput> for super::AbiInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AbiInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    additional_properties: value.additional_properties?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::AbiInput> for AbiInput {
            fn from(value: super::AbiInput) -> Self {
                Self {
                    additional_properties: Ok(value.additional_properties),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AbiParameter {
            components:
                ::std::result::Result<::std::vec::Vec<super::AbiParameter>, ::std::string::String>,
            internal_type: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for AbiParameter {
            fn default() -> Self {
                Self {
                    components: Ok(Default::default()),
                    internal_type: Ok(Default::default()),
                    name: Ok(Default::default()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl AbiParameter {
            pub fn components<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AbiParameter>>,
                T::Error: ::std::fmt::Display,
            {
                self.components = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for components: {}", e));
                self
            }
            pub fn internal_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.internal_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for internal_type: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<AbiParameter> for super::AbiParameter {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AbiParameter,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    components: value.components?,
                    internal_type: value.internal_type?,
                    name: value.name?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::AbiParameter> for AbiParameter {
            fn from(value: super::AbiParameter) -> Self {
                Self {
                    components: Ok(value.components),
                    internal_type: Ok(value.internal_type),
                    name: Ok(value.name),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountTokenAddressesResponse {
            account_address: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            token_addresses: ::std::result::Result<
                ::std::vec::Vec<super::AccountTokenAddressesResponseTokenAddressesItem>,
                ::std::string::String,
            >,
            total_count: ::std::result::Result<::std::option::Option<u64>, ::std::string::String>,
        }
        impl ::std::default::Default for AccountTokenAddressesResponse {
            fn default() -> Self {
                Self {
                    account_address: Ok(Default::default()),
                    token_addresses: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl AccountTokenAddressesResponse {
            pub fn account_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.account_address = value.try_into().map_err(|e| {
                    format!("error converting supplied value for account_address: {}", e)
                });
                self
            }
            pub fn token_addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::AccountTokenAddressesResponseTokenAddressesItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.token_addresses = value.try_into().map_err(|e| {
                    format!("error converting supplied value for token_addresses: {}", e)
                });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u64>>,
                T::Error: ::std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for total_count: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<AccountTokenAddressesResponse>
            for super::AccountTokenAddressesResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountTokenAddressesResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_address: value.account_address?,
                    token_addresses: value.token_addresses?,
                    total_count: value.total_count?,
                })
            }
        }
        impl ::std::convert::From<super::AccountTokenAddressesResponse> for AccountTokenAddressesResponse {
            fn from(value: super::AccountTokenAddressesResponse) -> Self {
                Self {
                    account_address: Ok(value.account_address),
                    token_addresses: Ok(value.token_addresses),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CommonSwapResponse {
            block_number:
                ::std::result::Result<super::CommonSwapResponseBlockNumber, ::std::string::String>,
            fees: ::std::result::Result<super::CommonSwapResponseFees, ::std::string::String>,
            from_amount:
                ::std::result::Result<super::CommonSwapResponseFromAmount, ::std::string::String>,
            from_token:
                ::std::result::Result<super::CommonSwapResponseFromToken, ::std::string::String>,
            issues: ::std::result::Result<super::CommonSwapResponseIssues, ::std::string::String>,
            liquidity_available: ::std::result::Result<bool, ::std::string::String>,
            min_to_amount:
                ::std::result::Result<super::CommonSwapResponseMinToAmount, ::std::string::String>,
            to_amount:
                ::std::result::Result<super::CommonSwapResponseToAmount, ::std::string::String>,
            to_token:
                ::std::result::Result<super::CommonSwapResponseToToken, ::std::string::String>,
        }
        impl ::std::default::Default for CommonSwapResponse {
            fn default() -> Self {
                Self {
                    block_number: Err("no value supplied for block_number".to_string()),
                    fees: Err("no value supplied for fees".to_string()),
                    from_amount: Err("no value supplied for from_amount".to_string()),
                    from_token: Err("no value supplied for from_token".to_string()),
                    issues: Err("no value supplied for issues".to_string()),
                    liquidity_available: Err(
                        "no value supplied for liquidity_available".to_string()
                    ),
                    min_to_amount: Err("no value supplied for min_to_amount".to_string()),
                    to_amount: Err("no value supplied for to_amount".to_string()),
                    to_token: Err("no value supplied for to_token".to_string()),
                }
            }
        }
        impl CommonSwapResponse {
            pub fn block_number<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CommonSwapResponseBlockNumber>,
                T::Error: ::std::fmt::Display,
            {
                self.block_number = value.try_into().map_err(|e| {
                    format!("error converting supplied value for block_number: {}", e)
                });
                self
            }
            pub fn fees<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CommonSwapResponseFees>,
                T::Error: ::std::fmt::Display,
            {
                self.fees = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for fees: {}", e));
                self
            }
            pub fn from_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CommonSwapResponseFromAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.from_amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for from_amount: {}", e));
                self
            }
            pub fn from_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CommonSwapResponseFromToken>,
                T::Error: ::std::fmt::Display,
            {
                self.from_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for from_token: {}", e));
                self
            }
            pub fn issues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CommonSwapResponseIssues>,
                T::Error: ::std::fmt::Display,
            {
                self.issues = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for issues: {}", e));
                self
            }
            pub fn liquidity_available<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.liquidity_available = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for liquidity_available: {}",
                        e
                    )
                });
                self
            }
            pub fn min_to_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CommonSwapResponseMinToAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.min_to_amount = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_to_amount: {}", e)
                });
                self
            }
            pub fn to_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CommonSwapResponseToAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.to_amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to_amount: {}", e));
                self
            }
            pub fn to_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CommonSwapResponseToToken>,
                T::Error: ::std::fmt::Display,
            {
                self.to_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to_token: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CommonSwapResponse> for super::CommonSwapResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CommonSwapResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_number: value.block_number?,
                    fees: value.fees?,
                    from_amount: value.from_amount?,
                    from_token: value.from_token?,
                    issues: value.issues?,
                    liquidity_available: value.liquidity_available?,
                    min_to_amount: value.min_to_amount?,
                    to_amount: value.to_amount?,
                    to_token: value.to_token?,
                })
            }
        }
        impl ::std::convert::From<super::CommonSwapResponse> for CommonSwapResponse {
            fn from(value: super::CommonSwapResponse) -> Self {
                Self {
                    block_number: Ok(value.block_number),
                    fees: Ok(value.fees),
                    from_amount: Ok(value.from_amount),
                    from_token: Ok(value.from_token),
                    issues: Ok(value.issues),
                    liquidity_available: Ok(value.liquidity_available),
                    min_to_amount: Ok(value.min_to_amount),
                    to_amount: Ok(value.to_amount),
                    to_token: Ok(value.to_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CommonSwapResponseFees {
            gas_fee: ::std::result::Result<
                ::std::option::Option<super::TokenFee>,
                ::std::string::String,
            >,
            protocol_fee: ::std::result::Result<
                ::std::option::Option<super::TokenFee>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CommonSwapResponseFees {
            fn default() -> Self {
                Self {
                    gas_fee: Err("no value supplied for gas_fee".to_string()),
                    protocol_fee: Err("no value supplied for protocol_fee".to_string()),
                }
            }
        }
        impl CommonSwapResponseFees {
            pub fn gas_fee<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::TokenFee>>,
                T::Error: ::std::fmt::Display,
            {
                self.gas_fee = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas_fee: {}", e));
                self
            }
            pub fn protocol_fee<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::TokenFee>>,
                T::Error: ::std::fmt::Display,
            {
                self.protocol_fee = value.try_into().map_err(|e| {
                    format!("error converting supplied value for protocol_fee: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CommonSwapResponseFees> for super::CommonSwapResponseFees {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CommonSwapResponseFees,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    gas_fee: value.gas_fee?,
                    protocol_fee: value.protocol_fee?,
                })
            }
        }
        impl ::std::convert::From<super::CommonSwapResponseFees> for CommonSwapResponseFees {
            fn from(value: super::CommonSwapResponseFees) -> Self {
                Self {
                    gas_fee: Ok(value.gas_fee),
                    protocol_fee: Ok(value.protocol_fee),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CommonSwapResponseIssues {
            allowance: ::std::result::Result<
                ::std::option::Option<super::CommonSwapResponseIssuesAllowance>,
                ::std::string::String,
            >,
            balance: ::std::result::Result<
                ::std::option::Option<super::CommonSwapResponseIssuesBalance>,
                ::std::string::String,
            >,
            simulation_incomplete: ::std::result::Result<bool, ::std::string::String>,
        }
        impl ::std::default::Default for CommonSwapResponseIssues {
            fn default() -> Self {
                Self {
                    allowance: Err("no value supplied for allowance".to_string()),
                    balance: Err("no value supplied for balance".to_string()),
                    simulation_incomplete: Err(
                        "no value supplied for simulation_incomplete".to_string()
                    ),
                }
            }
        }
        impl CommonSwapResponseIssues {
            pub fn allowance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CommonSwapResponseIssuesAllowance>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.allowance = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for allowance: {}", e));
                self
            }
            pub fn balance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CommonSwapResponseIssuesBalance>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.balance = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for balance: {}", e));
                self
            }
            pub fn simulation_incomplete<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.simulation_incomplete = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for simulation_incomplete: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CommonSwapResponseIssues> for super::CommonSwapResponseIssues {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CommonSwapResponseIssues,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allowance: value.allowance?,
                    balance: value.balance?,
                    simulation_incomplete: value.simulation_incomplete?,
                })
            }
        }
        impl ::std::convert::From<super::CommonSwapResponseIssues> for CommonSwapResponseIssues {
            fn from(value: super::CommonSwapResponseIssues) -> Self {
                Self {
                    allowance: Ok(value.allowance),
                    balance: Ok(value.balance),
                    simulation_incomplete: Ok(value.simulation_incomplete),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CommonSwapResponseIssuesAllowance {
            current_allowance: ::std::result::Result<
                super::CommonSwapResponseIssuesAllowanceCurrentAllowance,
                ::std::string::String,
            >,
            spender: ::std::result::Result<
                super::CommonSwapResponseIssuesAllowanceSpender,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CommonSwapResponseIssuesAllowance {
            fn default() -> Self {
                Self {
                    current_allowance: Err("no value supplied for current_allowance".to_string()),
                    spender: Err("no value supplied for spender".to_string()),
                }
            }
        }
        impl CommonSwapResponseIssuesAllowance {
            pub fn current_allowance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::CommonSwapResponseIssuesAllowanceCurrentAllowance,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.current_allowance = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for current_allowance: {}",
                        e
                    )
                });
                self
            }
            pub fn spender<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CommonSwapResponseIssuesAllowanceSpender>,
                T::Error: ::std::fmt::Display,
            {
                self.spender = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for spender: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CommonSwapResponseIssuesAllowance>
            for super::CommonSwapResponseIssuesAllowance
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CommonSwapResponseIssuesAllowance,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    current_allowance: value.current_allowance?,
                    spender: value.spender?,
                })
            }
        }
        impl ::std::convert::From<super::CommonSwapResponseIssuesAllowance>
            for CommonSwapResponseIssuesAllowance
        {
            fn from(value: super::CommonSwapResponseIssuesAllowance) -> Self {
                Self {
                    current_allowance: Ok(value.current_allowance),
                    spender: Ok(value.spender),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CommonSwapResponseIssuesBalance {
            current_balance: ::std::result::Result<
                super::CommonSwapResponseIssuesBalanceCurrentBalance,
                ::std::string::String,
            >,
            required_balance: ::std::result::Result<
                super::CommonSwapResponseIssuesBalanceRequiredBalance,
                ::std::string::String,
            >,
            token: ::std::result::Result<
                super::CommonSwapResponseIssuesBalanceToken,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CommonSwapResponseIssuesBalance {
            fn default() -> Self {
                Self {
                    current_balance: Err("no value supplied for current_balance".to_string()),
                    required_balance: Err("no value supplied for required_balance".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }
        impl CommonSwapResponseIssuesBalance {
            pub fn current_balance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CommonSwapResponseIssuesBalanceCurrentBalance>,
                T::Error: ::std::fmt::Display,
            {
                self.current_balance = value.try_into().map_err(|e| {
                    format!("error converting supplied value for current_balance: {}", e)
                });
                self
            }
            pub fn required_balance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CommonSwapResponseIssuesBalanceRequiredBalance>,
                T::Error: ::std::fmt::Display,
            {
                self.required_balance = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for required_balance: {}",
                        e
                    )
                });
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CommonSwapResponseIssuesBalanceToken>,
                T::Error: ::std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CommonSwapResponseIssuesBalance>
            for super::CommonSwapResponseIssuesBalance
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CommonSwapResponseIssuesBalance,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    current_balance: value.current_balance?,
                    required_balance: value.required_balance?,
                    token: value.token?,
                })
            }
        }
        impl ::std::convert::From<super::CommonSwapResponseIssuesBalance>
            for CommonSwapResponseIssuesBalance
        {
            fn from(value: super::CommonSwapResponseIssuesBalance) -> Self {
                Self {
                    current_balance: Ok(value.current_balance),
                    required_balance: Ok(value.required_balance),
                    token: Ok(value.token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateEndUserBody {
            authentication_methods:
                ::std::result::Result<super::AuthenticationMethods, ::std::string::String>,
            evm_account: ::std::result::Result<
                ::std::option::Option<super::CreateEndUserBodyEvmAccount>,
                ::std::string::String,
            >,
            solana_account: ::std::result::Result<
                ::std::option::Option<super::CreateEndUserBodySolanaAccount>,
                ::std::string::String,
            >,
            user_id: ::std::result::Result<
                ::std::option::Option<super::CreateEndUserBodyUserId>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateEndUserBody {
            fn default() -> Self {
                Self {
                    authentication_methods: Err(
                        "no value supplied for authentication_methods".to_string()
                    ),
                    evm_account: Ok(Default::default()),
                    solana_account: Ok(Default::default()),
                    user_id: Ok(Default::default()),
                }
            }
        }
        impl CreateEndUserBody {
            pub fn authentication_methods<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AuthenticationMethods>,
                T::Error: ::std::fmt::Display,
            {
                self.authentication_methods = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for authentication_methods: {}",
                        e
                    )
                });
                self
            }
            pub fn evm_account<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateEndUserBodyEvmAccount>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.evm_account = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for evm_account: {}", e));
                self
            }
            pub fn solana_account<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateEndUserBodySolanaAccount>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.solana_account = value.try_into().map_err(|e| {
                    format!("error converting supplied value for solana_account: {}", e)
                });
                self
            }
            pub fn user_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::CreateEndUserBodyUserId>>,
                T::Error: ::std::fmt::Display,
            {
                self.user_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_id: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateEndUserBody> for super::CreateEndUserBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateEndUserBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    authentication_methods: value.authentication_methods?,
                    evm_account: value.evm_account?,
                    solana_account: value.solana_account?,
                    user_id: value.user_id?,
                })
            }
        }
        impl ::std::convert::From<super::CreateEndUserBody> for CreateEndUserBody {
            fn from(value: super::CreateEndUserBody) -> Self {
                Self {
                    authentication_methods: Ok(value.authentication_methods),
                    evm_account: Ok(value.evm_account),
                    solana_account: Ok(value.solana_account),
                    user_id: Ok(value.user_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateEndUserBodyEvmAccount {
            create_smart_account: ::std::result::Result<bool, ::std::string::String>,
        }
        impl ::std::default::Default for CreateEndUserBodyEvmAccount {
            fn default() -> Self {
                Self {
                    create_smart_account: Ok(Default::default()),
                }
            }
        }
        impl CreateEndUserBodyEvmAccount {
            pub fn create_smart_account<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.create_smart_account = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for create_smart_account: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CreateEndUserBodyEvmAccount> for super::CreateEndUserBodyEvmAccount {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateEndUserBodyEvmAccount,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    create_smart_account: value.create_smart_account?,
                })
            }
        }
        impl ::std::convert::From<super::CreateEndUserBodyEvmAccount> for CreateEndUserBodyEvmAccount {
            fn from(value: super::CreateEndUserBodyEvmAccount) -> Self {
                Self {
                    create_smart_account: Ok(value.create_smart_account),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateEndUserBodySolanaAccount {
            create_smart_account: ::std::result::Result<bool, ::std::string::String>,
        }
        impl ::std::default::Default for CreateEndUserBodySolanaAccount {
            fn default() -> Self {
                Self {
                    create_smart_account: Ok(Default::default()),
                }
            }
        }
        impl CreateEndUserBodySolanaAccount {
            pub fn create_smart_account<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.create_smart_account = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for create_smart_account: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CreateEndUserBodySolanaAccount>
            for super::CreateEndUserBodySolanaAccount
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateEndUserBodySolanaAccount,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    create_smart_account: value.create_smart_account?,
                })
            }
        }
        impl ::std::convert::From<super::CreateEndUserBodySolanaAccount>
            for CreateEndUserBodySolanaAccount
        {
            fn from(value: super::CreateEndUserBodySolanaAccount) -> Self {
                Self {
                    create_smart_account: Ok(value.create_smart_account),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateEvmAccountBody {
            account_policy: ::std::result::Result<
                ::std::option::Option<super::CreateEvmAccountBodyAccountPolicy>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<super::CreateEvmAccountBodyName>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateEvmAccountBody {
            fn default() -> Self {
                Self {
                    account_policy: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }
        impl CreateEvmAccountBody {
            pub fn account_policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateEvmAccountBodyAccountPolicy>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.account_policy = value.try_into().map_err(|e| {
                    format!("error converting supplied value for account_policy: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::CreateEvmAccountBodyName>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateEvmAccountBody> for super::CreateEvmAccountBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateEvmAccountBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_policy: value.account_policy?,
                    name: value.name?,
                })
            }
        }
        impl ::std::convert::From<super::CreateEvmAccountBody> for CreateEvmAccountBody {
            fn from(value: super::CreateEvmAccountBody) -> Self {
                Self {
                    account_policy: Ok(value.account_policy),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateEvmSmartAccountBody {
            name: ::std::result::Result<
                ::std::option::Option<super::CreateEvmSmartAccountBodyName>,
                ::std::string::String,
            >,
            owners: ::std::result::Result<
                ::std::vec::Vec<super::CreateEvmSmartAccountBodyOwnersItem>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateEvmSmartAccountBody {
            fn default() -> Self {
                Self {
                    name: Ok(Default::default()),
                    owners: Err("no value supplied for owners".to_string()),
                }
            }
        }
        impl CreateEvmSmartAccountBody {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateEvmSmartAccountBodyName>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn owners<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::CreateEvmSmartAccountBodyOwnersItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.owners = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for owners: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateEvmSmartAccountBody> for super::CreateEvmSmartAccountBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateEvmSmartAccountBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    owners: value.owners?,
                })
            }
        }
        impl ::std::convert::From<super::CreateEvmSmartAccountBody> for CreateEvmSmartAccountBody {
            fn from(value: super::CreateEvmSmartAccountBody) -> Self {
                Self {
                    name: Ok(value.name),
                    owners: Ok(value.owners),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateEvmSwapQuoteBody {
            from_amount: ::std::result::Result<
                super::CreateEvmSwapQuoteBodyFromAmount,
                ::std::string::String,
            >,
            from_token: ::std::result::Result<
                super::CreateEvmSwapQuoteBodyFromToken,
                ::std::string::String,
            >,
            gas_price: ::std::result::Result<
                ::std::option::Option<super::CreateEvmSwapQuoteBodyGasPrice>,
                ::std::string::String,
            >,
            network: ::std::result::Result<super::EvmSwapsNetwork, ::std::string::String>,
            signer_address: ::std::result::Result<
                ::std::option::Option<super::CreateEvmSwapQuoteBodySignerAddress>,
                ::std::string::String,
            >,
            slippage_bps: ::std::result::Result<i64, ::std::string::String>,
            taker: ::std::result::Result<super::CreateEvmSwapQuoteBodyTaker, ::std::string::String>,
            to_token:
                ::std::result::Result<super::CreateEvmSwapQuoteBodyToToken, ::std::string::String>,
        }
        impl ::std::default::Default for CreateEvmSwapQuoteBody {
            fn default() -> Self {
                Self {
                    from_amount: Err("no value supplied for from_amount".to_string()),
                    from_token: Err("no value supplied for from_token".to_string()),
                    gas_price: Ok(Default::default()),
                    network: Err("no value supplied for network".to_string()),
                    signer_address: Ok(Default::default()),
                    slippage_bps: Ok(super::defaults::default_u64::<i64, 100>()),
                    taker: Err("no value supplied for taker".to_string()),
                    to_token: Err("no value supplied for to_token".to_string()),
                }
            }
        }
        impl CreateEvmSwapQuoteBody {
            pub fn from_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateEvmSwapQuoteBodyFromAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.from_amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for from_amount: {}", e));
                self
            }
            pub fn from_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateEvmSwapQuoteBodyFromToken>,
                T::Error: ::std::fmt::Display,
            {
                self.from_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for from_token: {}", e));
                self
            }
            pub fn gas_price<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateEvmSwapQuoteBodyGasPrice>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.gas_price = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas_price: {}", e));
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmSwapsNetwork>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn signer_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateEvmSwapQuoteBodySignerAddress>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.signer_address = value.try_into().map_err(|e| {
                    format!("error converting supplied value for signer_address: {}", e)
                });
                self
            }
            pub fn slippage_bps<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.slippage_bps = value.try_into().map_err(|e| {
                    format!("error converting supplied value for slippage_bps: {}", e)
                });
                self
            }
            pub fn taker<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateEvmSwapQuoteBodyTaker>,
                T::Error: ::std::fmt::Display,
            {
                self.taker = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for taker: {}", e));
                self
            }
            pub fn to_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateEvmSwapQuoteBodyToToken>,
                T::Error: ::std::fmt::Display,
            {
                self.to_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to_token: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateEvmSwapQuoteBody> for super::CreateEvmSwapQuoteBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateEvmSwapQuoteBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    from_amount: value.from_amount?,
                    from_token: value.from_token?,
                    gas_price: value.gas_price?,
                    network: value.network?,
                    signer_address: value.signer_address?,
                    slippage_bps: value.slippage_bps?,
                    taker: value.taker?,
                    to_token: value.to_token?,
                })
            }
        }
        impl ::std::convert::From<super::CreateEvmSwapQuoteBody> for CreateEvmSwapQuoteBody {
            fn from(value: super::CreateEvmSwapQuoteBody) -> Self {
                Self {
                    from_amount: Ok(value.from_amount),
                    from_token: Ok(value.from_token),
                    gas_price: Ok(value.gas_price),
                    network: Ok(value.network),
                    signer_address: Ok(value.signer_address),
                    slippage_bps: Ok(value.slippage_bps),
                    taker: Ok(value.taker),
                    to_token: Ok(value.to_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateOnrampOrderBody {
            agreement_accepted_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            client_ip: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            destination_address:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            destination_network:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            domain: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            email: ::std::result::Result<::std::string::String, ::std::string::String>,
            is_quote: ::std::result::Result<bool, ::std::string::String>,
            partner_order_ref: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            partner_user_ref: ::std::result::Result<::std::string::String, ::std::string::String>,
            payment_amount: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            payment_currency: ::std::result::Result<::std::string::String, ::std::string::String>,
            payment_method:
                ::std::result::Result<super::OnrampOrderPaymentMethodTypeId, ::std::string::String>,
            phone_number: ::std::result::Result<::std::string::String, ::std::string::String>,
            phone_number_verified_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            purchase_amount: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            purchase_currency: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CreateOnrampOrderBody {
            fn default() -> Self {
                Self {
                    agreement_accepted_at: Err(
                        "no value supplied for agreement_accepted_at".to_string()
                    ),
                    client_ip: Ok(Default::default()),
                    destination_address: Err(
                        "no value supplied for destination_address".to_string()
                    ),
                    destination_network: Err(
                        "no value supplied for destination_network".to_string()
                    ),
                    domain: Ok(Default::default()),
                    email: Err("no value supplied for email".to_string()),
                    is_quote: Ok(Default::default()),
                    partner_order_ref: Ok(Default::default()),
                    partner_user_ref: Err("no value supplied for partner_user_ref".to_string()),
                    payment_amount: Ok(Default::default()),
                    payment_currency: Err("no value supplied for payment_currency".to_string()),
                    payment_method: Err("no value supplied for payment_method".to_string()),
                    phone_number: Err("no value supplied for phone_number".to_string()),
                    phone_number_verified_at: Err(
                        "no value supplied for phone_number_verified_at".to_string()
                    ),
                    purchase_amount: Ok(Default::default()),
                    purchase_currency: Err("no value supplied for purchase_currency".to_string()),
                }
            }
        }
        impl CreateOnrampOrderBody {
            pub fn agreement_accepted_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.agreement_accepted_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for agreement_accepted_at: {}",
                        e
                    )
                });
                self
            }
            pub fn client_ip<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.client_ip = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for client_ip: {}", e));
                self
            }
            pub fn destination_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.destination_address = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for destination_address: {}",
                        e
                    )
                });
                self
            }
            pub fn destination_network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.destination_network = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for destination_network: {}",
                        e
                    )
                });
                self
            }
            pub fn domain<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.domain = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for domain: {}", e));
                self
            }
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn is_quote<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_quote = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_quote: {}", e));
                self
            }
            pub fn partner_order_ref<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.partner_order_ref = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for partner_order_ref: {}",
                        e
                    )
                });
                self
            }
            pub fn partner_user_ref<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.partner_user_ref = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for partner_user_ref: {}",
                        e
                    )
                });
                self
            }
            pub fn payment_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_amount = value.try_into().map_err(|e| {
                    format!("error converting supplied value for payment_amount: {}", e)
                });
                self
            }
            pub fn payment_currency<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_currency = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for payment_currency: {}",
                        e
                    )
                });
                self
            }
            pub fn payment_method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OnrampOrderPaymentMethodTypeId>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_method = value.try_into().map_err(|e| {
                    format!("error converting supplied value for payment_method: {}", e)
                });
                self
            }
            pub fn phone_number<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.phone_number = value.try_into().map_err(|e| {
                    format!("error converting supplied value for phone_number: {}", e)
                });
                self
            }
            pub fn phone_number_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.phone_number_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for phone_number_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn purchase_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.purchase_amount = value.try_into().map_err(|e| {
                    format!("error converting supplied value for purchase_amount: {}", e)
                });
                self
            }
            pub fn purchase_currency<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.purchase_currency = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for purchase_currency: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CreateOnrampOrderBody> for super::CreateOnrampOrderBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateOnrampOrderBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    agreement_accepted_at: value.agreement_accepted_at?,
                    client_ip: value.client_ip?,
                    destination_address: value.destination_address?,
                    destination_network: value.destination_network?,
                    domain: value.domain?,
                    email: value.email?,
                    is_quote: value.is_quote?,
                    partner_order_ref: value.partner_order_ref?,
                    partner_user_ref: value.partner_user_ref?,
                    payment_amount: value.payment_amount?,
                    payment_currency: value.payment_currency?,
                    payment_method: value.payment_method?,
                    phone_number: value.phone_number?,
                    phone_number_verified_at: value.phone_number_verified_at?,
                    purchase_amount: value.purchase_amount?,
                    purchase_currency: value.purchase_currency?,
                })
            }
        }
        impl ::std::convert::From<super::CreateOnrampOrderBody> for CreateOnrampOrderBody {
            fn from(value: super::CreateOnrampOrderBody) -> Self {
                Self {
                    agreement_accepted_at: Ok(value.agreement_accepted_at),
                    client_ip: Ok(value.client_ip),
                    destination_address: Ok(value.destination_address),
                    destination_network: Ok(value.destination_network),
                    domain: Ok(value.domain),
                    email: Ok(value.email),
                    is_quote: Ok(value.is_quote),
                    partner_order_ref: Ok(value.partner_order_ref),
                    partner_user_ref: Ok(value.partner_user_ref),
                    payment_amount: Ok(value.payment_amount),
                    payment_currency: Ok(value.payment_currency),
                    payment_method: Ok(value.payment_method),
                    phone_number: Ok(value.phone_number),
                    phone_number_verified_at: Ok(value.phone_number_verified_at),
                    purchase_amount: Ok(value.purchase_amount),
                    purchase_currency: Ok(value.purchase_currency),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateOnrampOrderResponse {
            order: ::std::result::Result<super::OnrampOrder, ::std::string::String>,
            payment_link: ::std::result::Result<
                ::std::option::Option<super::OnrampPaymentLink>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateOnrampOrderResponse {
            fn default() -> Self {
                Self {
                    order: Err("no value supplied for order".to_string()),
                    payment_link: Ok(Default::default()),
                }
            }
        }
        impl CreateOnrampOrderResponse {
            pub fn order<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OnrampOrder>,
                T::Error: ::std::fmt::Display,
            {
                self.order = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for order: {}", e));
                self
            }
            pub fn payment_link<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::OnrampPaymentLink>>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_link = value.try_into().map_err(|e| {
                    format!("error converting supplied value for payment_link: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CreateOnrampOrderResponse> for super::CreateOnrampOrderResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateOnrampOrderResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    order: value.order?,
                    payment_link: value.payment_link?,
                })
            }
        }
        impl ::std::convert::From<super::CreateOnrampOrderResponse> for CreateOnrampOrderResponse {
            fn from(value: super::CreateOnrampOrderResponse) -> Self {
                Self {
                    order: Ok(value.order),
                    payment_link: Ok(value.payment_link),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateOnrampSessionBody {
            client_ip: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            country: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            destination_address:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            destination_network:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            partner_user_ref: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            payment_amount: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            payment_currency: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            payment_method: ::std::result::Result<
                ::std::option::Option<super::OnrampQuotePaymentMethodTypeId>,
                ::std::string::String,
            >,
            purchase_currency: ::std::result::Result<::std::string::String, ::std::string::String>,
            redirect_url:
                ::std::result::Result<::std::option::Option<super::Uri>, ::std::string::String>,
            subdivision: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateOnrampSessionBody {
            fn default() -> Self {
                Self {
                    client_ip: Ok(Default::default()),
                    country: Ok(Default::default()),
                    destination_address: Err(
                        "no value supplied for destination_address".to_string()
                    ),
                    destination_network: Err(
                        "no value supplied for destination_network".to_string()
                    ),
                    partner_user_ref: Ok(Default::default()),
                    payment_amount: Ok(Default::default()),
                    payment_currency: Ok(Default::default()),
                    payment_method: Ok(Default::default()),
                    purchase_currency: Err("no value supplied for purchase_currency".to_string()),
                    redirect_url: Ok(Default::default()),
                    subdivision: Ok(Default::default()),
                }
            }
        }
        impl CreateOnrampSessionBody {
            pub fn client_ip<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.client_ip = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for client_ip: {}", e));
                self
            }
            pub fn country<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.country = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for country: {}", e));
                self
            }
            pub fn destination_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.destination_address = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for destination_address: {}",
                        e
                    )
                });
                self
            }
            pub fn destination_network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.destination_network = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for destination_network: {}",
                        e
                    )
                });
                self
            }
            pub fn partner_user_ref<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.partner_user_ref = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for partner_user_ref: {}",
                        e
                    )
                });
                self
            }
            pub fn payment_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_amount = value.try_into().map_err(|e| {
                    format!("error converting supplied value for payment_amount: {}", e)
                });
                self
            }
            pub fn payment_currency<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_currency = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for payment_currency: {}",
                        e
                    )
                });
                self
            }
            pub fn payment_method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::OnrampQuotePaymentMethodTypeId>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.payment_method = value.try_into().map_err(|e| {
                    format!("error converting supplied value for payment_method: {}", e)
                });
                self
            }
            pub fn purchase_currency<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.purchase_currency = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for purchase_currency: {}",
                        e
                    )
                });
                self
            }
            pub fn redirect_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Uri>>,
                T::Error: ::std::fmt::Display,
            {
                self.redirect_url = value.try_into().map_err(|e| {
                    format!("error converting supplied value for redirect_url: {}", e)
                });
                self
            }
            pub fn subdivision<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.subdivision = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subdivision: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateOnrampSessionBody> for super::CreateOnrampSessionBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateOnrampSessionBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    client_ip: value.client_ip?,
                    country: value.country?,
                    destination_address: value.destination_address?,
                    destination_network: value.destination_network?,
                    partner_user_ref: value.partner_user_ref?,
                    payment_amount: value.payment_amount?,
                    payment_currency: value.payment_currency?,
                    payment_method: value.payment_method?,
                    purchase_currency: value.purchase_currency?,
                    redirect_url: value.redirect_url?,
                    subdivision: value.subdivision?,
                })
            }
        }
        impl ::std::convert::From<super::CreateOnrampSessionBody> for CreateOnrampSessionBody {
            fn from(value: super::CreateOnrampSessionBody) -> Self {
                Self {
                    client_ip: Ok(value.client_ip),
                    country: Ok(value.country),
                    destination_address: Ok(value.destination_address),
                    destination_network: Ok(value.destination_network),
                    partner_user_ref: Ok(value.partner_user_ref),
                    payment_amount: Ok(value.payment_amount),
                    payment_currency: Ok(value.payment_currency),
                    payment_method: Ok(value.payment_method),
                    purchase_currency: Ok(value.purchase_currency),
                    redirect_url: Ok(value.redirect_url),
                    subdivision: Ok(value.subdivision),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateOnrampSessionResponse {
            quote: ::std::result::Result<
                ::std::option::Option<super::OnrampQuote>,
                ::std::string::String,
            >,
            session: ::std::result::Result<super::OnrampSession, ::std::string::String>,
        }
        impl ::std::default::Default for CreateOnrampSessionResponse {
            fn default() -> Self {
                Self {
                    quote: Ok(Default::default()),
                    session: Err("no value supplied for session".to_string()),
                }
            }
        }
        impl CreateOnrampSessionResponse {
            pub fn quote<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::OnrampQuote>>,
                T::Error: ::std::fmt::Display,
            {
                self.quote = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for quote: {}", e));
                self
            }
            pub fn session<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OnrampSession>,
                T::Error: ::std::fmt::Display,
            {
                self.session = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for session: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateOnrampSessionResponse> for super::CreateOnrampSessionResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateOnrampSessionResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    quote: value.quote?,
                    session: value.session?,
                })
            }
        }
        impl ::std::convert::From<super::CreateOnrampSessionResponse> for CreateOnrampSessionResponse {
            fn from(value: super::CreateOnrampSessionResponse) -> Self {
                Self {
                    quote: Ok(value.quote),
                    session: Ok(value.session),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreatePolicyBody {
            description: ::std::result::Result<
                ::std::option::Option<super::CreatePolicyBodyDescription>,
                ::std::string::String,
            >,
            rules: ::std::result::Result<::std::vec::Vec<super::Rule>, ::std::string::String>,
            scope: ::std::result::Result<super::CreatePolicyBodyScope, ::std::string::String>,
        }
        impl ::std::default::Default for CreatePolicyBody {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    rules: Err("no value supplied for rules".to_string()),
                    scope: Err("no value supplied for scope".to_string()),
                }
            }
        }
        impl CreatePolicyBody {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreatePolicyBodyDescription>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn rules<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Rule>>,
                T::Error: ::std::fmt::Display,
            {
                self.rules = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rules: {}", e));
                self
            }
            pub fn scope<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreatePolicyBodyScope>,
                T::Error: ::std::fmt::Display,
            {
                self.scope = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scope: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreatePolicyBody> for super::CreatePolicyBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreatePolicyBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    rules: value.rules?,
                    scope: value.scope?,
                })
            }
        }
        impl ::std::convert::From<super::CreatePolicyBody> for CreatePolicyBody {
            fn from(value: super::CreatePolicyBody) -> Self {
                Self {
                    description: Ok(value.description),
                    rules: Ok(value.rules),
                    scope: Ok(value.scope),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateSolanaAccountBody {
            account_policy: ::std::result::Result<
                ::std::option::Option<super::CreateSolanaAccountBodyAccountPolicy>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<super::CreateSolanaAccountBodyName>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateSolanaAccountBody {
            fn default() -> Self {
                Self {
                    account_policy: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }
        impl CreateSolanaAccountBody {
            pub fn account_policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateSolanaAccountBodyAccountPolicy>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.account_policy = value.try_into().map_err(|e| {
                    format!("error converting supplied value for account_policy: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateSolanaAccountBodyName>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateSolanaAccountBody> for super::CreateSolanaAccountBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateSolanaAccountBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_policy: value.account_policy?,
                    name: value.name?,
                })
            }
        }
        impl ::std::convert::From<super::CreateSolanaAccountBody> for CreateSolanaAccountBody {
            fn from(value: super::CreateSolanaAccountBody) -> Self {
                Self {
                    account_policy: Ok(value.account_policy),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateSpendPermissionRequest {
            allowance: ::std::result::Result<::std::string::String, ::std::string::String>,
            end: ::std::result::Result<::std::string::String, ::std::string::String>,
            extra_data: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            network: ::std::result::Result<super::SpendPermissionNetwork, ::std::string::String>,
            paymaster_url:
                ::std::result::Result<::std::option::Option<super::Url>, ::std::string::String>,
            period: ::std::result::Result<::std::string::String, ::std::string::String>,
            salt: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            spender: ::std::result::Result<
                super::CreateSpendPermissionRequestSpender,
                ::std::string::String,
            >,
            start: ::std::result::Result<::std::string::String, ::std::string::String>,
            token: ::std::result::Result<
                super::CreateSpendPermissionRequestToken,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateSpendPermissionRequest {
            fn default() -> Self {
                Self {
                    allowance: Err("no value supplied for allowance".to_string()),
                    end: Err("no value supplied for end".to_string()),
                    extra_data: Ok(Default::default()),
                    network: Err("no value supplied for network".to_string()),
                    paymaster_url: Ok(Default::default()),
                    period: Err("no value supplied for period".to_string()),
                    salt: Ok(Default::default()),
                    spender: Err("no value supplied for spender".to_string()),
                    start: Err("no value supplied for start".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }
        impl CreateSpendPermissionRequest {
            pub fn allowance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.allowance = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for allowance: {}", e));
                self
            }
            pub fn end<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.end = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for end: {}", e));
                self
            }
            pub fn extra_data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.extra_data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for extra_data: {}", e));
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SpendPermissionNetwork>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn paymaster_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Url>>,
                T::Error: ::std::fmt::Display,
            {
                self.paymaster_url = value.try_into().map_err(|e| {
                    format!("error converting supplied value for paymaster_url: {}", e)
                });
                self
            }
            pub fn period<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.period = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for period: {}", e));
                self
            }
            pub fn salt<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.salt = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for salt: {}", e));
                self
            }
            pub fn spender<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSpendPermissionRequestSpender>,
                T::Error: ::std::fmt::Display,
            {
                self.spender = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for spender: {}", e));
                self
            }
            pub fn start<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.start = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start: {}", e));
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSpendPermissionRequestToken>,
                T::Error: ::std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateSpendPermissionRequest> for super::CreateSpendPermissionRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateSpendPermissionRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allowance: value.allowance?,
                    end: value.end?,
                    extra_data: value.extra_data?,
                    network: value.network?,
                    paymaster_url: value.paymaster_url?,
                    period: value.period?,
                    salt: value.salt?,
                    spender: value.spender?,
                    start: value.start?,
                    token: value.token?,
                })
            }
        }
        impl ::std::convert::From<super::CreateSpendPermissionRequest> for CreateSpendPermissionRequest {
            fn from(value: super::CreateSpendPermissionRequest) -> Self {
                Self {
                    allowance: Ok(value.allowance),
                    end: Ok(value.end),
                    extra_data: Ok(value.extra_data),
                    network: Ok(value.network),
                    paymaster_url: Ok(value.paymaster_url),
                    period: Ok(value.period),
                    salt: Ok(value.salt),
                    spender: Ok(value.spender),
                    start: Ok(value.start),
                    token: Ok(value.token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateSwapQuoteResponse {
            block_number: ::std::result::Result<
                super::CreateSwapQuoteResponseBlockNumber,
                ::std::string::String,
            >,
            fees: ::std::result::Result<super::CreateSwapQuoteResponseFees, ::std::string::String>,
            from_amount: ::std::result::Result<
                super::CreateSwapQuoteResponseFromAmount,
                ::std::string::String,
            >,
            from_token: ::std::result::Result<
                super::CreateSwapQuoteResponseFromToken,
                ::std::string::String,
            >,
            issues:
                ::std::result::Result<super::CreateSwapQuoteResponseIssues, ::std::string::String>,
            liquidity_available: ::std::result::Result<bool, ::std::string::String>,
            min_to_amount: ::std::result::Result<
                super::CreateSwapQuoteResponseMinToAmount,
                ::std::string::String,
            >,
            permit2: ::std::result::Result<
                ::std::option::Option<super::CreateSwapQuoteResponsePermit2>,
                ::std::string::String,
            >,
            to_amount: ::std::result::Result<
                super::CreateSwapQuoteResponseToAmount,
                ::std::string::String,
            >,
            to_token:
                ::std::result::Result<super::CreateSwapQuoteResponseToToken, ::std::string::String>,
            transaction: ::std::result::Result<
                super::CreateSwapQuoteResponseTransaction,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateSwapQuoteResponse {
            fn default() -> Self {
                Self {
                    block_number: Err("no value supplied for block_number".to_string()),
                    fees: Err("no value supplied for fees".to_string()),
                    from_amount: Err("no value supplied for from_amount".to_string()),
                    from_token: Err("no value supplied for from_token".to_string()),
                    issues: Err("no value supplied for issues".to_string()),
                    liquidity_available: Err(
                        "no value supplied for liquidity_available".to_string()
                    ),
                    min_to_amount: Err("no value supplied for min_to_amount".to_string()),
                    permit2: Err("no value supplied for permit2".to_string()),
                    to_amount: Err("no value supplied for to_amount".to_string()),
                    to_token: Err("no value supplied for to_token".to_string()),
                    transaction: Err("no value supplied for transaction".to_string()),
                }
            }
        }
        impl CreateSwapQuoteResponse {
            pub fn block_number<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseBlockNumber>,
                T::Error: ::std::fmt::Display,
            {
                self.block_number = value.try_into().map_err(|e| {
                    format!("error converting supplied value for block_number: {}", e)
                });
                self
            }
            pub fn fees<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseFees>,
                T::Error: ::std::fmt::Display,
            {
                self.fees = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for fees: {}", e));
                self
            }
            pub fn from_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseFromAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.from_amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for from_amount: {}", e));
                self
            }
            pub fn from_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseFromToken>,
                T::Error: ::std::fmt::Display,
            {
                self.from_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for from_token: {}", e));
                self
            }
            pub fn issues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseIssues>,
                T::Error: ::std::fmt::Display,
            {
                self.issues = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for issues: {}", e));
                self
            }
            pub fn liquidity_available<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.liquidity_available = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for liquidity_available: {}",
                        e
                    )
                });
                self
            }
            pub fn min_to_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseMinToAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.min_to_amount = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_to_amount: {}", e)
                });
                self
            }
            pub fn permit2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateSwapQuoteResponsePermit2>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.permit2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for permit2: {}", e));
                self
            }
            pub fn to_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseToAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.to_amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to_amount: {}", e));
                self
            }
            pub fn to_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseToToken>,
                T::Error: ::std::fmt::Display,
            {
                self.to_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to_token: {}", e));
                self
            }
            pub fn transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseTransaction>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for transaction: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateSwapQuoteResponse> for super::CreateSwapQuoteResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateSwapQuoteResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_number: value.block_number?,
                    fees: value.fees?,
                    from_amount: value.from_amount?,
                    from_token: value.from_token?,
                    issues: value.issues?,
                    liquidity_available: value.liquidity_available?,
                    min_to_amount: value.min_to_amount?,
                    permit2: value.permit2?,
                    to_amount: value.to_amount?,
                    to_token: value.to_token?,
                    transaction: value.transaction?,
                })
            }
        }
        impl ::std::convert::From<super::CreateSwapQuoteResponse> for CreateSwapQuoteResponse {
            fn from(value: super::CreateSwapQuoteResponse) -> Self {
                Self {
                    block_number: Ok(value.block_number),
                    fees: Ok(value.fees),
                    from_amount: Ok(value.from_amount),
                    from_token: Ok(value.from_token),
                    issues: Ok(value.issues),
                    liquidity_available: Ok(value.liquidity_available),
                    min_to_amount: Ok(value.min_to_amount),
                    permit2: Ok(value.permit2),
                    to_amount: Ok(value.to_amount),
                    to_token: Ok(value.to_token),
                    transaction: Ok(value.transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateSwapQuoteResponseFees {
            gas_fee: ::std::result::Result<
                ::std::option::Option<super::TokenFee>,
                ::std::string::String,
            >,
            protocol_fee: ::std::result::Result<
                ::std::option::Option<super::TokenFee>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateSwapQuoteResponseFees {
            fn default() -> Self {
                Self {
                    gas_fee: Err("no value supplied for gas_fee".to_string()),
                    protocol_fee: Err("no value supplied for protocol_fee".to_string()),
                }
            }
        }
        impl CreateSwapQuoteResponseFees {
            pub fn gas_fee<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::TokenFee>>,
                T::Error: ::std::fmt::Display,
            {
                self.gas_fee = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas_fee: {}", e));
                self
            }
            pub fn protocol_fee<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::TokenFee>>,
                T::Error: ::std::fmt::Display,
            {
                self.protocol_fee = value.try_into().map_err(|e| {
                    format!("error converting supplied value for protocol_fee: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CreateSwapQuoteResponseFees> for super::CreateSwapQuoteResponseFees {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateSwapQuoteResponseFees,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    gas_fee: value.gas_fee?,
                    protocol_fee: value.protocol_fee?,
                })
            }
        }
        impl ::std::convert::From<super::CreateSwapQuoteResponseFees> for CreateSwapQuoteResponseFees {
            fn from(value: super::CreateSwapQuoteResponseFees) -> Self {
                Self {
                    gas_fee: Ok(value.gas_fee),
                    protocol_fee: Ok(value.protocol_fee),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateSwapQuoteResponseIssues {
            allowance: ::std::result::Result<
                ::std::option::Option<super::CreateSwapQuoteResponseIssuesAllowance>,
                ::std::string::String,
            >,
            balance: ::std::result::Result<
                ::std::option::Option<super::CreateSwapQuoteResponseIssuesBalance>,
                ::std::string::String,
            >,
            simulation_incomplete: ::std::result::Result<bool, ::std::string::String>,
        }
        impl ::std::default::Default for CreateSwapQuoteResponseIssues {
            fn default() -> Self {
                Self {
                    allowance: Err("no value supplied for allowance".to_string()),
                    balance: Err("no value supplied for balance".to_string()),
                    simulation_incomplete: Err(
                        "no value supplied for simulation_incomplete".to_string()
                    ),
                }
            }
        }
        impl CreateSwapQuoteResponseIssues {
            pub fn allowance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateSwapQuoteResponseIssuesAllowance>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.allowance = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for allowance: {}", e));
                self
            }
            pub fn balance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateSwapQuoteResponseIssuesBalance>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.balance = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for balance: {}", e));
                self
            }
            pub fn simulation_incomplete<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.simulation_incomplete = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for simulation_incomplete: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<CreateSwapQuoteResponseIssues>
            for super::CreateSwapQuoteResponseIssues
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateSwapQuoteResponseIssues,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allowance: value.allowance?,
                    balance: value.balance?,
                    simulation_incomplete: value.simulation_incomplete?,
                })
            }
        }
        impl ::std::convert::From<super::CreateSwapQuoteResponseIssues> for CreateSwapQuoteResponseIssues {
            fn from(value: super::CreateSwapQuoteResponseIssues) -> Self {
                Self {
                    allowance: Ok(value.allowance),
                    balance: Ok(value.balance),
                    simulation_incomplete: Ok(value.simulation_incomplete),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateSwapQuoteResponseIssuesAllowance {
            current_allowance: ::std::result::Result<
                super::CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance,
                ::std::string::String,
            >,
            spender: ::std::result::Result<
                super::CreateSwapQuoteResponseIssuesAllowanceSpender,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateSwapQuoteResponseIssuesAllowance {
            fn default() -> Self {
                Self {
                    current_allowance: Err("no value supplied for current_allowance".to_string()),
                    spender: Err("no value supplied for spender".to_string()),
                }
            }
        }
        impl CreateSwapQuoteResponseIssuesAllowance {
            pub fn current_allowance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::CreateSwapQuoteResponseIssuesAllowanceCurrentAllowance,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.current_allowance = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for current_allowance: {}",
                        e
                    )
                });
                self
            }
            pub fn spender<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseIssuesAllowanceSpender>,
                T::Error: ::std::fmt::Display,
            {
                self.spender = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for spender: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateSwapQuoteResponseIssuesAllowance>
            for super::CreateSwapQuoteResponseIssuesAllowance
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateSwapQuoteResponseIssuesAllowance,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    current_allowance: value.current_allowance?,
                    spender: value.spender?,
                })
            }
        }
        impl ::std::convert::From<super::CreateSwapQuoteResponseIssuesAllowance>
            for CreateSwapQuoteResponseIssuesAllowance
        {
            fn from(value: super::CreateSwapQuoteResponseIssuesAllowance) -> Self {
                Self {
                    current_allowance: Ok(value.current_allowance),
                    spender: Ok(value.spender),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateSwapQuoteResponseIssuesBalance {
            current_balance: ::std::result::Result<
                super::CreateSwapQuoteResponseIssuesBalanceCurrentBalance,
                ::std::string::String,
            >,
            required_balance: ::std::result::Result<
                super::CreateSwapQuoteResponseIssuesBalanceRequiredBalance,
                ::std::string::String,
            >,
            token: ::std::result::Result<
                super::CreateSwapQuoteResponseIssuesBalanceToken,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateSwapQuoteResponseIssuesBalance {
            fn default() -> Self {
                Self {
                    current_balance: Err("no value supplied for current_balance".to_string()),
                    required_balance: Err("no value supplied for required_balance".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }
        impl CreateSwapQuoteResponseIssuesBalance {
            pub fn current_balance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::CreateSwapQuoteResponseIssuesBalanceCurrentBalance,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.current_balance = value.try_into().map_err(|e| {
                    format!("error converting supplied value for current_balance: {}", e)
                });
                self
            }
            pub fn required_balance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::CreateSwapQuoteResponseIssuesBalanceRequiredBalance,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.required_balance = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for required_balance: {}",
                        e
                    )
                });
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseIssuesBalanceToken>,
                T::Error: ::std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateSwapQuoteResponseIssuesBalance>
            for super::CreateSwapQuoteResponseIssuesBalance
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateSwapQuoteResponseIssuesBalance,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    current_balance: value.current_balance?,
                    required_balance: value.required_balance?,
                    token: value.token?,
                })
            }
        }
        impl ::std::convert::From<super::CreateSwapQuoteResponseIssuesBalance>
            for CreateSwapQuoteResponseIssuesBalance
        {
            fn from(value: super::CreateSwapQuoteResponseIssuesBalance) -> Self {
                Self {
                    current_balance: Ok(value.current_balance),
                    required_balance: Ok(value.required_balance),
                    token: Ok(value.token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateSwapQuoteResponsePermit2 {
            eip712: ::std::result::Result<super::Eip712Message, ::std::string::String>,
            hash: ::std::result::Result<
                super::CreateSwapQuoteResponsePermit2Hash,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateSwapQuoteResponsePermit2 {
            fn default() -> Self {
                Self {
                    eip712: Err("no value supplied for eip712".to_string()),
                    hash: Err("no value supplied for hash".to_string()),
                }
            }
        }
        impl CreateSwapQuoteResponsePermit2 {
            pub fn eip712<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Eip712Message>,
                T::Error: ::std::fmt::Display,
            {
                self.eip712 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for eip712: {}", e));
                self
            }
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponsePermit2Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hash: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateSwapQuoteResponsePermit2>
            for super::CreateSwapQuoteResponsePermit2
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateSwapQuoteResponsePermit2,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    eip712: value.eip712?,
                    hash: value.hash?,
                })
            }
        }
        impl ::std::convert::From<super::CreateSwapQuoteResponsePermit2>
            for CreateSwapQuoteResponsePermit2
        {
            fn from(value: super::CreateSwapQuoteResponsePermit2) -> Self {
                Self {
                    eip712: Ok(value.eip712),
                    hash: Ok(value.hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateSwapQuoteResponseTransaction {
            data: ::std::result::Result<::std::string::String, ::std::string::String>,
            gas: ::std::result::Result<
                super::CreateSwapQuoteResponseTransactionGas,
                ::std::string::String,
            >,
            gas_price: ::std::result::Result<
                super::CreateSwapQuoteResponseTransactionGasPrice,
                ::std::string::String,
            >,
            to: ::std::result::Result<
                super::CreateSwapQuoteResponseTransactionTo,
                ::std::string::String,
            >,
            value: ::std::result::Result<
                super::CreateSwapQuoteResponseTransactionValue,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateSwapQuoteResponseTransaction {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    gas: Err("no value supplied for gas".to_string()),
                    gas_price: Err("no value supplied for gas_price".to_string()),
                    to: Err("no value supplied for to".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl CreateSwapQuoteResponseTransaction {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn gas<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseTransactionGas>,
                T::Error: ::std::fmt::Display,
            {
                self.gas = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas: {}", e));
                self
            }
            pub fn gas_price<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseTransactionGasPrice>,
                T::Error: ::std::fmt::Display,
            {
                self.gas_price = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas_price: {}", e));
                self
            }
            pub fn to<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseTransactionTo>,
                T::Error: ::std::fmt::Display,
            {
                self.to = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateSwapQuoteResponseTransactionValue>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateSwapQuoteResponseTransaction>
            for super::CreateSwapQuoteResponseTransaction
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateSwapQuoteResponseTransaction,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    gas: value.gas?,
                    gas_price: value.gas_price?,
                    to: value.to?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::CreateSwapQuoteResponseTransaction>
            for CreateSwapQuoteResponseTransaction
        {
            fn from(value: super::CreateSwapQuoteResponseTransaction) -> Self {
                Self {
                    data: Ok(value.data),
                    gas: Ok(value.gas),
                    gas_price: Ok(value.gas_price),
                    to: Ok(value.to),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DeveloperJwtAuthentication {
            kid: ::std::result::Result<::std::string::String, ::std::string::String>,
            sub: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_:
                ::std::result::Result<super::DeveloperJwtAuthenticationType, ::std::string::String>,
        }
        impl ::std::default::Default for DeveloperJwtAuthentication {
            fn default() -> Self {
                Self {
                    kid: Err("no value supplied for kid".to_string()),
                    sub: Err("no value supplied for sub".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl DeveloperJwtAuthentication {
            pub fn kid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.kid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kid: {}", e));
                self
            }
            pub fn sub<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.sub = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sub: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::DeveloperJwtAuthenticationType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<DeveloperJwtAuthentication> for super::DeveloperJwtAuthentication {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DeveloperJwtAuthentication,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    kid: value.kid?,
                    sub: value.sub?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::DeveloperJwtAuthentication> for DeveloperJwtAuthentication {
            fn from(value: super::DeveloperJwtAuthentication) -> Self {
                Self {
                    kid: Ok(value.kid),
                    sub: Ok(value.sub),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Eip712Domain {
            chain_id: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            salt: ::std::result::Result<
                ::std::option::Option<super::Eip712DomainSalt>,
                ::std::string::String,
            >,
            verifying_contract: ::std::result::Result<
                ::std::option::Option<super::Eip712DomainVerifyingContract>,
                ::std::string::String,
            >,
            version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for Eip712Domain {
            fn default() -> Self {
                Self {
                    chain_id: Ok(Default::default()),
                    name: Ok(Default::default()),
                    salt: Ok(Default::default()),
                    verifying_contract: Ok(Default::default()),
                    version: Ok(Default::default()),
                }
            }
        }
        impl Eip712Domain {
            pub fn chain_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn salt<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Eip712DomainSalt>>,
                T::Error: ::std::fmt::Display,
            {
                self.salt = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for salt: {}", e));
                self
            }
            pub fn verifying_contract<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::Eip712DomainVerifyingContract>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.verifying_contract = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for verifying_contract: {}",
                        e
                    )
                });
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<Eip712Domain> for super::Eip712Domain {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Eip712Domain,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    chain_id: value.chain_id?,
                    name: value.name?,
                    salt: value.salt?,
                    verifying_contract: value.verifying_contract?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::Eip712Domain> for Eip712Domain {
            fn from(value: super::Eip712Domain) -> Self {
                Self {
                    chain_id: Ok(value.chain_id),
                    name: Ok(value.name),
                    salt: Ok(value.salt),
                    verifying_contract: Ok(value.verifying_contract),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Eip712Message {
            domain: ::std::result::Result<super::Eip712Domain, ::std::string::String>,
            message: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            primary_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            types: ::std::result::Result<super::Eip712Types, ::std::string::String>,
        }
        impl ::std::default::Default for Eip712Message {
            fn default() -> Self {
                Self {
                    domain: Err("no value supplied for domain".to_string()),
                    message: Err("no value supplied for message".to_string()),
                    primary_type: Err("no value supplied for primary_type".to_string()),
                    types: Err("no value supplied for types".to_string()),
                }
            }
        }
        impl Eip712Message {
            pub fn domain<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Eip712Domain>,
                T::Error: ::std::fmt::Display,
            {
                self.domain = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for domain: {}", e));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
            pub fn primary_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.primary_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for primary_type: {}", e)
                });
                self
            }
            pub fn types<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Eip712Types>,
                T::Error: ::std::fmt::Display,
            {
                self.types = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for types: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<Eip712Message> for super::Eip712Message {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Eip712Message,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    domain: value.domain?,
                    message: value.message?,
                    primary_type: value.primary_type?,
                    types: value.types?,
                })
            }
        }
        impl ::std::convert::From<super::Eip712Message> for Eip712Message {
            fn from(value: super::Eip712Message) -> Self {
                Self {
                    domain: Ok(value.domain),
                    message: Ok(value.message),
                    primary_type: Ok(value.primary_type),
                    types: Ok(value.types),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EmailAuthentication {
            email: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<super::EmailAuthenticationType, ::std::string::String>,
        }
        impl ::std::default::Default for EmailAuthentication {
            fn default() -> Self {
                Self {
                    email: Err("no value supplied for email".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl EmailAuthentication {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EmailAuthenticationType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EmailAuthentication> for super::EmailAuthentication {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EmailAuthentication,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::EmailAuthentication> for EmailAuthentication {
            fn from(value: super::EmailAuthentication) -> Self {
                Self {
                    email: Ok(value.email),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EndUser {
            authentication_methods:
                ::std::result::Result<super::AuthenticationMethods, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            evm_account_objects: ::std::result::Result<
                ::std::vec::Vec<super::EndUserEvmAccount>,
                ::std::string::String,
            >,
            evm_accounts: ::std::result::Result<
                ::std::vec::Vec<super::EndUserEvmAccountsItem>,
                ::std::string::String,
            >,
            evm_smart_account_objects: ::std::result::Result<
                ::std::vec::Vec<super::EndUserEvmSmartAccount>,
                ::std::string::String,
            >,
            evm_smart_accounts: ::std::result::Result<
                ::std::vec::Vec<super::EndUserEvmSmartAccountsItem>,
                ::std::string::String,
            >,
            solana_account_objects: ::std::result::Result<
                ::std::vec::Vec<super::EndUserSolanaAccount>,
                ::std::string::String,
            >,
            solana_accounts: ::std::result::Result<
                ::std::vec::Vec<super::EndUserSolanaAccountsItem>,
                ::std::string::String,
            >,
            user_id: ::std::result::Result<super::EndUserUserId, ::std::string::String>,
        }
        impl ::std::default::Default for EndUser {
            fn default() -> Self {
                Self {
                    authentication_methods: Err(
                        "no value supplied for authentication_methods".to_string()
                    ),
                    created_at: Err("no value supplied for created_at".to_string()),
                    evm_account_objects: Err(
                        "no value supplied for evm_account_objects".to_string()
                    ),
                    evm_accounts: Err("no value supplied for evm_accounts".to_string()),
                    evm_smart_account_objects: Err(
                        "no value supplied for evm_smart_account_objects".to_string(),
                    ),
                    evm_smart_accounts: Err("no value supplied for evm_smart_accounts".to_string()),
                    solana_account_objects: Err(
                        "no value supplied for solana_account_objects".to_string()
                    ),
                    solana_accounts: Err("no value supplied for solana_accounts".to_string()),
                    user_id: Err("no value supplied for user_id".to_string()),
                }
            }
        }
        impl EndUser {
            pub fn authentication_methods<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AuthenticationMethods>,
                T::Error: ::std::fmt::Display,
            {
                self.authentication_methods = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for authentication_methods: {}",
                        e
                    )
                });
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn evm_account_objects<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EndUserEvmAccount>>,
                T::Error: ::std::fmt::Display,
            {
                self.evm_account_objects = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for evm_account_objects: {}",
                        e
                    )
                });
                self
            }
            pub fn evm_accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EndUserEvmAccountsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.evm_accounts = value.try_into().map_err(|e| {
                    format!("error converting supplied value for evm_accounts: {}", e)
                });
                self
            }
            pub fn evm_smart_account_objects<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EndUserEvmSmartAccount>>,
                T::Error: ::std::fmt::Display,
            {
                self.evm_smart_account_objects = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for evm_smart_account_objects: {}",
                        e
                    )
                });
                self
            }
            pub fn evm_smart_accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EndUserEvmSmartAccountsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.evm_smart_accounts = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for evm_smart_accounts: {}",
                        e
                    )
                });
                self
            }
            pub fn solana_account_objects<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EndUserSolanaAccount>>,
                T::Error: ::std::fmt::Display,
            {
                self.solana_account_objects = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for solana_account_objects: {}",
                        e
                    )
                });
                self
            }
            pub fn solana_accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EndUserSolanaAccountsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.solana_accounts = value.try_into().map_err(|e| {
                    format!("error converting supplied value for solana_accounts: {}", e)
                });
                self
            }
            pub fn user_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EndUserUserId>,
                T::Error: ::std::fmt::Display,
            {
                self.user_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_id: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EndUser> for super::EndUser {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EndUser,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    authentication_methods: value.authentication_methods?,
                    created_at: value.created_at?,
                    evm_account_objects: value.evm_account_objects?,
                    evm_accounts: value.evm_accounts?,
                    evm_smart_account_objects: value.evm_smart_account_objects?,
                    evm_smart_accounts: value.evm_smart_accounts?,
                    solana_account_objects: value.solana_account_objects?,
                    solana_accounts: value.solana_accounts?,
                    user_id: value.user_id?,
                })
            }
        }
        impl ::std::convert::From<super::EndUser> for EndUser {
            fn from(value: super::EndUser) -> Self {
                Self {
                    authentication_methods: Ok(value.authentication_methods),
                    created_at: Ok(value.created_at),
                    evm_account_objects: Ok(value.evm_account_objects),
                    evm_accounts: Ok(value.evm_accounts),
                    evm_smart_account_objects: Ok(value.evm_smart_account_objects),
                    evm_smart_accounts: Ok(value.evm_smart_accounts),
                    solana_account_objects: Ok(value.solana_account_objects),
                    solana_accounts: Ok(value.solana_accounts),
                    user_id: Ok(value.user_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EndUserEvmAccount {
            address: ::std::result::Result<super::EndUserEvmAccountAddress, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EndUserEvmAccount {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                }
            }
        }
        impl EndUserEvmAccount {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EndUserEvmAccountAddress>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EndUserEvmAccount> for super::EndUserEvmAccount {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EndUserEvmAccount,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    created_at: value.created_at?,
                })
            }
        }
        impl ::std::convert::From<super::EndUserEvmAccount> for EndUserEvmAccount {
            fn from(value: super::EndUserEvmAccount) -> Self {
                Self {
                    address: Ok(value.address),
                    created_at: Ok(value.created_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EndUserEvmSmartAccount {
            address:
                ::std::result::Result<super::EndUserEvmSmartAccountAddress, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            owner_addresses: ::std::result::Result<
                ::std::vec::Vec<super::EndUserEvmSmartAccountOwnerAddressesItem>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EndUserEvmSmartAccount {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    owner_addresses: Err("no value supplied for owner_addresses".to_string()),
                }
            }
        }
        impl EndUserEvmSmartAccount {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EndUserEvmSmartAccountAddress>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn owner_addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::EndUserEvmSmartAccountOwnerAddressesItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.owner_addresses = value.try_into().map_err(|e| {
                    format!("error converting supplied value for owner_addresses: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<EndUserEvmSmartAccount> for super::EndUserEvmSmartAccount {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EndUserEvmSmartAccount,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    created_at: value.created_at?,
                    owner_addresses: value.owner_addresses?,
                })
            }
        }
        impl ::std::convert::From<super::EndUserEvmSmartAccount> for EndUserEvmSmartAccount {
            fn from(value: super::EndUserEvmSmartAccount) -> Self {
                Self {
                    address: Ok(value.address),
                    created_at: Ok(value.created_at),
                    owner_addresses: Ok(value.owner_addresses),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EndUserSolanaAccount {
            address:
                ::std::result::Result<super::EndUserSolanaAccountAddress, ::std::string::String>,
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EndUserSolanaAccount {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                }
            }
        }
        impl EndUserSolanaAccount {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EndUserSolanaAccountAddress>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EndUserSolanaAccount> for super::EndUserSolanaAccount {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EndUserSolanaAccount,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    created_at: value.created_at?,
                })
            }
        }
        impl ::std::convert::From<super::EndUserSolanaAccount> for EndUserSolanaAccount {
            fn from(value: super::EndUserSolanaAccount) -> Self {
                Self {
                    address: Ok(value.address),
                    created_at: Ok(value.created_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Error {
            correlation_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            error_link:
                ::std::result::Result<::std::option::Option<super::Url>, ::std::string::String>,
            error_message: ::std::result::Result<::std::string::String, ::std::string::String>,
            error_type: ::std::result::Result<super::ErrorType, ::std::string::String>,
        }
        impl ::std::default::Default for Error {
            fn default() -> Self {
                Self {
                    correlation_id: Ok(Default::default()),
                    error_link: Ok(Default::default()),
                    error_message: Err("no value supplied for error_message".to_string()),
                    error_type: Err("no value supplied for error_type".to_string()),
                }
            }
        }
        impl Error {
            pub fn correlation_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.correlation_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for correlation_id: {}", e)
                });
                self
            }
            pub fn error_link<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Url>>,
                T::Error: ::std::fmt::Display,
            {
                self.error_link = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_link: {}", e));
                self
            }
            pub fn error_message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.error_message = value.try_into().map_err(|e| {
                    format!("error converting supplied value for error_message: {}", e)
                });
                self
            }
            pub fn error_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ErrorType>,
                T::Error: ::std::fmt::Display,
            {
                self.error_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_type: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<Error> for super::Error {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Error,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    correlation_id: value.correlation_id?,
                    error_link: value.error_link?,
                    error_message: value.error_message?,
                    error_type: value.error_type?,
                })
            }
        }
        impl ::std::convert::From<super::Error> for Error {
            fn from(value: super::Error) -> Self {
                Self {
                    correlation_id: Ok(value.correlation_id),
                    error_link: Ok(value.error_link),
                    error_message: Ok(value.error_message),
                    error_type: Ok(value.error_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthValueCriterion {
            eth_value:
                ::std::result::Result<super::EthValueCriterionEthValue, ::std::string::String>,
            operator:
                ::std::result::Result<super::EthValueCriterionOperator, ::std::string::String>,
            type_: ::std::result::Result<super::EthValueCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for EthValueCriterion {
            fn default() -> Self {
                Self {
                    eth_value: Err("no value supplied for eth_value".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl EthValueCriterion {
            pub fn eth_value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthValueCriterionEthValue>,
                T::Error: ::std::fmt::Display,
            {
                self.eth_value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for eth_value: {}", e));
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthValueCriterionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthValueCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthValueCriterion> for super::EthValueCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthValueCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    eth_value: value.eth_value?,
                    operator: value.operator?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::EthValueCriterion> for EthValueCriterion {
            fn from(value: super::EthValueCriterion) -> Self {
                Self {
                    eth_value: Ok(value.eth_value),
                    operator: Ok(value.operator),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvmAccount {
            address: ::std::result::Result<super::EvmAccountAddress, ::std::string::String>,
            created_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<super::EvmAccountName>,
                ::std::string::String,
            >,
            policies: ::std::result::Result<
                ::std::vec::Vec<super::EvmAccountPoliciesItem>,
                ::std::string::String,
            >,
            updated_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EvmAccount {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    created_at: Ok(Default::default()),
                    name: Ok(Default::default()),
                    policies: Ok(Default::default()),
                    updated_at: Ok(Default::default()),
                }
            }
        }
        impl EvmAccount {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmAccountAddress>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::EvmAccountName>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn policies<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EvmAccountPoliciesItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.policies = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policies: {}", e));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EvmAccount> for super::EvmAccount {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvmAccount,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    created_at: value.created_at?,
                    name: value.name?,
                    policies: value.policies?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::EvmAccount> for EvmAccount {
            fn from(value: super::EvmAccount) -> Self {
                Self {
                    address: Ok(value.address),
                    created_at: Ok(value.created_at),
                    name: Ok(value.name),
                    policies: Ok(value.policies),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvmAddressCriterion {
            addresses: ::std::result::Result<
                ::std::vec::Vec<super::EvmAddressCriterionAddressesItem>,
                ::std::string::String,
            >,
            operator:
                ::std::result::Result<super::EvmAddressCriterionOperator, ::std::string::String>,
            type_: ::std::result::Result<super::EvmAddressCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for EvmAddressCriterion {
            fn default() -> Self {
                Self {
                    addresses: Err("no value supplied for addresses".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl EvmAddressCriterion {
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::EvmAddressCriterionAddressesItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for addresses: {}", e));
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmAddressCriterionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmAddressCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EvmAddressCriterion> for super::EvmAddressCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvmAddressCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addresses: value.addresses?,
                    operator: value.operator?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::EvmAddressCriterion> for EvmAddressCriterion {
            fn from(value: super::EvmAddressCriterion) -> Self {
                Self {
                    addresses: Ok(value.addresses),
                    operator: Ok(value.operator),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvmCall {
            data: ::std::result::Result<super::EvmCallData, ::std::string::String>,
            override_gas_limit: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            to: ::std::result::Result<super::EvmCallTo, ::std::string::String>,
            value: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for EvmCall {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    override_gas_limit: Ok(Default::default()),
                    to: Err("no value supplied for to".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl EvmCall {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmCallData>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn override_gas_limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.override_gas_limit = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for override_gas_limit: {}",
                        e
                    )
                });
                self
            }
            pub fn to<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmCallTo>,
                T::Error: ::std::fmt::Display,
            {
                self.to = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EvmCall> for super::EvmCall {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvmCall,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    override_gas_limit: value.override_gas_limit?,
                    to: value.to?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::EvmCall> for EvmCall {
            fn from(value: super::EvmCall) -> Self {
                Self {
                    data: Ok(value.data),
                    override_gas_limit: Ok(value.override_gas_limit),
                    to: Ok(value.to),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvmDataCondition {
            function: ::std::result::Result<::std::string::String, ::std::string::String>,
            params: ::std::result::Result<
                ::std::vec::Vec<super::EvmDataConditionParamsItem>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EvmDataCondition {
            fn default() -> Self {
                Self {
                    function: Err("no value supplied for function".to_string()),
                    params: Ok(Default::default()),
                }
            }
        }
        impl EvmDataCondition {
            pub fn function<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.function = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for function: {}", e));
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EvmDataConditionParamsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for params: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EvmDataCondition> for super::EvmDataCondition {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvmDataCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    function: value.function?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::EvmDataCondition> for EvmDataCondition {
            fn from(value: super::EvmDataCondition) -> Self {
                Self {
                    function: Ok(value.function),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvmDataCriterion {
            abi: ::std::result::Result<super::EvmDataCriterionAbi, ::std::string::String>,
            conditions: ::std::result::Result<
                ::std::vec::Vec<super::EvmDataCondition>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<super::EvmDataCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for EvmDataCriterion {
            fn default() -> Self {
                Self {
                    abi: Err("no value supplied for abi".to_string()),
                    conditions: Err("no value supplied for conditions".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl EvmDataCriterion {
            pub fn abi<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmDataCriterionAbi>,
                T::Error: ::std::fmt::Display,
            {
                self.abi = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for abi: {}", e));
                self
            }
            pub fn conditions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EvmDataCondition>>,
                T::Error: ::std::fmt::Display,
            {
                self.conditions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for conditions: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmDataCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EvmDataCriterion> for super::EvmDataCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvmDataCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    abi: value.abi?,
                    conditions: value.conditions?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::EvmDataCriterion> for EvmDataCriterion {
            fn from(value: super::EvmDataCriterion) -> Self {
                Self {
                    abi: Ok(value.abi),
                    conditions: Ok(value.conditions),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvmDataParameterCondition {
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            operator: ::std::result::Result<
                super::EvmDataParameterConditionOperator,
                ::std::string::String,
            >,
            value: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for EvmDataParameterCondition {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl EvmDataParameterCondition {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmDataParameterConditionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EvmDataParameterCondition> for super::EvmDataParameterCondition {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvmDataParameterCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    operator: value.operator?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::EvmDataParameterCondition> for EvmDataParameterCondition {
            fn from(value: super::EvmDataParameterCondition) -> Self {
                Self {
                    name: Ok(value.name),
                    operator: Ok(value.operator),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvmDataParameterConditionList {
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            operator: ::std::result::Result<
                super::EvmDataParameterConditionListOperator,
                ::std::string::String,
            >,
            values: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EvmDataParameterConditionList {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl EvmDataParameterConditionList {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmDataParameterConditionListOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for values: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EvmDataParameterConditionList>
            for super::EvmDataParameterConditionList
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvmDataParameterConditionList,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    operator: value.operator?,
                    values: value.values?,
                })
            }
        }
        impl ::std::convert::From<super::EvmDataParameterConditionList> for EvmDataParameterConditionList {
            fn from(value: super::EvmDataParameterConditionList) -> Self {
                Self {
                    name: Ok(value.name),
                    operator: Ok(value.operator),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvmMessageCriterion {
            match_: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<super::EvmMessageCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for EvmMessageCriterion {
            fn default() -> Self {
                Self {
                    match_: Err("no value supplied for match_".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl EvmMessageCriterion {
            pub fn match_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.match_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for match_: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmMessageCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EvmMessageCriterion> for super::EvmMessageCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvmMessageCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    match_: value.match_?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::EvmMessageCriterion> for EvmMessageCriterion {
            fn from(value: super::EvmMessageCriterion) -> Self {
                Self {
                    match_: Ok(value.match_),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvmNetworkCriterion {
            networks: ::std::result::Result<
                ::std::vec::Vec<super::EvmNetworkCriterionNetworksItem>,
                ::std::string::String,
            >,
            operator:
                ::std::result::Result<super::EvmNetworkCriterionOperator, ::std::string::String>,
            type_: ::std::result::Result<super::EvmNetworkCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for EvmNetworkCriterion {
            fn default() -> Self {
                Self {
                    networks: Err("no value supplied for networks".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl EvmNetworkCriterion {
            pub fn networks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EvmNetworkCriterionNetworksItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.networks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for networks: {}", e));
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmNetworkCriterionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmNetworkCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EvmNetworkCriterion> for super::EvmNetworkCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvmNetworkCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    networks: value.networks?,
                    operator: value.operator?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::EvmNetworkCriterion> for EvmNetworkCriterion {
            fn from(value: super::EvmNetworkCriterion) -> Self {
                Self {
                    networks: Ok(value.networks),
                    operator: Ok(value.operator),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvmSmartAccount {
            address: ::std::result::Result<super::EvmSmartAccountAddress, ::std::string::String>,
            created_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<super::EvmSmartAccountName>,
                ::std::string::String,
            >,
            owners: ::std::result::Result<
                ::std::vec::Vec<super::EvmSmartAccountOwnersItem>,
                ::std::string::String,
            >,
            policies: ::std::result::Result<
                ::std::vec::Vec<super::EvmSmartAccountPoliciesItem>,
                ::std::string::String,
            >,
            updated_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EvmSmartAccount {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    created_at: Ok(Default::default()),
                    name: Ok(Default::default()),
                    owners: Err("no value supplied for owners".to_string()),
                    policies: Ok(Default::default()),
                    updated_at: Ok(Default::default()),
                }
            }
        }
        impl EvmSmartAccount {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmSmartAccountAddress>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::EvmSmartAccountName>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn owners<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EvmSmartAccountOwnersItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.owners = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for owners: {}", e));
                self
            }
            pub fn policies<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EvmSmartAccountPoliciesItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.policies = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policies: {}", e));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EvmSmartAccount> for super::EvmSmartAccount {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvmSmartAccount,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    created_at: value.created_at?,
                    name: value.name?,
                    owners: value.owners?,
                    policies: value.policies?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::EvmSmartAccount> for EvmSmartAccount {
            fn from(value: super::EvmSmartAccount) -> Self {
                Self {
                    address: Ok(value.address),
                    created_at: Ok(value.created_at),
                    name: Ok(value.name),
                    owners: Ok(value.owners),
                    policies: Ok(value.policies),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvmTypedAddressCondition {
            addresses: ::std::result::Result<
                ::std::vec::Vec<super::EvmTypedAddressConditionAddressesItem>,
                ::std::string::String,
            >,
            operator: ::std::result::Result<
                super::EvmTypedAddressConditionOperator,
                ::std::string::String,
            >,
            path: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for EvmTypedAddressCondition {
            fn default() -> Self {
                Self {
                    addresses: Err("no value supplied for addresses".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    path: Err("no value supplied for path".to_string()),
                }
            }
        }
        impl EvmTypedAddressCondition {
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::EvmTypedAddressConditionAddressesItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for addresses: {}", e));
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmTypedAddressConditionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EvmTypedAddressCondition> for super::EvmTypedAddressCondition {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvmTypedAddressCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addresses: value.addresses?,
                    operator: value.operator?,
                    path: value.path?,
                })
            }
        }
        impl ::std::convert::From<super::EvmTypedAddressCondition> for EvmTypedAddressCondition {
            fn from(value: super::EvmTypedAddressCondition) -> Self {
                Self {
                    addresses: Ok(value.addresses),
                    operator: Ok(value.operator),
                    path: Ok(value.path),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvmTypedNumericalCondition {
            operator: ::std::result::Result<
                super::EvmTypedNumericalConditionOperator,
                ::std::string::String,
            >,
            path: ::std::result::Result<::std::string::String, ::std::string::String>,
            value: ::std::result::Result<
                super::EvmTypedNumericalConditionValue,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EvmTypedNumericalCondition {
            fn default() -> Self {
                Self {
                    operator: Err("no value supplied for operator".to_string()),
                    path: Err("no value supplied for path".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl EvmTypedNumericalCondition {
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmTypedNumericalConditionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmTypedNumericalConditionValue>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EvmTypedNumericalCondition> for super::EvmTypedNumericalCondition {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvmTypedNumericalCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    operator: value.operator?,
                    path: value.path?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::EvmTypedNumericalCondition> for EvmTypedNumericalCondition {
            fn from(value: super::EvmTypedNumericalCondition) -> Self {
                Self {
                    operator: Ok(value.operator),
                    path: Ok(value.path),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvmTypedStringCondition {
            match_: ::std::result::Result<::std::string::String, ::std::string::String>,
            path: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for EvmTypedStringCondition {
            fn default() -> Self {
                Self {
                    match_: Err("no value supplied for match_".to_string()),
                    path: Err("no value supplied for path".to_string()),
                }
            }
        }
        impl EvmTypedStringCondition {
            pub fn match_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.match_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for match_: {}", e));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EvmTypedStringCondition> for super::EvmTypedStringCondition {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvmTypedStringCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    match_: value.match_?,
                    path: value.path?,
                })
            }
        }
        impl ::std::convert::From<super::EvmTypedStringCondition> for EvmTypedStringCondition {
            fn from(value: super::EvmTypedStringCondition) -> Self {
                Self {
                    match_: Ok(value.match_),
                    path: Ok(value.path),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EvmUserOperation {
            calls: ::std::result::Result<::std::vec::Vec<super::EvmCall>, ::std::string::String>,
            network: ::std::result::Result<super::EvmUserOperationNetwork, ::std::string::String>,
            receipts: ::std::result::Result<
                ::std::vec::Vec<super::UserOperationReceipt>,
                ::std::string::String,
            >,
            status: ::std::result::Result<super::EvmUserOperationStatus, ::std::string::String>,
            transaction_hash: ::std::result::Result<
                ::std::option::Option<super::EvmUserOperationTransactionHash>,
                ::std::string::String,
            >,
            user_op_hash:
                ::std::result::Result<super::EvmUserOperationUserOpHash, ::std::string::String>,
        }
        impl ::std::default::Default for EvmUserOperation {
            fn default() -> Self {
                Self {
                    calls: Err("no value supplied for calls".to_string()),
                    network: Err("no value supplied for network".to_string()),
                    receipts: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                    transaction_hash: Ok(Default::default()),
                    user_op_hash: Err("no value supplied for user_op_hash".to_string()),
                }
            }
        }
        impl EvmUserOperation {
            pub fn calls<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EvmCall>>,
                T::Error: ::std::fmt::Display,
            {
                self.calls = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for calls: {}", e));
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmUserOperationNetwork>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn receipts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::UserOperationReceipt>>,
                T::Error: ::std::fmt::Display,
            {
                self.receipts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for receipts: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmUserOperationStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn transaction_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::EvmUserOperationTransactionHash>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.transaction_hash = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for transaction_hash: {}",
                        e
                    )
                });
                self
            }
            pub fn user_op_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmUserOperationUserOpHash>,
                T::Error: ::std::fmt::Display,
            {
                self.user_op_hash = value.try_into().map_err(|e| {
                    format!("error converting supplied value for user_op_hash: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<EvmUserOperation> for super::EvmUserOperation {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EvmUserOperation,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    calls: value.calls?,
                    network: value.network?,
                    receipts: value.receipts?,
                    status: value.status?,
                    transaction_hash: value.transaction_hash?,
                    user_op_hash: value.user_op_hash?,
                })
            }
        }
        impl ::std::convert::From<super::EvmUserOperation> for EvmUserOperation {
            fn from(value: super::EvmUserOperation) -> Self {
                Self {
                    calls: Ok(value.calls),
                    network: Ok(value.network),
                    receipts: Ok(value.receipts),
                    status: Ok(value.status),
                    transaction_hash: Ok(value.transaction_hash),
                    user_op_hash: Ok(value.user_op_hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ExportEvmAccountBody {
            export_encryption_key:
                ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ExportEvmAccountBody {
            fn default() -> Self {
                Self {
                    export_encryption_key: Err(
                        "no value supplied for export_encryption_key".to_string()
                    ),
                }
            }
        }
        impl ExportEvmAccountBody {
            pub fn export_encryption_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.export_encryption_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for export_encryption_key: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ExportEvmAccountBody> for super::ExportEvmAccountBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ExportEvmAccountBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    export_encryption_key: value.export_encryption_key?,
                })
            }
        }
        impl ::std::convert::From<super::ExportEvmAccountBody> for ExportEvmAccountBody {
            fn from(value: super::ExportEvmAccountBody) -> Self {
                Self {
                    export_encryption_key: Ok(value.export_encryption_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ExportEvmAccountByNameBody {
            export_encryption_key:
                ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ExportEvmAccountByNameBody {
            fn default() -> Self {
                Self {
                    export_encryption_key: Err(
                        "no value supplied for export_encryption_key".to_string()
                    ),
                }
            }
        }
        impl ExportEvmAccountByNameBody {
            pub fn export_encryption_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.export_encryption_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for export_encryption_key: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ExportEvmAccountByNameBody> for super::ExportEvmAccountByNameBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ExportEvmAccountByNameBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    export_encryption_key: value.export_encryption_key?,
                })
            }
        }
        impl ::std::convert::From<super::ExportEvmAccountByNameBody> for ExportEvmAccountByNameBody {
            fn from(value: super::ExportEvmAccountByNameBody) -> Self {
                Self {
                    export_encryption_key: Ok(value.export_encryption_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ExportEvmAccountByNameResponse {
            encrypted_private_key:
                ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ExportEvmAccountByNameResponse {
            fn default() -> Self {
                Self {
                    encrypted_private_key: Err(
                        "no value supplied for encrypted_private_key".to_string()
                    ),
                }
            }
        }
        impl ExportEvmAccountByNameResponse {
            pub fn encrypted_private_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.encrypted_private_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for encrypted_private_key: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ExportEvmAccountByNameResponse>
            for super::ExportEvmAccountByNameResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ExportEvmAccountByNameResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encrypted_private_key: value.encrypted_private_key?,
                })
            }
        }
        impl ::std::convert::From<super::ExportEvmAccountByNameResponse>
            for ExportEvmAccountByNameResponse
        {
            fn from(value: super::ExportEvmAccountByNameResponse) -> Self {
                Self {
                    encrypted_private_key: Ok(value.encrypted_private_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ExportEvmAccountResponse {
            encrypted_private_key:
                ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ExportEvmAccountResponse {
            fn default() -> Self {
                Self {
                    encrypted_private_key: Err(
                        "no value supplied for encrypted_private_key".to_string()
                    ),
                }
            }
        }
        impl ExportEvmAccountResponse {
            pub fn encrypted_private_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.encrypted_private_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for encrypted_private_key: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ExportEvmAccountResponse> for super::ExportEvmAccountResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ExportEvmAccountResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encrypted_private_key: value.encrypted_private_key?,
                })
            }
        }
        impl ::std::convert::From<super::ExportEvmAccountResponse> for ExportEvmAccountResponse {
            fn from(value: super::ExportEvmAccountResponse) -> Self {
                Self {
                    encrypted_private_key: Ok(value.encrypted_private_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ExportSolanaAccountBody {
            export_encryption_key:
                ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ExportSolanaAccountBody {
            fn default() -> Self {
                Self {
                    export_encryption_key: Err(
                        "no value supplied for export_encryption_key".to_string()
                    ),
                }
            }
        }
        impl ExportSolanaAccountBody {
            pub fn export_encryption_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.export_encryption_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for export_encryption_key: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ExportSolanaAccountBody> for super::ExportSolanaAccountBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ExportSolanaAccountBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    export_encryption_key: value.export_encryption_key?,
                })
            }
        }
        impl ::std::convert::From<super::ExportSolanaAccountBody> for ExportSolanaAccountBody {
            fn from(value: super::ExportSolanaAccountBody) -> Self {
                Self {
                    export_encryption_key: Ok(value.export_encryption_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ExportSolanaAccountByNameBody {
            export_encryption_key:
                ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ExportSolanaAccountByNameBody {
            fn default() -> Self {
                Self {
                    export_encryption_key: Err(
                        "no value supplied for export_encryption_key".to_string()
                    ),
                }
            }
        }
        impl ExportSolanaAccountByNameBody {
            pub fn export_encryption_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.export_encryption_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for export_encryption_key: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ExportSolanaAccountByNameBody>
            for super::ExportSolanaAccountByNameBody
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ExportSolanaAccountByNameBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    export_encryption_key: value.export_encryption_key?,
                })
            }
        }
        impl ::std::convert::From<super::ExportSolanaAccountByNameBody> for ExportSolanaAccountByNameBody {
            fn from(value: super::ExportSolanaAccountByNameBody) -> Self {
                Self {
                    export_encryption_key: Ok(value.export_encryption_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ExportSolanaAccountByNameResponse {
            encrypted_private_key:
                ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ExportSolanaAccountByNameResponse {
            fn default() -> Self {
                Self {
                    encrypted_private_key: Err(
                        "no value supplied for encrypted_private_key".to_string()
                    ),
                }
            }
        }
        impl ExportSolanaAccountByNameResponse {
            pub fn encrypted_private_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.encrypted_private_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for encrypted_private_key: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ExportSolanaAccountByNameResponse>
            for super::ExportSolanaAccountByNameResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ExportSolanaAccountByNameResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encrypted_private_key: value.encrypted_private_key?,
                })
            }
        }
        impl ::std::convert::From<super::ExportSolanaAccountByNameResponse>
            for ExportSolanaAccountByNameResponse
        {
            fn from(value: super::ExportSolanaAccountByNameResponse) -> Self {
                Self {
                    encrypted_private_key: Ok(value.encrypted_private_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ExportSolanaAccountResponse {
            encrypted_private_key:
                ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ExportSolanaAccountResponse {
            fn default() -> Self {
                Self {
                    encrypted_private_key: Err(
                        "no value supplied for encrypted_private_key".to_string()
                    ),
                }
            }
        }
        impl ExportSolanaAccountResponse {
            pub fn encrypted_private_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.encrypted_private_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for encrypted_private_key: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ExportSolanaAccountResponse> for super::ExportSolanaAccountResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ExportSolanaAccountResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encrypted_private_key: value.encrypted_private_key?,
                })
            }
        }
        impl ::std::convert::From<super::ExportSolanaAccountResponse> for ExportSolanaAccountResponse {
            fn from(value: super::ExportSolanaAccountResponse) -> Self {
                Self {
                    encrypted_private_key: Ok(value.encrypted_private_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GetOnrampOrderByIdResponse {
            order: ::std::result::Result<super::OnrampOrder, ::std::string::String>,
        }
        impl ::std::default::Default for GetOnrampOrderByIdResponse {
            fn default() -> Self {
                Self {
                    order: Err("no value supplied for order".to_string()),
                }
            }
        }
        impl GetOnrampOrderByIdResponse {
            pub fn order<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OnrampOrder>,
                T::Error: ::std::fmt::Display,
            {
                self.order = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for order: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<GetOnrampOrderByIdResponse> for super::GetOnrampOrderByIdResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GetOnrampOrderByIdResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    order: value.order?,
                })
            }
        }
        impl ::std::convert::From<super::GetOnrampOrderByIdResponse> for GetOnrampOrderByIdResponse {
            fn from(value: super::GetOnrampOrderByIdResponse) -> Self {
                Self {
                    order: Ok(value.order),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GetSwapPriceResponse {
            block_number: ::std::result::Result<
                super::GetSwapPriceResponseBlockNumber,
                ::std::string::String,
            >,
            fees: ::std::result::Result<super::GetSwapPriceResponseFees, ::std::string::String>,
            from_amount:
                ::std::result::Result<super::GetSwapPriceResponseFromAmount, ::std::string::String>,
            from_token:
                ::std::result::Result<super::GetSwapPriceResponseFromToken, ::std::string::String>,
            gas: ::std::result::Result<
                ::std::option::Option<super::GetSwapPriceResponseGas>,
                ::std::string::String,
            >,
            gas_price:
                ::std::result::Result<super::GetSwapPriceResponseGasPrice, ::std::string::String>,
            issues: ::std::result::Result<super::GetSwapPriceResponseIssues, ::std::string::String>,
            liquidity_available: ::std::result::Result<bool, ::std::string::String>,
            min_to_amount: ::std::result::Result<
                super::GetSwapPriceResponseMinToAmount,
                ::std::string::String,
            >,
            to_amount:
                ::std::result::Result<super::GetSwapPriceResponseToAmount, ::std::string::String>,
            to_token:
                ::std::result::Result<super::GetSwapPriceResponseToToken, ::std::string::String>,
        }
        impl ::std::default::Default for GetSwapPriceResponse {
            fn default() -> Self {
                Self {
                    block_number: Err("no value supplied for block_number".to_string()),
                    fees: Err("no value supplied for fees".to_string()),
                    from_amount: Err("no value supplied for from_amount".to_string()),
                    from_token: Err("no value supplied for from_token".to_string()),
                    gas: Err("no value supplied for gas".to_string()),
                    gas_price: Err("no value supplied for gas_price".to_string()),
                    issues: Err("no value supplied for issues".to_string()),
                    liquidity_available: Err(
                        "no value supplied for liquidity_available".to_string()
                    ),
                    min_to_amount: Err("no value supplied for min_to_amount".to_string()),
                    to_amount: Err("no value supplied for to_amount".to_string()),
                    to_token: Err("no value supplied for to_token".to_string()),
                }
            }
        }
        impl GetSwapPriceResponse {
            pub fn block_number<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetSwapPriceResponseBlockNumber>,
                T::Error: ::std::fmt::Display,
            {
                self.block_number = value.try_into().map_err(|e| {
                    format!("error converting supplied value for block_number: {}", e)
                });
                self
            }
            pub fn fees<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetSwapPriceResponseFees>,
                T::Error: ::std::fmt::Display,
            {
                self.fees = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for fees: {}", e));
                self
            }
            pub fn from_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetSwapPriceResponseFromAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.from_amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for from_amount: {}", e));
                self
            }
            pub fn from_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetSwapPriceResponseFromToken>,
                T::Error: ::std::fmt::Display,
            {
                self.from_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for from_token: {}", e));
                self
            }
            pub fn gas<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::GetSwapPriceResponseGas>>,
                T::Error: ::std::fmt::Display,
            {
                self.gas = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas: {}", e));
                self
            }
            pub fn gas_price<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetSwapPriceResponseGasPrice>,
                T::Error: ::std::fmt::Display,
            {
                self.gas_price = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas_price: {}", e));
                self
            }
            pub fn issues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetSwapPriceResponseIssues>,
                T::Error: ::std::fmt::Display,
            {
                self.issues = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for issues: {}", e));
                self
            }
            pub fn liquidity_available<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.liquidity_available = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for liquidity_available: {}",
                        e
                    )
                });
                self
            }
            pub fn min_to_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetSwapPriceResponseMinToAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.min_to_amount = value.try_into().map_err(|e| {
                    format!("error converting supplied value for min_to_amount: {}", e)
                });
                self
            }
            pub fn to_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetSwapPriceResponseToAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.to_amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to_amount: {}", e));
                self
            }
            pub fn to_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetSwapPriceResponseToToken>,
                T::Error: ::std::fmt::Display,
            {
                self.to_token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to_token: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<GetSwapPriceResponse> for super::GetSwapPriceResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GetSwapPriceResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_number: value.block_number?,
                    fees: value.fees?,
                    from_amount: value.from_amount?,
                    from_token: value.from_token?,
                    gas: value.gas?,
                    gas_price: value.gas_price?,
                    issues: value.issues?,
                    liquidity_available: value.liquidity_available?,
                    min_to_amount: value.min_to_amount?,
                    to_amount: value.to_amount?,
                    to_token: value.to_token?,
                })
            }
        }
        impl ::std::convert::From<super::GetSwapPriceResponse> for GetSwapPriceResponse {
            fn from(value: super::GetSwapPriceResponse) -> Self {
                Self {
                    block_number: Ok(value.block_number),
                    fees: Ok(value.fees),
                    from_amount: Ok(value.from_amount),
                    from_token: Ok(value.from_token),
                    gas: Ok(value.gas),
                    gas_price: Ok(value.gas_price),
                    issues: Ok(value.issues),
                    liquidity_available: Ok(value.liquidity_available),
                    min_to_amount: Ok(value.min_to_amount),
                    to_amount: Ok(value.to_amount),
                    to_token: Ok(value.to_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GetSwapPriceResponseFees {
            gas_fee: ::std::result::Result<
                ::std::option::Option<super::TokenFee>,
                ::std::string::String,
            >,
            protocol_fee: ::std::result::Result<
                ::std::option::Option<super::TokenFee>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for GetSwapPriceResponseFees {
            fn default() -> Self {
                Self {
                    gas_fee: Err("no value supplied for gas_fee".to_string()),
                    protocol_fee: Err("no value supplied for protocol_fee".to_string()),
                }
            }
        }
        impl GetSwapPriceResponseFees {
            pub fn gas_fee<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::TokenFee>>,
                T::Error: ::std::fmt::Display,
            {
                self.gas_fee = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas_fee: {}", e));
                self
            }
            pub fn protocol_fee<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::TokenFee>>,
                T::Error: ::std::fmt::Display,
            {
                self.protocol_fee = value.try_into().map_err(|e| {
                    format!("error converting supplied value for protocol_fee: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<GetSwapPriceResponseFees> for super::GetSwapPriceResponseFees {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GetSwapPriceResponseFees,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    gas_fee: value.gas_fee?,
                    protocol_fee: value.protocol_fee?,
                })
            }
        }
        impl ::std::convert::From<super::GetSwapPriceResponseFees> for GetSwapPriceResponseFees {
            fn from(value: super::GetSwapPriceResponseFees) -> Self {
                Self {
                    gas_fee: Ok(value.gas_fee),
                    protocol_fee: Ok(value.protocol_fee),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GetSwapPriceResponseIssues {
            allowance: ::std::result::Result<
                ::std::option::Option<super::GetSwapPriceResponseIssuesAllowance>,
                ::std::string::String,
            >,
            balance: ::std::result::Result<
                ::std::option::Option<super::GetSwapPriceResponseIssuesBalance>,
                ::std::string::String,
            >,
            simulation_incomplete: ::std::result::Result<bool, ::std::string::String>,
        }
        impl ::std::default::Default for GetSwapPriceResponseIssues {
            fn default() -> Self {
                Self {
                    allowance: Err("no value supplied for allowance".to_string()),
                    balance: Err("no value supplied for balance".to_string()),
                    simulation_incomplete: Err(
                        "no value supplied for simulation_incomplete".to_string()
                    ),
                }
            }
        }
        impl GetSwapPriceResponseIssues {
            pub fn allowance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::GetSwapPriceResponseIssuesAllowance>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.allowance = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for allowance: {}", e));
                self
            }
            pub fn balance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::GetSwapPriceResponseIssuesBalance>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.balance = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for balance: {}", e));
                self
            }
            pub fn simulation_incomplete<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.simulation_incomplete = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for simulation_incomplete: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<GetSwapPriceResponseIssues> for super::GetSwapPriceResponseIssues {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GetSwapPriceResponseIssues,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allowance: value.allowance?,
                    balance: value.balance?,
                    simulation_incomplete: value.simulation_incomplete?,
                })
            }
        }
        impl ::std::convert::From<super::GetSwapPriceResponseIssues> for GetSwapPriceResponseIssues {
            fn from(value: super::GetSwapPriceResponseIssues) -> Self {
                Self {
                    allowance: Ok(value.allowance),
                    balance: Ok(value.balance),
                    simulation_incomplete: Ok(value.simulation_incomplete),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GetSwapPriceResponseIssuesAllowance {
            current_allowance: ::std::result::Result<
                super::GetSwapPriceResponseIssuesAllowanceCurrentAllowance,
                ::std::string::String,
            >,
            spender: ::std::result::Result<
                super::GetSwapPriceResponseIssuesAllowanceSpender,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for GetSwapPriceResponseIssuesAllowance {
            fn default() -> Self {
                Self {
                    current_allowance: Err("no value supplied for current_allowance".to_string()),
                    spender: Err("no value supplied for spender".to_string()),
                }
            }
        }
        impl GetSwapPriceResponseIssuesAllowance {
            pub fn current_allowance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::GetSwapPriceResponseIssuesAllowanceCurrentAllowance,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.current_allowance = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for current_allowance: {}",
                        e
                    )
                });
                self
            }
            pub fn spender<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetSwapPriceResponseIssuesAllowanceSpender>,
                T::Error: ::std::fmt::Display,
            {
                self.spender = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for spender: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<GetSwapPriceResponseIssuesAllowance>
            for super::GetSwapPriceResponseIssuesAllowance
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GetSwapPriceResponseIssuesAllowance,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    current_allowance: value.current_allowance?,
                    spender: value.spender?,
                })
            }
        }
        impl ::std::convert::From<super::GetSwapPriceResponseIssuesAllowance>
            for GetSwapPriceResponseIssuesAllowance
        {
            fn from(value: super::GetSwapPriceResponseIssuesAllowance) -> Self {
                Self {
                    current_allowance: Ok(value.current_allowance),
                    spender: Ok(value.spender),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GetSwapPriceResponseIssuesBalance {
            current_balance: ::std::result::Result<
                super::GetSwapPriceResponseIssuesBalanceCurrentBalance,
                ::std::string::String,
            >,
            required_balance: ::std::result::Result<
                super::GetSwapPriceResponseIssuesBalanceRequiredBalance,
                ::std::string::String,
            >,
            token: ::std::result::Result<
                super::GetSwapPriceResponseIssuesBalanceToken,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for GetSwapPriceResponseIssuesBalance {
            fn default() -> Self {
                Self {
                    current_balance: Err("no value supplied for current_balance".to_string()),
                    required_balance: Err("no value supplied for required_balance".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }
        impl GetSwapPriceResponseIssuesBalance {
            pub fn current_balance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetSwapPriceResponseIssuesBalanceCurrentBalance>,
                T::Error: ::std::fmt::Display,
            {
                self.current_balance = value.try_into().map_err(|e| {
                    format!("error converting supplied value for current_balance: {}", e)
                });
                self
            }
            pub fn required_balance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetSwapPriceResponseIssuesBalanceRequiredBalance>,
                T::Error: ::std::fmt::Display,
            {
                self.required_balance = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for required_balance: {}",
                        e
                    )
                });
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetSwapPriceResponseIssuesBalanceToken>,
                T::Error: ::std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<GetSwapPriceResponseIssuesBalance>
            for super::GetSwapPriceResponseIssuesBalance
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GetSwapPriceResponseIssuesBalance,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    current_balance: value.current_balance?,
                    required_balance: value.required_balance?,
                    token: value.token?,
                })
            }
        }
        impl ::std::convert::From<super::GetSwapPriceResponseIssuesBalance>
            for GetSwapPriceResponseIssuesBalance
        {
            fn from(value: super::GetSwapPriceResponseIssuesBalance) -> Self {
                Self {
                    current_balance: Ok(value.current_balance),
                    required_balance: Ok(value.required_balance),
                    token: Ok(value.token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Idl {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            instructions: ::std::result::Result<
                ::std::vec::Vec<super::IdlInstructionsItem>,
                ::std::string::String,
            >,
            metadata: ::std::result::Result<
                ::std::option::Option<super::IdlMetadata>,
                ::std::string::String,
            >,
            types: ::std::result::Result<
                ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for Idl {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    instructions: Err("no value supplied for instructions".to_string()),
                    metadata: Ok(Default::default()),
                    types: Ok(Default::default()),
                }
            }
        }
        impl Idl {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn instructions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::IdlInstructionsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.instructions = value.try_into().map_err(|e| {
                    format!("error converting supplied value for instructions: {}", e)
                });
                self
            }
            pub fn metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::IdlMetadata>>,
                T::Error: ::std::fmt::Display,
            {
                self.metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for metadata: {}", e));
                self
            }
            pub fn types<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.types = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for types: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<Idl> for super::Idl {
            type Error = super::error::ConversionError;
            fn try_from(value: Idl) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    instructions: value.instructions?,
                    metadata: value.metadata?,
                    types: value.types?,
                })
            }
        }
        impl ::std::convert::From<super::Idl> for Idl {
            fn from(value: super::Idl) -> Self {
                Self {
                    address: Ok(value.address),
                    instructions: Ok(value.instructions),
                    metadata: Ok(value.metadata),
                    types: Ok(value.types),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct IdlInstructionsItem {
            accounts: ::std::result::Result<
                ::std::vec::Vec<super::IdlInstructionsItemAccountsItem>,
                ::std::string::String,
            >,
            args: ::std::result::Result<
                ::std::vec::Vec<super::IdlInstructionsItemArgsItem>,
                ::std::string::String,
            >,
            discriminator: ::std::result::Result<[u8; 8usize], ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for IdlInstructionsItem {
            fn default() -> Self {
                Self {
                    accounts: Ok(Default::default()),
                    args: Err("no value supplied for args".to_string()),
                    discriminator: Err("no value supplied for discriminator".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }
        impl IdlInstructionsItem {
            pub fn accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::IdlInstructionsItemAccountsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.accounts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for accounts: {}", e));
                self
            }
            pub fn args<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::IdlInstructionsItemArgsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.args = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for args: {}", e));
                self
            }
            pub fn discriminator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<[u8; 8usize]>,
                T::Error: ::std::fmt::Display,
            {
                self.discriminator = value.try_into().map_err(|e| {
                    format!("error converting supplied value for discriminator: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<IdlInstructionsItem> for super::IdlInstructionsItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IdlInstructionsItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    accounts: value.accounts?,
                    args: value.args?,
                    discriminator: value.discriminator?,
                    name: value.name?,
                })
            }
        }
        impl ::std::convert::From<super::IdlInstructionsItem> for IdlInstructionsItem {
            fn from(value: super::IdlInstructionsItem) -> Self {
                Self {
                    accounts: Ok(value.accounts),
                    args: Ok(value.args),
                    discriminator: Ok(value.discriminator),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct IdlInstructionsItemAccountsItem {
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            signer: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            writable: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        }
        impl ::std::default::Default for IdlInstructionsItemAccountsItem {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    signer: Ok(Default::default()),
                    writable: Ok(Default::default()),
                }
            }
        }
        impl IdlInstructionsItemAccountsItem {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn signer<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.signer = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signer: {}", e));
                self
            }
            pub fn writable<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.writable = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for writable: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<IdlInstructionsItemAccountsItem>
            for super::IdlInstructionsItemAccountsItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IdlInstructionsItemAccountsItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    signer: value.signer?,
                    writable: value.writable?,
                })
            }
        }
        impl ::std::convert::From<super::IdlInstructionsItemAccountsItem>
            for IdlInstructionsItemAccountsItem
        {
            fn from(value: super::IdlInstructionsItemAccountsItem) -> Self {
                Self {
                    name: Ok(value.name),
                    signer: Ok(value.signer),
                    writable: Ok(value.writable),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct IdlInstructionsItemArgsItem {
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for IdlInstructionsItemArgsItem {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl IdlInstructionsItemArgsItem {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<IdlInstructionsItemArgsItem> for super::IdlInstructionsItemArgsItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IdlInstructionsItemArgsItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::IdlInstructionsItemArgsItem> for IdlInstructionsItemArgsItem {
            fn from(value: super::IdlInstructionsItemArgsItem) -> Self {
                Self {
                    name: Ok(value.name),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct IdlMetadata {
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            spec: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for IdlMetadata {
            fn default() -> Self {
                Self {
                    name: Ok(Default::default()),
                    spec: Ok(Default::default()),
                    version: Ok(Default::default()),
                }
            }
        }
        impl IdlMetadata {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn spec<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.spec = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for spec: {}", e));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<IdlMetadata> for super::IdlMetadata {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IdlMetadata,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    spec: value.spec?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::IdlMetadata> for IdlMetadata {
            fn from(value: super::IdlMetadata) -> Self {
                Self {
                    name: Ok(value.name),
                    spec: Ok(value.spec),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ImportEvmAccountBody {
            account_policy: ::std::result::Result<
                ::std::option::Option<super::ImportEvmAccountBodyAccountPolicy>,
                ::std::string::String,
            >,
            encrypted_private_key:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<super::ImportEvmAccountBodyName>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ImportEvmAccountBody {
            fn default() -> Self {
                Self {
                    account_policy: Ok(Default::default()),
                    encrypted_private_key: Err(
                        "no value supplied for encrypted_private_key".to_string()
                    ),
                    name: Ok(Default::default()),
                }
            }
        }
        impl ImportEvmAccountBody {
            pub fn account_policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::ImportEvmAccountBodyAccountPolicy>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.account_policy = value.try_into().map_err(|e| {
                    format!("error converting supplied value for account_policy: {}", e)
                });
                self
            }
            pub fn encrypted_private_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.encrypted_private_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for encrypted_private_key: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::ImportEvmAccountBodyName>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<ImportEvmAccountBody> for super::ImportEvmAccountBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ImportEvmAccountBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_policy: value.account_policy?,
                    encrypted_private_key: value.encrypted_private_key?,
                    name: value.name?,
                })
            }
        }
        impl ::std::convert::From<super::ImportEvmAccountBody> for ImportEvmAccountBody {
            fn from(value: super::ImportEvmAccountBody) -> Self {
                Self {
                    account_policy: Ok(value.account_policy),
                    encrypted_private_key: Ok(value.encrypted_private_key),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ImportSolanaAccountBody {
            encrypted_private_key:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<super::ImportSolanaAccountBodyName>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ImportSolanaAccountBody {
            fn default() -> Self {
                Self {
                    encrypted_private_key: Err(
                        "no value supplied for encrypted_private_key".to_string()
                    ),
                    name: Ok(Default::default()),
                }
            }
        }
        impl ImportSolanaAccountBody {
            pub fn encrypted_private_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.encrypted_private_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for encrypted_private_key: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::ImportSolanaAccountBodyName>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<ImportSolanaAccountBody> for super::ImportSolanaAccountBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ImportSolanaAccountBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encrypted_private_key: value.encrypted_private_key?,
                    name: value.name?,
                })
            }
        }
        impl ::std::convert::From<super::ImportSolanaAccountBody> for ImportSolanaAccountBody {
            fn from(value: super::ImportSolanaAccountBody) -> Self {
                Self {
                    encrypted_private_key: Ok(value.encrypted_private_key),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListDataTokenBalancesResponse {
            balances:
                ::std::result::Result<::std::vec::Vec<super::TokenBalance>, ::std::string::String>,
            next_page_token: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListDataTokenBalancesResponse {
            fn default() -> Self {
                Self {
                    balances: Err("no value supplied for balances".to_string()),
                    next_page_token: Ok(Default::default()),
                }
            }
        }
        impl ListDataTokenBalancesResponse {
            pub fn balances<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::TokenBalance>>,
                T::Error: ::std::fmt::Display,
            {
                self.balances = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for balances: {}", e));
                self
            }
            pub fn next_page_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page_token = value.try_into().map_err(|e| {
                    format!("error converting supplied value for next_page_token: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ListDataTokenBalancesResponse>
            for super::ListDataTokenBalancesResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListDataTokenBalancesResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    balances: value.balances?,
                    next_page_token: value.next_page_token?,
                })
            }
        }
        impl ::std::convert::From<super::ListDataTokenBalancesResponse> for ListDataTokenBalancesResponse {
            fn from(value: super::ListDataTokenBalancesResponse) -> Self {
                Self {
                    balances: Ok(value.balances),
                    next_page_token: Ok(value.next_page_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListEndUsersResponse {
            end_users:
                ::std::result::Result<::std::vec::Vec<super::EndUser>, ::std::string::String>,
            next_page_token: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListEndUsersResponse {
            fn default() -> Self {
                Self {
                    end_users: Err("no value supplied for end_users".to_string()),
                    next_page_token: Ok(Default::default()),
                }
            }
        }
        impl ListEndUsersResponse {
            pub fn end_users<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EndUser>>,
                T::Error: ::std::fmt::Display,
            {
                self.end_users = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for end_users: {}", e));
                self
            }
            pub fn next_page_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page_token = value.try_into().map_err(|e| {
                    format!("error converting supplied value for next_page_token: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ListEndUsersResponse> for super::ListEndUsersResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListEndUsersResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    end_users: value.end_users?,
                    next_page_token: value.next_page_token?,
                })
            }
        }
        impl ::std::convert::From<super::ListEndUsersResponse> for ListEndUsersResponse {
            fn from(value: super::ListEndUsersResponse) -> Self {
                Self {
                    end_users: Ok(value.end_users),
                    next_page_token: Ok(value.next_page_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListEvmAccountsResponse {
            accounts:
                ::std::result::Result<::std::vec::Vec<super::EvmAccount>, ::std::string::String>,
            next_page_token: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListEvmAccountsResponse {
            fn default() -> Self {
                Self {
                    accounts: Err("no value supplied for accounts".to_string()),
                    next_page_token: Ok(Default::default()),
                }
            }
        }
        impl ListEvmAccountsResponse {
            pub fn accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EvmAccount>>,
                T::Error: ::std::fmt::Display,
            {
                self.accounts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for accounts: {}", e));
                self
            }
            pub fn next_page_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page_token = value.try_into().map_err(|e| {
                    format!("error converting supplied value for next_page_token: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ListEvmAccountsResponse> for super::ListEvmAccountsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListEvmAccountsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    accounts: value.accounts?,
                    next_page_token: value.next_page_token?,
                })
            }
        }
        impl ::std::convert::From<super::ListEvmAccountsResponse> for ListEvmAccountsResponse {
            fn from(value: super::ListEvmAccountsResponse) -> Self {
                Self {
                    accounts: Ok(value.accounts),
                    next_page_token: Ok(value.next_page_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListEvmSmartAccountsResponse {
            accounts: ::std::result::Result<
                ::std::vec::Vec<super::EvmSmartAccount>,
                ::std::string::String,
            >,
            next_page_token: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListEvmSmartAccountsResponse {
            fn default() -> Self {
                Self {
                    accounts: Err("no value supplied for accounts".to_string()),
                    next_page_token: Ok(Default::default()),
                }
            }
        }
        impl ListEvmSmartAccountsResponse {
            pub fn accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EvmSmartAccount>>,
                T::Error: ::std::fmt::Display,
            {
                self.accounts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for accounts: {}", e));
                self
            }
            pub fn next_page_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page_token = value.try_into().map_err(|e| {
                    format!("error converting supplied value for next_page_token: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ListEvmSmartAccountsResponse> for super::ListEvmSmartAccountsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListEvmSmartAccountsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    accounts: value.accounts?,
                    next_page_token: value.next_page_token?,
                })
            }
        }
        impl ::std::convert::From<super::ListEvmSmartAccountsResponse> for ListEvmSmartAccountsResponse {
            fn from(value: super::ListEvmSmartAccountsResponse) -> Self {
                Self {
                    accounts: Ok(value.accounts),
                    next_page_token: Ok(value.next_page_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListEvmTokenBalancesResponse {
            balances:
                ::std::result::Result<::std::vec::Vec<super::TokenBalance>, ::std::string::String>,
            next_page_token: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListEvmTokenBalancesResponse {
            fn default() -> Self {
                Self {
                    balances: Err("no value supplied for balances".to_string()),
                    next_page_token: Ok(Default::default()),
                }
            }
        }
        impl ListEvmTokenBalancesResponse {
            pub fn balances<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::TokenBalance>>,
                T::Error: ::std::fmt::Display,
            {
                self.balances = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for balances: {}", e));
                self
            }
            pub fn next_page_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page_token = value.try_into().map_err(|e| {
                    format!("error converting supplied value for next_page_token: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ListEvmTokenBalancesResponse> for super::ListEvmTokenBalancesResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListEvmTokenBalancesResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    balances: value.balances?,
                    next_page_token: value.next_page_token?,
                })
            }
        }
        impl ::std::convert::From<super::ListEvmTokenBalancesResponse> for ListEvmTokenBalancesResponse {
            fn from(value: super::ListEvmTokenBalancesResponse) -> Self {
                Self {
                    balances: Ok(value.balances),
                    next_page_token: Ok(value.next_page_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListPoliciesResponse {
            next_page_token: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            policies: ::std::result::Result<::std::vec::Vec<super::Policy>, ::std::string::String>,
        }
        impl ::std::default::Default for ListPoliciesResponse {
            fn default() -> Self {
                Self {
                    next_page_token: Ok(Default::default()),
                    policies: Err("no value supplied for policies".to_string()),
                }
            }
        }
        impl ListPoliciesResponse {
            pub fn next_page_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page_token = value.try_into().map_err(|e| {
                    format!("error converting supplied value for next_page_token: {}", e)
                });
                self
            }
            pub fn policies<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Policy>>,
                T::Error: ::std::fmt::Display,
            {
                self.policies = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policies: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<ListPoliciesResponse> for super::ListPoliciesResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListPoliciesResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    next_page_token: value.next_page_token?,
                    policies: value.policies?,
                })
            }
        }
        impl ::std::convert::From<super::ListPoliciesResponse> for ListPoliciesResponse {
            fn from(value: super::ListPoliciesResponse) -> Self {
                Self {
                    next_page_token: Ok(value.next_page_token),
                    policies: Ok(value.policies),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListResponse {
            next_page_token: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListResponse {
            fn default() -> Self {
                Self {
                    next_page_token: Ok(Default::default()),
                }
            }
        }
        impl ListResponse {
            pub fn next_page_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page_token = value.try_into().map_err(|e| {
                    format!("error converting supplied value for next_page_token: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ListResponse> for super::ListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    next_page_token: value.next_page_token?,
                })
            }
        }
        impl ::std::convert::From<super::ListResponse> for ListResponse {
            fn from(value: super::ListResponse) -> Self {
                Self {
                    next_page_token: Ok(value.next_page_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListSolanaAccountsResponse {
            accounts:
                ::std::result::Result<::std::vec::Vec<super::SolanaAccount>, ::std::string::String>,
            next_page_token: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListSolanaAccountsResponse {
            fn default() -> Self {
                Self {
                    accounts: Err("no value supplied for accounts".to_string()),
                    next_page_token: Ok(Default::default()),
                }
            }
        }
        impl ListSolanaAccountsResponse {
            pub fn accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SolanaAccount>>,
                T::Error: ::std::fmt::Display,
            {
                self.accounts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for accounts: {}", e));
                self
            }
            pub fn next_page_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page_token = value.try_into().map_err(|e| {
                    format!("error converting supplied value for next_page_token: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ListSolanaAccountsResponse> for super::ListSolanaAccountsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListSolanaAccountsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    accounts: value.accounts?,
                    next_page_token: value.next_page_token?,
                })
            }
        }
        impl ::std::convert::From<super::ListSolanaAccountsResponse> for ListSolanaAccountsResponse {
            fn from(value: super::ListSolanaAccountsResponse) -> Self {
                Self {
                    accounts: Ok(value.accounts),
                    next_page_token: Ok(value.next_page_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListSolanaTokenBalancesResponse {
            balances: ::std::result::Result<
                ::std::vec::Vec<super::SolanaTokenBalance>,
                ::std::string::String,
            >,
            next_page_token: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListSolanaTokenBalancesResponse {
            fn default() -> Self {
                Self {
                    balances: Err("no value supplied for balances".to_string()),
                    next_page_token: Ok(Default::default()),
                }
            }
        }
        impl ListSolanaTokenBalancesResponse {
            pub fn balances<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SolanaTokenBalance>>,
                T::Error: ::std::fmt::Display,
            {
                self.balances = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for balances: {}", e));
                self
            }
            pub fn next_page_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page_token = value.try_into().map_err(|e| {
                    format!("error converting supplied value for next_page_token: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ListSolanaTokenBalancesResponse>
            for super::ListSolanaTokenBalancesResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListSolanaTokenBalancesResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    balances: value.balances?,
                    next_page_token: value.next_page_token?,
                })
            }
        }
        impl ::std::convert::From<super::ListSolanaTokenBalancesResponse>
            for ListSolanaTokenBalancesResponse
        {
            fn from(value: super::ListSolanaTokenBalancesResponse) -> Self {
                Self {
                    balances: Ok(value.balances),
                    next_page_token: Ok(value.next_page_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListSpendPermissionsResponse {
            next_page_token: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            spend_permissions: ::std::result::Result<
                ::std::vec::Vec<super::SpendPermissionResponseObject>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListSpendPermissionsResponse {
            fn default() -> Self {
                Self {
                    next_page_token: Ok(Default::default()),
                    spend_permissions: Err("no value supplied for spend_permissions".to_string()),
                }
            }
        }
        impl ListSpendPermissionsResponse {
            pub fn next_page_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page_token = value.try_into().map_err(|e| {
                    format!("error converting supplied value for next_page_token: {}", e)
                });
                self
            }
            pub fn spend_permissions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SpendPermissionResponseObject>>,
                T::Error: ::std::fmt::Display,
            {
                self.spend_permissions = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for spend_permissions: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ListSpendPermissionsResponse> for super::ListSpendPermissionsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListSpendPermissionsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    next_page_token: value.next_page_token?,
                    spend_permissions: value.spend_permissions?,
                })
            }
        }
        impl ::std::convert::From<super::ListSpendPermissionsResponse> for ListSpendPermissionsResponse {
            fn from(value: super::ListSpendPermissionsResponse) -> Self {
                Self {
                    next_page_token: Ok(value.next_page_token),
                    spend_permissions: Ok(value.spend_permissions),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MintAddressCriterion {
            addresses: ::std::result::Result<
                ::std::vec::Vec<super::MintAddressCriterionAddressesItem>,
                ::std::string::String,
            >,
            operator:
                ::std::result::Result<super::MintAddressCriterionOperator, ::std::string::String>,
            type_: ::std::result::Result<super::MintAddressCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for MintAddressCriterion {
            fn default() -> Self {
                Self {
                    addresses: Err("no value supplied for addresses".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl MintAddressCriterion {
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::MintAddressCriterionAddressesItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for addresses: {}", e));
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::MintAddressCriterionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::MintAddressCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<MintAddressCriterion> for super::MintAddressCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MintAddressCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addresses: value.addresses?,
                    operator: value.operator?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::MintAddressCriterion> for MintAddressCriterion {
            fn from(value: super::MintAddressCriterion) -> Self {
                Self {
                    addresses: Ok(value.addresses),
                    operator: Ok(value.operator),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NetUsdChangeCriterion {
            change_cents: ::std::result::Result<i64, ::std::string::String>,
            operator:
                ::std::result::Result<super::NetUsdChangeCriterionOperator, ::std::string::String>,
            type_: ::std::result::Result<super::NetUsdChangeCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for NetUsdChangeCriterion {
            fn default() -> Self {
                Self {
                    change_cents: Err("no value supplied for change_cents".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl NetUsdChangeCriterion {
            pub fn change_cents<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.change_cents = value.try_into().map_err(|e| {
                    format!("error converting supplied value for change_cents: {}", e)
                });
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NetUsdChangeCriterionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NetUsdChangeCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<NetUsdChangeCriterion> for super::NetUsdChangeCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NetUsdChangeCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    change_cents: value.change_cents?,
                    operator: value.operator?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::NetUsdChangeCriterion> for NetUsdChangeCriterion {
            fn from(value: super::NetUsdChangeCriterion) -> Self {
                Self {
                    change_cents: Ok(value.change_cents),
                    operator: Ok(value.operator),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OAuth2Authentication {
            email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            sub: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<super::OAuth2ProviderType, ::std::string::String>,
            username: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for OAuth2Authentication {
            fn default() -> Self {
                Self {
                    email: Ok(Default::default()),
                    name: Ok(Default::default()),
                    sub: Err("no value supplied for sub".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    username: Ok(Default::default()),
                }
            }
        }
        impl OAuth2Authentication {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn sub<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.sub = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sub: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OAuth2ProviderType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<OAuth2Authentication> for super::OAuth2Authentication {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OAuth2Authentication,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    name: value.name?,
                    sub: value.sub?,
                    type_: value.type_?,
                    username: value.username?,
                })
            }
        }
        impl ::std::convert::From<super::OAuth2Authentication> for OAuth2Authentication {
            fn from(value: super::OAuth2Authentication) -> Self {
                Self {
                    email: Ok(value.email),
                    name: Ok(value.name),
                    sub: Ok(value.sub),
                    type_: Ok(value.type_),
                    username: Ok(value.username),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OnchainDataQuery {
            cache: ::std::result::Result<
                ::std::option::Option<super::QueryResultCacheConfiguration>,
                ::std::string::String,
            >,
            sql: ::std::result::Result<super::OnchainDataQuerySql, ::std::string::String>,
        }
        impl ::std::default::Default for OnchainDataQuery {
            fn default() -> Self {
                Self {
                    cache: Ok(Default::default()),
                    sql: Err("no value supplied for sql".to_string()),
                }
            }
        }
        impl OnchainDataQuery {
            pub fn cache<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::QueryResultCacheConfiguration>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.cache = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cache: {}", e));
                self
            }
            pub fn sql<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OnchainDataQuerySql>,
                T::Error: ::std::fmt::Display,
            {
                self.sql = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sql: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<OnchainDataQuery> for super::OnchainDataQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OnchainDataQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cache: value.cache?,
                    sql: value.sql?,
                })
            }
        }
        impl ::std::convert::From<super::OnchainDataQuery> for OnchainDataQuery {
            fn from(value: super::OnchainDataQuery) -> Self {
                Self {
                    cache: Ok(value.cache),
                    sql: Ok(value.sql),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OnchainDataResult {
            metadata: ::std::result::Result<
                ::std::option::Option<super::OnchainDataResultMetadata>,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
                ::std::string::String,
            >,
            schema: ::std::result::Result<
                ::std::option::Option<super::OnchainDataResultSchema>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for OnchainDataResult {
            fn default() -> Self {
                Self {
                    metadata: Ok(Default::default()),
                    result: Ok(Default::default()),
                    schema: Ok(Default::default()),
                }
            }
        }
        impl OnchainDataResult {
            pub fn metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::OnchainDataResultMetadata>>,
                T::Error: ::std::fmt::Display,
            {
                self.metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for metadata: {}", e));
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<::serde_json::Map<::std::string::String, ::serde_json::Value>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for result: {}", e));
                self
            }
            pub fn schema<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::OnchainDataResultSchema>>,
                T::Error: ::std::fmt::Display,
            {
                self.schema = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for schema: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<OnchainDataResult> for super::OnchainDataResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OnchainDataResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    metadata: value.metadata?,
                    result: value.result?,
                    schema: value.schema?,
                })
            }
        }
        impl ::std::convert::From<super::OnchainDataResult> for OnchainDataResult {
            fn from(value: super::OnchainDataResult) -> Self {
                Self {
                    metadata: Ok(value.metadata),
                    result: Ok(value.result),
                    schema: Ok(value.schema),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OnchainDataResultMetadata {
            cached: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            execution_time_ms:
                ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            execution_timestamp: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            row_count: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        }
        impl ::std::default::Default for OnchainDataResultMetadata {
            fn default() -> Self {
                Self {
                    cached: Ok(Default::default()),
                    execution_time_ms: Ok(Default::default()),
                    execution_timestamp: Ok(Default::default()),
                    row_count: Ok(Default::default()),
                }
            }
        }
        impl OnchainDataResultMetadata {
            pub fn cached<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.cached = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cached: {}", e));
                self
            }
            pub fn execution_time_ms<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.execution_time_ms = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for execution_time_ms: {}",
                        e
                    )
                });
                self
            }
            pub fn execution_timestamp<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.execution_timestamp = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for execution_timestamp: {}",
                        e
                    )
                });
                self
            }
            pub fn row_count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.row_count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for row_count: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<OnchainDataResultMetadata> for super::OnchainDataResultMetadata {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OnchainDataResultMetadata,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cached: value.cached?,
                    execution_time_ms: value.execution_time_ms?,
                    execution_timestamp: value.execution_timestamp?,
                    row_count: value.row_count?,
                })
            }
        }
        impl ::std::convert::From<super::OnchainDataResultMetadata> for OnchainDataResultMetadata {
            fn from(value: super::OnchainDataResultMetadata) -> Self {
                Self {
                    cached: Ok(value.cached),
                    execution_time_ms: Ok(value.execution_time_ms),
                    execution_timestamp: Ok(value.execution_timestamp),
                    row_count: Ok(value.row_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OnchainDataResultSchema {
            columns: ::std::result::Result<
                ::std::vec::Vec<super::OnchainDataResultSchemaColumnsItem>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for OnchainDataResultSchema {
            fn default() -> Self {
                Self {
                    columns: Ok(Default::default()),
                }
            }
        }
        impl OnchainDataResultSchema {
            pub fn columns<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::OnchainDataResultSchemaColumnsItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.columns = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for columns: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<OnchainDataResultSchema> for super::OnchainDataResultSchema {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OnchainDataResultSchema,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    columns: value.columns?,
                })
            }
        }
        impl ::std::convert::From<super::OnchainDataResultSchema> for OnchainDataResultSchema {
            fn from(value: super::OnchainDataResultSchema) -> Self {
                Self {
                    columns: Ok(value.columns),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OnchainDataResultSchemaColumnsItem {
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                ::std::option::Option<super::OnchainDataResultSchemaColumnsItemType>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for OnchainDataResultSchemaColumnsItem {
            fn default() -> Self {
                Self {
                    name: Ok(Default::default()),
                    type_: Ok(Default::default()),
                }
            }
        }
        impl OnchainDataResultSchemaColumnsItem {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::OnchainDataResultSchemaColumnsItemType>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<OnchainDataResultSchemaColumnsItem>
            for super::OnchainDataResultSchemaColumnsItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OnchainDataResultSchemaColumnsItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::OnchainDataResultSchemaColumnsItem>
            for OnchainDataResultSchemaColumnsItem
        {
            fn from(value: super::OnchainDataResultSchemaColumnsItem) -> Self {
                Self {
                    name: Ok(value.name),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OnrampOrder {
            created_at: ::std::result::Result<::std::string::String, ::std::string::String>,
            destination_address:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            destination_network:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            exchange_rate: ::std::result::Result<::std::string::String, ::std::string::String>,
            fees: ::std::result::Result<
                ::std::vec::Vec<super::OnrampOrderFee>,
                ::std::string::String,
            >,
            order_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            partner_user_ref: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            payment_currency: ::std::result::Result<::std::string::String, ::std::string::String>,
            payment_method:
                ::std::result::Result<super::OnrampOrderPaymentMethodTypeId, ::std::string::String>,
            payment_subtotal: ::std::result::Result<::std::string::String, ::std::string::String>,
            payment_total: ::std::result::Result<::std::string::String, ::std::string::String>,
            purchase_amount: ::std::result::Result<::std::string::String, ::std::string::String>,
            purchase_currency: ::std::result::Result<::std::string::String, ::std::string::String>,
            status: ::std::result::Result<super::OnrampOrderStatus, ::std::string::String>,
            tx_hash: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            updated_at: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for OnrampOrder {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    destination_address: Err(
                        "no value supplied for destination_address".to_string()
                    ),
                    destination_network: Err(
                        "no value supplied for destination_network".to_string()
                    ),
                    exchange_rate: Err("no value supplied for exchange_rate".to_string()),
                    fees: Err("no value supplied for fees".to_string()),
                    order_id: Err("no value supplied for order_id".to_string()),
                    partner_user_ref: Ok(Default::default()),
                    payment_currency: Err("no value supplied for payment_currency".to_string()),
                    payment_method: Err("no value supplied for payment_method".to_string()),
                    payment_subtotal: Err("no value supplied for payment_subtotal".to_string()),
                    payment_total: Err("no value supplied for payment_total".to_string()),
                    purchase_amount: Err("no value supplied for purchase_amount".to_string()),
                    purchase_currency: Err("no value supplied for purchase_currency".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    tx_hash: Ok(Default::default()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl OnrampOrder {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn destination_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.destination_address = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for destination_address: {}",
                        e
                    )
                });
                self
            }
            pub fn destination_network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.destination_network = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for destination_network: {}",
                        e
                    )
                });
                self
            }
            pub fn exchange_rate<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.exchange_rate = value.try_into().map_err(|e| {
                    format!("error converting supplied value for exchange_rate: {}", e)
                });
                self
            }
            pub fn fees<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::OnrampOrderFee>>,
                T::Error: ::std::fmt::Display,
            {
                self.fees = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for fees: {}", e));
                self
            }
            pub fn order_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.order_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for order_id: {}", e));
                self
            }
            pub fn partner_user_ref<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.partner_user_ref = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for partner_user_ref: {}",
                        e
                    )
                });
                self
            }
            pub fn payment_currency<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_currency = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for payment_currency: {}",
                        e
                    )
                });
                self
            }
            pub fn payment_method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OnrampOrderPaymentMethodTypeId>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_method = value.try_into().map_err(|e| {
                    format!("error converting supplied value for payment_method: {}", e)
                });
                self
            }
            pub fn payment_subtotal<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_subtotal = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for payment_subtotal: {}",
                        e
                    )
                });
                self
            }
            pub fn payment_total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_total = value.try_into().map_err(|e| {
                    format!("error converting supplied value for payment_total: {}", e)
                });
                self
            }
            pub fn purchase_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.purchase_amount = value.try_into().map_err(|e| {
                    format!("error converting supplied value for purchase_amount: {}", e)
                });
                self
            }
            pub fn purchase_currency<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.purchase_currency = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for purchase_currency: {}",
                        e
                    )
                });
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OnrampOrderStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn tx_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.tx_hash = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for tx_hash: {}", e));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<OnrampOrder> for super::OnrampOrder {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OnrampOrder,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    destination_address: value.destination_address?,
                    destination_network: value.destination_network?,
                    exchange_rate: value.exchange_rate?,
                    fees: value.fees?,
                    order_id: value.order_id?,
                    partner_user_ref: value.partner_user_ref?,
                    payment_currency: value.payment_currency?,
                    payment_method: value.payment_method?,
                    payment_subtotal: value.payment_subtotal?,
                    payment_total: value.payment_total?,
                    purchase_amount: value.purchase_amount?,
                    purchase_currency: value.purchase_currency?,
                    status: value.status?,
                    tx_hash: value.tx_hash?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::OnrampOrder> for OnrampOrder {
            fn from(value: super::OnrampOrder) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    destination_address: Ok(value.destination_address),
                    destination_network: Ok(value.destination_network),
                    exchange_rate: Ok(value.exchange_rate),
                    fees: Ok(value.fees),
                    order_id: Ok(value.order_id),
                    partner_user_ref: Ok(value.partner_user_ref),
                    payment_currency: Ok(value.payment_currency),
                    payment_method: Ok(value.payment_method),
                    payment_subtotal: Ok(value.payment_subtotal),
                    payment_total: Ok(value.payment_total),
                    purchase_amount: Ok(value.purchase_amount),
                    purchase_currency: Ok(value.purchase_currency),
                    status: Ok(value.status),
                    tx_hash: Ok(value.tx_hash),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OnrampOrderFee {
            amount: ::std::result::Result<::std::string::String, ::std::string::String>,
            currency: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<super::OnrampOrderFeeType, ::std::string::String>,
        }
        impl ::std::default::Default for OnrampOrderFee {
            fn default() -> Self {
                Self {
                    amount: Err("no value supplied for amount".to_string()),
                    currency: Err("no value supplied for currency".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl OnrampOrderFee {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for amount: {}", e));
                self
            }
            pub fn currency<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.currency = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for currency: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OnrampOrderFeeType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<OnrampOrderFee> for super::OnrampOrderFee {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OnrampOrderFee,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    amount: value.amount?,
                    currency: value.currency?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::OnrampOrderFee> for OnrampOrderFee {
            fn from(value: super::OnrampOrderFee) -> Self {
                Self {
                    amount: Ok(value.amount),
                    currency: Ok(value.currency),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OnrampPaymentLink {
            payment_link_type:
                ::std::result::Result<super::OnrampPaymentLinkType, ::std::string::String>,
            url: ::std::result::Result<super::Url, ::std::string::String>,
        }
        impl ::std::default::Default for OnrampPaymentLink {
            fn default() -> Self {
                Self {
                    payment_link_type: Err("no value supplied for payment_link_type".to_string()),
                    url: Err("no value supplied for url".to_string()),
                }
            }
        }
        impl OnrampPaymentLink {
            pub fn payment_link_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OnrampPaymentLinkType>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_link_type = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for payment_link_type: {}",
                        e
                    )
                });
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Url>,
                T::Error: ::std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<OnrampPaymentLink> for super::OnrampPaymentLink {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OnrampPaymentLink,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    payment_link_type: value.payment_link_type?,
                    url: value.url?,
                })
            }
        }
        impl ::std::convert::From<super::OnrampPaymentLink> for OnrampPaymentLink {
            fn from(value: super::OnrampPaymentLink) -> Self {
                Self {
                    payment_link_type: Ok(value.payment_link_type),
                    url: Ok(value.url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OnrampQuote {
            destination_network:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            exchange_rate: ::std::result::Result<::std::string::String, ::std::string::String>,
            fees: ::std::result::Result<
                ::std::vec::Vec<super::OnrampOrderFee>,
                ::std::string::String,
            >,
            payment_currency: ::std::result::Result<::std::string::String, ::std::string::String>,
            payment_subtotal: ::std::result::Result<::std::string::String, ::std::string::String>,
            payment_total: ::std::result::Result<::std::string::String, ::std::string::String>,
            purchase_amount: ::std::result::Result<::std::string::String, ::std::string::String>,
            purchase_currency: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for OnrampQuote {
            fn default() -> Self {
                Self {
                    destination_network: Err(
                        "no value supplied for destination_network".to_string()
                    ),
                    exchange_rate: Err("no value supplied for exchange_rate".to_string()),
                    fees: Err("no value supplied for fees".to_string()),
                    payment_currency: Err("no value supplied for payment_currency".to_string()),
                    payment_subtotal: Err("no value supplied for payment_subtotal".to_string()),
                    payment_total: Err("no value supplied for payment_total".to_string()),
                    purchase_amount: Err("no value supplied for purchase_amount".to_string()),
                    purchase_currency: Err("no value supplied for purchase_currency".to_string()),
                }
            }
        }
        impl OnrampQuote {
            pub fn destination_network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.destination_network = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for destination_network: {}",
                        e
                    )
                });
                self
            }
            pub fn exchange_rate<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.exchange_rate = value.try_into().map_err(|e| {
                    format!("error converting supplied value for exchange_rate: {}", e)
                });
                self
            }
            pub fn fees<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::OnrampOrderFee>>,
                T::Error: ::std::fmt::Display,
            {
                self.fees = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for fees: {}", e));
                self
            }
            pub fn payment_currency<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_currency = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for payment_currency: {}",
                        e
                    )
                });
                self
            }
            pub fn payment_subtotal<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_subtotal = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for payment_subtotal: {}",
                        e
                    )
                });
                self
            }
            pub fn payment_total<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_total = value.try_into().map_err(|e| {
                    format!("error converting supplied value for payment_total: {}", e)
                });
                self
            }
            pub fn purchase_amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.purchase_amount = value.try_into().map_err(|e| {
                    format!("error converting supplied value for purchase_amount: {}", e)
                });
                self
            }
            pub fn purchase_currency<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.purchase_currency = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for purchase_currency: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<OnrampQuote> for super::OnrampQuote {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OnrampQuote,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    destination_network: value.destination_network?,
                    exchange_rate: value.exchange_rate?,
                    fees: value.fees?,
                    payment_currency: value.payment_currency?,
                    payment_subtotal: value.payment_subtotal?,
                    payment_total: value.payment_total?,
                    purchase_amount: value.purchase_amount?,
                    purchase_currency: value.purchase_currency?,
                })
            }
        }
        impl ::std::convert::From<super::OnrampQuote> for OnrampQuote {
            fn from(value: super::OnrampQuote) -> Self {
                Self {
                    destination_network: Ok(value.destination_network),
                    exchange_rate: Ok(value.exchange_rate),
                    fees: Ok(value.fees),
                    payment_currency: Ok(value.payment_currency),
                    payment_subtotal: Ok(value.payment_subtotal),
                    payment_total: Ok(value.payment_total),
                    purchase_amount: Ok(value.purchase_amount),
                    purchase_currency: Ok(value.purchase_currency),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OnrampSession {
            onramp_url: ::std::result::Result<super::Url, ::std::string::String>,
        }
        impl ::std::default::Default for OnrampSession {
            fn default() -> Self {
                Self {
                    onramp_url: Err("no value supplied for onramp_url".to_string()),
                }
            }
        }
        impl OnrampSession {
            pub fn onramp_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Url>,
                T::Error: ::std::fmt::Display,
            {
                self.onramp_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for onramp_url: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<OnrampSession> for super::OnrampSession {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OnrampSession,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    onramp_url: value.onramp_url?,
                })
            }
        }
        impl ::std::convert::From<super::OnrampSession> for OnrampSession {
            fn from(value: super::OnrampSession) -> Self {
                Self {
                    onramp_url: Ok(value.onramp_url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Policy {
            created_at: ::std::result::Result<::std::string::String, ::std::string::String>,
            description: ::std::result::Result<
                ::std::option::Option<super::PolicyDescription>,
                ::std::string::String,
            >,
            id: ::std::result::Result<super::PolicyId, ::std::string::String>,
            rules: ::std::result::Result<::std::vec::Vec<super::Rule>, ::std::string::String>,
            scope: ::std::result::Result<super::PolicyScope, ::std::string::String>,
            updated_at: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for Policy {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    description: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    rules: Err("no value supplied for rules".to_string()),
                    scope: Err("no value supplied for scope".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl Policy {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::PolicyDescription>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PolicyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn rules<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Rule>>,
                T::Error: ::std::fmt::Display,
            {
                self.rules = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rules: {}", e));
                self
            }
            pub fn scope<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PolicyScope>,
                T::Error: ::std::fmt::Display,
            {
                self.scope = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scope: {}", e));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<Policy> for super::Policy {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Policy,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    description: value.description?,
                    id: value.id?,
                    rules: value.rules?,
                    scope: value.scope?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::Policy> for Policy {
            fn from(value: super::Policy) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    description: Ok(value.description),
                    id: Ok(value.id),
                    rules: Ok(value.rules),
                    scope: Ok(value.scope),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PrepareAndSendUserOperationBody {
            calls: ::std::result::Result<::std::vec::Vec<super::EvmCall>, ::std::string::String>,
            network: ::std::result::Result<super::EvmUserOperationNetwork, ::std::string::String>,
            paymaster_url:
                ::std::result::Result<::std::option::Option<super::Url>, ::std::string::String>,
        }
        impl ::std::default::Default for PrepareAndSendUserOperationBody {
            fn default() -> Self {
                Self {
                    calls: Err("no value supplied for calls".to_string()),
                    network: Err("no value supplied for network".to_string()),
                    paymaster_url: Ok(Default::default()),
                }
            }
        }
        impl PrepareAndSendUserOperationBody {
            pub fn calls<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EvmCall>>,
                T::Error: ::std::fmt::Display,
            {
                self.calls = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for calls: {}", e));
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmUserOperationNetwork>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn paymaster_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Url>>,
                T::Error: ::std::fmt::Display,
            {
                self.paymaster_url = value.try_into().map_err(|e| {
                    format!("error converting supplied value for paymaster_url: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<PrepareAndSendUserOperationBody>
            for super::PrepareAndSendUserOperationBody
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PrepareAndSendUserOperationBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    calls: value.calls?,
                    network: value.network?,
                    paymaster_url: value.paymaster_url?,
                })
            }
        }
        impl ::std::convert::From<super::PrepareAndSendUserOperationBody>
            for PrepareAndSendUserOperationBody
        {
            fn from(value: super::PrepareAndSendUserOperationBody) -> Self {
                Self {
                    calls: Ok(value.calls),
                    network: Ok(value.network),
                    paymaster_url: Ok(value.paymaster_url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PrepareUserOperationBody {
            calls: ::std::result::Result<::std::vec::Vec<super::EvmCall>, ::std::string::String>,
            data_suffix: ::std::result::Result<
                ::std::option::Option<super::PrepareUserOperationBodyDataSuffix>,
                ::std::string::String,
            >,
            network: ::std::result::Result<super::EvmUserOperationNetwork, ::std::string::String>,
            paymaster_url:
                ::std::result::Result<::std::option::Option<super::Url>, ::std::string::String>,
        }
        impl ::std::default::Default for PrepareUserOperationBody {
            fn default() -> Self {
                Self {
                    calls: Err("no value supplied for calls".to_string()),
                    data_suffix: Ok(Default::default()),
                    network: Err("no value supplied for network".to_string()),
                    paymaster_url: Ok(Default::default()),
                }
            }
        }
        impl PrepareUserOperationBody {
            pub fn calls<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EvmCall>>,
                T::Error: ::std::fmt::Display,
            {
                self.calls = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for calls: {}", e));
                self
            }
            pub fn data_suffix<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PrepareUserOperationBodyDataSuffix>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.data_suffix = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data_suffix: {}", e));
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EvmUserOperationNetwork>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn paymaster_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Url>>,
                T::Error: ::std::fmt::Display,
            {
                self.paymaster_url = value.try_into().map_err(|e| {
                    format!("error converting supplied value for paymaster_url: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<PrepareUserOperationBody> for super::PrepareUserOperationBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PrepareUserOperationBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    calls: value.calls?,
                    data_suffix: value.data_suffix?,
                    network: value.network?,
                    paymaster_url: value.paymaster_url?,
                })
            }
        }
        impl ::std::convert::From<super::PrepareUserOperationBody> for PrepareUserOperationBody {
            fn from(value: super::PrepareUserOperationBody) -> Self {
                Self {
                    calls: Ok(value.calls),
                    data_suffix: Ok(value.data_suffix),
                    network: Ok(value.network),
                    paymaster_url: Ok(value.paymaster_url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PrepareUserOperationRule {
            action:
                ::std::result::Result<super::PrepareUserOperationRuleAction, ::std::string::String>,
            criteria:
                ::std::result::Result<super::PrepareUserOperationCriteria, ::std::string::String>,
            operation: ::std::result::Result<
                super::PrepareUserOperationRuleOperation,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PrepareUserOperationRule {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    criteria: Err("no value supplied for criteria".to_string()),
                    operation: Err("no value supplied for operation".to_string()),
                }
            }
        }
        impl PrepareUserOperationRule {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PrepareUserOperationRuleAction>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn criteria<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PrepareUserOperationCriteria>,
                T::Error: ::std::fmt::Display,
            {
                self.criteria = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for criteria: {}", e));
                self
            }
            pub fn operation<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PrepareUserOperationRuleOperation>,
                T::Error: ::std::fmt::Display,
            {
                self.operation = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operation: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<PrepareUserOperationRule> for super::PrepareUserOperationRule {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PrepareUserOperationRule,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    criteria: value.criteria?,
                    operation: value.operation?,
                })
            }
        }
        impl ::std::convert::From<super::PrepareUserOperationRule> for PrepareUserOperationRule {
            fn from(value: super::PrepareUserOperationRule) -> Self {
                Self {
                    action: Ok(value.action),
                    criteria: Ok(value.criteria),
                    operation: Ok(value.operation),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgramIdCriterion {
            operator:
                ::std::result::Result<super::ProgramIdCriterionOperator, ::std::string::String>,
            program_ids: ::std::result::Result<
                ::std::vec::Vec<super::ProgramIdCriterionProgramIdsItem>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<super::ProgramIdCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for ProgramIdCriterion {
            fn default() -> Self {
                Self {
                    operator: Err("no value supplied for operator".to_string()),
                    program_ids: Err("no value supplied for program_ids".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl ProgramIdCriterion {
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ProgramIdCriterionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn program_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::ProgramIdCriterionProgramIdsItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.program_ids = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for program_ids: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ProgramIdCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<ProgramIdCriterion> for super::ProgramIdCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgramIdCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    operator: value.operator?,
                    program_ids: value.program_ids?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::ProgramIdCriterion> for ProgramIdCriterion {
            fn from(value: super::ProgramIdCriterion) -> Self {
                Self {
                    operator: Ok(value.operator),
                    program_ids: Ok(value.program_ids),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct QueryResultCacheConfiguration {
            max_age_ms: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for QueryResultCacheConfiguration {
            fn default() -> Self {
                Self {
                    max_age_ms: Ok(super::defaults::default_u64::<i64, 500>()),
                }
            }
        }
        impl QueryResultCacheConfiguration {
            pub fn max_age_ms<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.max_age_ms = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max_age_ms: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<QueryResultCacheConfiguration>
            for super::QueryResultCacheConfiguration
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: QueryResultCacheConfiguration,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    max_age_ms: value.max_age_ms?,
                })
            }
        }
        impl ::std::convert::From<super::QueryResultCacheConfiguration> for QueryResultCacheConfiguration {
            fn from(value: super::QueryResultCacheConfiguration) -> Self {
                Self {
                    max_age_ms: Ok(value.max_age_ms),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RequestEvmFaucetBody {
            address:
                ::std::result::Result<super::RequestEvmFaucetBodyAddress, ::std::string::String>,
            network:
                ::std::result::Result<super::RequestEvmFaucetBodyNetwork, ::std::string::String>,
            token: ::std::result::Result<super::RequestEvmFaucetBodyToken, ::std::string::String>,
        }
        impl ::std::default::Default for RequestEvmFaucetBody {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    network: Err("no value supplied for network".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }
        impl RequestEvmFaucetBody {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RequestEvmFaucetBodyAddress>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RequestEvmFaucetBodyNetwork>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RequestEvmFaucetBodyToken>,
                T::Error: ::std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<RequestEvmFaucetBody> for super::RequestEvmFaucetBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RequestEvmFaucetBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    network: value.network?,
                    token: value.token?,
                })
            }
        }
        impl ::std::convert::From<super::RequestEvmFaucetBody> for RequestEvmFaucetBody {
            fn from(value: super::RequestEvmFaucetBody) -> Self {
                Self {
                    address: Ok(value.address),
                    network: Ok(value.network),
                    token: Ok(value.token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RequestEvmFaucetResponse {
            transaction_hash: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for RequestEvmFaucetResponse {
            fn default() -> Self {
                Self {
                    transaction_hash: Err("no value supplied for transaction_hash".to_string()),
                }
            }
        }
        impl RequestEvmFaucetResponse {
            pub fn transaction_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction_hash = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for transaction_hash: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<RequestEvmFaucetResponse> for super::RequestEvmFaucetResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RequestEvmFaucetResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    transaction_hash: value.transaction_hash?,
                })
            }
        }
        impl ::std::convert::From<super::RequestEvmFaucetResponse> for RequestEvmFaucetResponse {
            fn from(value: super::RequestEvmFaucetResponse) -> Self {
                Self {
                    transaction_hash: Ok(value.transaction_hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RequestSolanaFaucetBody {
            address:
                ::std::result::Result<super::RequestSolanaFaucetBodyAddress, ::std::string::String>,
            token:
                ::std::result::Result<super::RequestSolanaFaucetBodyToken, ::std::string::String>,
        }
        impl ::std::default::Default for RequestSolanaFaucetBody {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }
        impl RequestSolanaFaucetBody {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RequestSolanaFaucetBodyAddress>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RequestSolanaFaucetBodyToken>,
                T::Error: ::std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<RequestSolanaFaucetBody> for super::RequestSolanaFaucetBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RequestSolanaFaucetBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    token: value.token?,
                })
            }
        }
        impl ::std::convert::From<super::RequestSolanaFaucetBody> for RequestSolanaFaucetBody {
            fn from(value: super::RequestSolanaFaucetBody) -> Self {
                Self {
                    address: Ok(value.address),
                    token: Ok(value.token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RequestSolanaFaucetResponse {
            transaction_signature:
                ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for RequestSolanaFaucetResponse {
            fn default() -> Self {
                Self {
                    transaction_signature: Err(
                        "no value supplied for transaction_signature".to_string()
                    ),
                }
            }
        }
        impl RequestSolanaFaucetResponse {
            pub fn transaction_signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction_signature = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for transaction_signature: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<RequestSolanaFaucetResponse> for super::RequestSolanaFaucetResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RequestSolanaFaucetResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    transaction_signature: value.transaction_signature?,
                })
            }
        }
        impl ::std::convert::From<super::RequestSolanaFaucetResponse> for RequestSolanaFaucetResponse {
            fn from(value: super::RequestSolanaFaucetResponse) -> Self {
                Self {
                    transaction_signature: Ok(value.transaction_signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RevokeSpendPermissionRequest {
            network: ::std::result::Result<super::SpendPermissionNetwork, ::std::string::String>,
            paymaster_url:
                ::std::result::Result<::std::option::Option<super::Url>, ::std::string::String>,
            permission_hash: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for RevokeSpendPermissionRequest {
            fn default() -> Self {
                Self {
                    network: Err("no value supplied for network".to_string()),
                    paymaster_url: Ok(Default::default()),
                    permission_hash: Err("no value supplied for permission_hash".to_string()),
                }
            }
        }
        impl RevokeSpendPermissionRequest {
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SpendPermissionNetwork>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn paymaster_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Url>>,
                T::Error: ::std::fmt::Display,
            {
                self.paymaster_url = value.try_into().map_err(|e| {
                    format!("error converting supplied value for paymaster_url: {}", e)
                });
                self
            }
            pub fn permission_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.permission_hash = value.try_into().map_err(|e| {
                    format!("error converting supplied value for permission_hash: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<RevokeSpendPermissionRequest> for super::RevokeSpendPermissionRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RevokeSpendPermissionRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    network: value.network?,
                    paymaster_url: value.paymaster_url?,
                    permission_hash: value.permission_hash?,
                })
            }
        }
        impl ::std::convert::From<super::RevokeSpendPermissionRequest> for RevokeSpendPermissionRequest {
            fn from(value: super::RevokeSpendPermissionRequest) -> Self {
                Self {
                    network: Ok(value.network),
                    paymaster_url: Ok(value.paymaster_url),
                    permission_hash: Ok(value.permission_hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SendEvmTransactionBody {
            network:
                ::std::result::Result<super::SendEvmTransactionBodyNetwork, ::std::string::String>,
            transaction: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SendEvmTransactionBody {
            fn default() -> Self {
                Self {
                    network: Err("no value supplied for network".to_string()),
                    transaction: Err("no value supplied for transaction".to_string()),
                }
            }
        }
        impl SendEvmTransactionBody {
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SendEvmTransactionBodyNetwork>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for transaction: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SendEvmTransactionBody> for super::SendEvmTransactionBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SendEvmTransactionBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    network: value.network?,
                    transaction: value.transaction?,
                })
            }
        }
        impl ::std::convert::From<super::SendEvmTransactionBody> for SendEvmTransactionBody {
            fn from(value: super::SendEvmTransactionBody) -> Self {
                Self {
                    network: Ok(value.network),
                    transaction: Ok(value.transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SendEvmTransactionResponse {
            transaction_hash: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SendEvmTransactionResponse {
            fn default() -> Self {
                Self {
                    transaction_hash: Err("no value supplied for transaction_hash".to_string()),
                }
            }
        }
        impl SendEvmTransactionResponse {
            pub fn transaction_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction_hash = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for transaction_hash: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<SendEvmTransactionResponse> for super::SendEvmTransactionResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SendEvmTransactionResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    transaction_hash: value.transaction_hash?,
                })
            }
        }
        impl ::std::convert::From<super::SendEvmTransactionResponse> for SendEvmTransactionResponse {
            fn from(value: super::SendEvmTransactionResponse) -> Self {
                Self {
                    transaction_hash: Ok(value.transaction_hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SendEvmTransactionRule {
            action:
                ::std::result::Result<super::SendEvmTransactionRuleAction, ::std::string::String>,
            criteria:
                ::std::result::Result<super::SendEvmTransactionCriteria, ::std::string::String>,
            operation: ::std::result::Result<
                super::SendEvmTransactionRuleOperation,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SendEvmTransactionRule {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    criteria: Err("no value supplied for criteria".to_string()),
                    operation: Err("no value supplied for operation".to_string()),
                }
            }
        }
        impl SendEvmTransactionRule {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SendEvmTransactionRuleAction>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn criteria<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SendEvmTransactionCriteria>,
                T::Error: ::std::fmt::Display,
            {
                self.criteria = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for criteria: {}", e));
                self
            }
            pub fn operation<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SendEvmTransactionRuleOperation>,
                T::Error: ::std::fmt::Display,
            {
                self.operation = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operation: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SendEvmTransactionRule> for super::SendEvmTransactionRule {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SendEvmTransactionRule,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    criteria: value.criteria?,
                    operation: value.operation?,
                })
            }
        }
        impl ::std::convert::From<super::SendEvmTransactionRule> for SendEvmTransactionRule {
            fn from(value: super::SendEvmTransactionRule) -> Self {
                Self {
                    action: Ok(value.action),
                    criteria: Ok(value.criteria),
                    operation: Ok(value.operation),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SendSolTransactionRule {
            action:
                ::std::result::Result<super::SendSolTransactionRuleAction, ::std::string::String>,
            criteria:
                ::std::result::Result<super::SendSolTransactionCriteria, ::std::string::String>,
            operation: ::std::result::Result<
                super::SendSolTransactionRuleOperation,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SendSolTransactionRule {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    criteria: Err("no value supplied for criteria".to_string()),
                    operation: Err("no value supplied for operation".to_string()),
                }
            }
        }
        impl SendSolTransactionRule {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SendSolTransactionRuleAction>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn criteria<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SendSolTransactionCriteria>,
                T::Error: ::std::fmt::Display,
            {
                self.criteria = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for criteria: {}", e));
                self
            }
            pub fn operation<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SendSolTransactionRuleOperation>,
                T::Error: ::std::fmt::Display,
            {
                self.operation = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operation: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SendSolTransactionRule> for super::SendSolTransactionRule {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SendSolTransactionRule,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    criteria: value.criteria?,
                    operation: value.operation?,
                })
            }
        }
        impl ::std::convert::From<super::SendSolTransactionRule> for SendSolTransactionRule {
            fn from(value: super::SendSolTransactionRule) -> Self {
                Self {
                    action: Ok(value.action),
                    criteria: Ok(value.criteria),
                    operation: Ok(value.operation),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SendSolanaTransactionBody {
            network: ::std::result::Result<
                super::SendSolanaTransactionBodyNetwork,
                ::std::string::String,
            >,
            transaction: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SendSolanaTransactionBody {
            fn default() -> Self {
                Self {
                    network: Err("no value supplied for network".to_string()),
                    transaction: Err("no value supplied for transaction".to_string()),
                }
            }
        }
        impl SendSolanaTransactionBody {
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SendSolanaTransactionBodyNetwork>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for transaction: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SendSolanaTransactionBody> for super::SendSolanaTransactionBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SendSolanaTransactionBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    network: value.network?,
                    transaction: value.transaction?,
                })
            }
        }
        impl ::std::convert::From<super::SendSolanaTransactionBody> for SendSolanaTransactionBody {
            fn from(value: super::SendSolanaTransactionBody) -> Self {
                Self {
                    network: Ok(value.network),
                    transaction: Ok(value.transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SendSolanaTransactionResponse {
            transaction_signature:
                ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SendSolanaTransactionResponse {
            fn default() -> Self {
                Self {
                    transaction_signature: Err(
                        "no value supplied for transaction_signature".to_string()
                    ),
                }
            }
        }
        impl SendSolanaTransactionResponse {
            pub fn transaction_signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction_signature = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for transaction_signature: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<SendSolanaTransactionResponse>
            for super::SendSolanaTransactionResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SendSolanaTransactionResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    transaction_signature: value.transaction_signature?,
                })
            }
        }
        impl ::std::convert::From<super::SendSolanaTransactionResponse> for SendSolanaTransactionResponse {
            fn from(value: super::SendSolanaTransactionResponse) -> Self {
                Self {
                    transaction_signature: Ok(value.transaction_signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SendUserOperationBody {
            signature: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SendUserOperationBody {
            fn default() -> Self {
                Self {
                    signature: Err("no value supplied for signature".to_string()),
                }
            }
        }
        impl SendUserOperationBody {
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signature: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SendUserOperationBody> for super::SendUserOperationBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SendUserOperationBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    signature: value.signature?,
                })
            }
        }
        impl ::std::convert::From<super::SendUserOperationBody> for SendUserOperationBody {
            fn from(value: super::SendUserOperationBody) -> Self {
                Self {
                    signature: Ok(value.signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SendUserOperationRule {
            action:
                ::std::result::Result<super::SendUserOperationRuleAction, ::std::string::String>,
            criteria:
                ::std::result::Result<super::SendUserOperationCriteria, ::std::string::String>,
            operation:
                ::std::result::Result<super::SendUserOperationRuleOperation, ::std::string::String>,
        }
        impl ::std::default::Default for SendUserOperationRule {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    criteria: Err("no value supplied for criteria".to_string()),
                    operation: Err("no value supplied for operation".to_string()),
                }
            }
        }
        impl SendUserOperationRule {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SendUserOperationRuleAction>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn criteria<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SendUserOperationCriteria>,
                T::Error: ::std::fmt::Display,
            {
                self.criteria = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for criteria: {}", e));
                self
            }
            pub fn operation<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SendUserOperationRuleOperation>,
                T::Error: ::std::fmt::Display,
            {
                self.operation = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operation: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SendUserOperationRule> for super::SendUserOperationRule {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SendUserOperationRule,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    criteria: value.criteria?,
                    operation: value.operation?,
                })
            }
        }
        impl ::std::convert::From<super::SendUserOperationRule> for SendUserOperationRule {
            fn from(value: super::SendUserOperationRule) -> Self {
                Self {
                    action: Ok(value.action),
                    criteria: Ok(value.criteria),
                    operation: Ok(value.operation),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SettleX402PaymentBody {
            payment_payload:
                ::std::result::Result<super::X402PaymentPayload, ::std::string::String>,
            payment_requirements:
                ::std::result::Result<super::X402PaymentRequirements, ::std::string::String>,
            x402_version: ::std::result::Result<super::X402Version, ::std::string::String>,
        }
        impl ::std::default::Default for SettleX402PaymentBody {
            fn default() -> Self {
                Self {
                    payment_payload: Err("no value supplied for payment_payload".to_string()),
                    payment_requirements: Err(
                        "no value supplied for payment_requirements".to_string()
                    ),
                    x402_version: Err("no value supplied for x402_version".to_string()),
                }
            }
        }
        impl SettleX402PaymentBody {
            pub fn payment_payload<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402PaymentPayload>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_payload = value.try_into().map_err(|e| {
                    format!("error converting supplied value for payment_payload: {}", e)
                });
                self
            }
            pub fn payment_requirements<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402PaymentRequirements>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_requirements = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for payment_requirements: {}",
                        e
                    )
                });
                self
            }
            pub fn x402_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402Version>,
                T::Error: ::std::fmt::Display,
            {
                self.x402_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for x402_version: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<SettleX402PaymentBody> for super::SettleX402PaymentBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SettleX402PaymentBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    payment_payload: value.payment_payload?,
                    payment_requirements: value.payment_requirements?,
                    x402_version: value.x402_version?,
                })
            }
        }
        impl ::std::convert::From<super::SettleX402PaymentBody> for SettleX402PaymentBody {
            fn from(value: super::SettleX402PaymentBody) -> Self {
                Self {
                    payment_payload: Ok(value.payment_payload),
                    payment_requirements: Ok(value.payment_requirements),
                    x402_version: Ok(value.x402_version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SettleX402PaymentResponse {
            error_reason: ::std::result::Result<
                ::std::option::Option<super::X402SettleErrorReason>,
                ::std::string::String,
            >,
            network: ::std::result::Result<::std::string::String, ::std::string::String>,
            payer:
                ::std::result::Result<super::SettleX402PaymentResponsePayer, ::std::string::String>,
            success: ::std::result::Result<bool, ::std::string::String>,
            transaction: ::std::result::Result<
                super::SettleX402PaymentResponseTransaction,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SettleX402PaymentResponse {
            fn default() -> Self {
                Self {
                    error_reason: Ok(Default::default()),
                    network: Err("no value supplied for network".to_string()),
                    payer: Err("no value supplied for payer".to_string()),
                    success: Err("no value supplied for success".to_string()),
                    transaction: Err("no value supplied for transaction".to_string()),
                }
            }
        }
        impl SettleX402PaymentResponse {
            pub fn error_reason<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::X402SettleErrorReason>>,
                T::Error: ::std::fmt::Display,
            {
                self.error_reason = value.try_into().map_err(|e| {
                    format!("error converting supplied value for error_reason: {}", e)
                });
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn payer<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SettleX402PaymentResponsePayer>,
                T::Error: ::std::fmt::Display,
            {
                self.payer = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for payer: {}", e));
                self
            }
            pub fn success<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.success = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for success: {}", e));
                self
            }
            pub fn transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SettleX402PaymentResponseTransaction>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for transaction: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SettleX402PaymentResponse> for super::SettleX402PaymentResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SettleX402PaymentResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error_reason: value.error_reason?,
                    network: value.network?,
                    payer: value.payer?,
                    success: value.success?,
                    transaction: value.transaction?,
                })
            }
        }
        impl ::std::convert::From<super::SettleX402PaymentResponse> for SettleX402PaymentResponse {
            fn from(value: super::SettleX402PaymentResponse) -> Self {
                Self {
                    error_reason: Ok(value.error_reason),
                    network: Ok(value.network),
                    payer: Ok(value.payer),
                    success: Ok(value.success),
                    transaction: Ok(value.transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmHashBody {
            hash: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SignEvmHashBody {
            fn default() -> Self {
                Self {
                    hash: Err("no value supplied for hash".to_string()),
                }
            }
        }
        impl SignEvmHashBody {
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hash: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmHashBody> for super::SignEvmHashBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmHashBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { hash: value.hash? })
            }
        }
        impl ::std::convert::From<super::SignEvmHashBody> for SignEvmHashBody {
            fn from(value: super::SignEvmHashBody) -> Self {
                Self {
                    hash: Ok(value.hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmHashResponse {
            signature: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SignEvmHashResponse {
            fn default() -> Self {
                Self {
                    signature: Err("no value supplied for signature".to_string()),
                }
            }
        }
        impl SignEvmHashResponse {
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signature: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmHashResponse> for super::SignEvmHashResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmHashResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    signature: value.signature?,
                })
            }
        }
        impl ::std::convert::From<super::SignEvmHashResponse> for SignEvmHashResponse {
            fn from(value: super::SignEvmHashResponse) -> Self {
                Self {
                    signature: Ok(value.signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmHashRule {
            action: ::std::result::Result<super::SignEvmHashRuleAction, ::std::string::String>,
            operation:
                ::std::result::Result<super::SignEvmHashRuleOperation, ::std::string::String>,
        }
        impl ::std::default::Default for SignEvmHashRule {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    operation: Err("no value supplied for operation".to_string()),
                }
            }
        }
        impl SignEvmHashRule {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignEvmHashRuleAction>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn operation<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignEvmHashRuleOperation>,
                T::Error: ::std::fmt::Display,
            {
                self.operation = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operation: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmHashRule> for super::SignEvmHashRule {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmHashRule,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    operation: value.operation?,
                })
            }
        }
        impl ::std::convert::From<super::SignEvmHashRule> for SignEvmHashRule {
            fn from(value: super::SignEvmHashRule) -> Self {
                Self {
                    action: Ok(value.action),
                    operation: Ok(value.operation),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmMessageBody {
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SignEvmMessageBody {
            fn default() -> Self {
                Self {
                    message: Err("no value supplied for message".to_string()),
                }
            }
        }
        impl SignEvmMessageBody {
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmMessageBody> for super::SignEvmMessageBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmMessageBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::SignEvmMessageBody> for SignEvmMessageBody {
            fn from(value: super::SignEvmMessageBody) -> Self {
                Self {
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmMessageResponse {
            signature: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SignEvmMessageResponse {
            fn default() -> Self {
                Self {
                    signature: Err("no value supplied for signature".to_string()),
                }
            }
        }
        impl SignEvmMessageResponse {
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signature: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmMessageResponse> for super::SignEvmMessageResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmMessageResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    signature: value.signature?,
                })
            }
        }
        impl ::std::convert::From<super::SignEvmMessageResponse> for SignEvmMessageResponse {
            fn from(value: super::SignEvmMessageResponse) -> Self {
                Self {
                    signature: Ok(value.signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmMessageRule {
            action: ::std::result::Result<super::SignEvmMessageRuleAction, ::std::string::String>,
            criteria: ::std::result::Result<super::SignEvmMessageCriteria, ::std::string::String>,
            operation:
                ::std::result::Result<super::SignEvmMessageRuleOperation, ::std::string::String>,
        }
        impl ::std::default::Default for SignEvmMessageRule {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    criteria: Err("no value supplied for criteria".to_string()),
                    operation: Err("no value supplied for operation".to_string()),
                }
            }
        }
        impl SignEvmMessageRule {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignEvmMessageRuleAction>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn criteria<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignEvmMessageCriteria>,
                T::Error: ::std::fmt::Display,
            {
                self.criteria = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for criteria: {}", e));
                self
            }
            pub fn operation<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignEvmMessageRuleOperation>,
                T::Error: ::std::fmt::Display,
            {
                self.operation = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operation: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmMessageRule> for super::SignEvmMessageRule {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmMessageRule,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    criteria: value.criteria?,
                    operation: value.operation?,
                })
            }
        }
        impl ::std::convert::From<super::SignEvmMessageRule> for SignEvmMessageRule {
            fn from(value: super::SignEvmMessageRule) -> Self {
                Self {
                    action: Ok(value.action),
                    criteria: Ok(value.criteria),
                    operation: Ok(value.operation),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmTransactionBody {
            transaction: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SignEvmTransactionBody {
            fn default() -> Self {
                Self {
                    transaction: Err("no value supplied for transaction".to_string()),
                }
            }
        }
        impl SignEvmTransactionBody {
            pub fn transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for transaction: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmTransactionBody> for super::SignEvmTransactionBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmTransactionBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    transaction: value.transaction?,
                })
            }
        }
        impl ::std::convert::From<super::SignEvmTransactionBody> for SignEvmTransactionBody {
            fn from(value: super::SignEvmTransactionBody) -> Self {
                Self {
                    transaction: Ok(value.transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmTransactionResponse {
            signed_transaction: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SignEvmTransactionResponse {
            fn default() -> Self {
                Self {
                    signed_transaction: Err("no value supplied for signed_transaction".to_string()),
                }
            }
        }
        impl SignEvmTransactionResponse {
            pub fn signed_transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signed_transaction = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for signed_transaction: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmTransactionResponse> for super::SignEvmTransactionResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmTransactionResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    signed_transaction: value.signed_transaction?,
                })
            }
        }
        impl ::std::convert::From<super::SignEvmTransactionResponse> for SignEvmTransactionResponse {
            fn from(value: super::SignEvmTransactionResponse) -> Self {
                Self {
                    signed_transaction: Ok(value.signed_transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmTransactionRule {
            action:
                ::std::result::Result<super::SignEvmTransactionRuleAction, ::std::string::String>,
            criteria:
                ::std::result::Result<super::SignEvmTransactionCriteria, ::std::string::String>,
            operation: ::std::result::Result<
                super::SignEvmTransactionRuleOperation,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SignEvmTransactionRule {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    criteria: Err("no value supplied for criteria".to_string()),
                    operation: Err("no value supplied for operation".to_string()),
                }
            }
        }
        impl SignEvmTransactionRule {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignEvmTransactionRuleAction>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn criteria<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignEvmTransactionCriteria>,
                T::Error: ::std::fmt::Display,
            {
                self.criteria = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for criteria: {}", e));
                self
            }
            pub fn operation<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignEvmTransactionRuleOperation>,
                T::Error: ::std::fmt::Display,
            {
                self.operation = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operation: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmTransactionRule> for super::SignEvmTransactionRule {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmTransactionRule,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    criteria: value.criteria?,
                    operation: value.operation?,
                })
            }
        }
        impl ::std::convert::From<super::SignEvmTransactionRule> for SignEvmTransactionRule {
            fn from(value: super::SignEvmTransactionRule) -> Self {
                Self {
                    action: Ok(value.action),
                    criteria: Ok(value.criteria),
                    operation: Ok(value.operation),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmTypedDataFieldCriterion {
            conditions: ::std::result::Result<
                ::std::vec::Vec<super::SignEvmTypedDataFieldCriterionConditionsItem>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                super::SignEvmTypedDataFieldCriterionType,
                ::std::string::String,
            >,
            types: ::std::result::Result<
                super::SignEvmTypedDataFieldCriterionTypes,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SignEvmTypedDataFieldCriterion {
            fn default() -> Self {
                Self {
                    conditions: Err("no value supplied for conditions".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    types: Err("no value supplied for types".to_string()),
                }
            }
        }
        impl SignEvmTypedDataFieldCriterion {
            pub fn conditions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::SignEvmTypedDataFieldCriterionConditionsItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.conditions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for conditions: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignEvmTypedDataFieldCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn types<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignEvmTypedDataFieldCriterionTypes>,
                T::Error: ::std::fmt::Display,
            {
                self.types = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for types: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmTypedDataFieldCriterion>
            for super::SignEvmTypedDataFieldCriterion
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmTypedDataFieldCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    conditions: value.conditions?,
                    type_: value.type_?,
                    types: value.types?,
                })
            }
        }
        impl ::std::convert::From<super::SignEvmTypedDataFieldCriterion>
            for SignEvmTypedDataFieldCriterion
        {
            fn from(value: super::SignEvmTypedDataFieldCriterion) -> Self {
                Self {
                    conditions: Ok(value.conditions),
                    type_: Ok(value.type_),
                    types: Ok(value.types),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmTypedDataFieldCriterionTypes {
            primary_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            types: ::std::result::Result<
                ::std::collections::HashMap<
                    ::std::string::String,
                    ::std::vec::Vec<super::SignEvmTypedDataFieldCriterionTypesTypesValueItem>,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SignEvmTypedDataFieldCriterionTypes {
            fn default() -> Self {
                Self {
                    primary_type: Err("no value supplied for primary_type".to_string()),
                    types: Err("no value supplied for types".to_string()),
                }
            }
        }
        impl SignEvmTypedDataFieldCriterionTypes {
            pub fn primary_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.primary_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for primary_type: {}", e)
                });
                self
            }
            pub fn types<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<
                        ::std::string::String,
                        ::std::vec::Vec<super::SignEvmTypedDataFieldCriterionTypesTypesValueItem>,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.types = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for types: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmTypedDataFieldCriterionTypes>
            for super::SignEvmTypedDataFieldCriterionTypes
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmTypedDataFieldCriterionTypes,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    primary_type: value.primary_type?,
                    types: value.types?,
                })
            }
        }
        impl ::std::convert::From<super::SignEvmTypedDataFieldCriterionTypes>
            for SignEvmTypedDataFieldCriterionTypes
        {
            fn from(value: super::SignEvmTypedDataFieldCriterionTypes) -> Self {
                Self {
                    primary_type: Ok(value.primary_type),
                    types: Ok(value.types),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmTypedDataFieldCriterionTypesTypesValueItem {
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SignEvmTypedDataFieldCriterionTypesTypesValueItem {
            fn default() -> Self {
                Self {
                    name: Ok(Default::default()),
                    type_: Ok(Default::default()),
                }
            }
        }
        impl SignEvmTypedDataFieldCriterionTypesTypesValueItem {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmTypedDataFieldCriterionTypesTypesValueItem>
            for super::SignEvmTypedDataFieldCriterionTypesTypesValueItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmTypedDataFieldCriterionTypesTypesValueItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::SignEvmTypedDataFieldCriterionTypesTypesValueItem>
            for SignEvmTypedDataFieldCriterionTypesTypesValueItem
        {
            fn from(value: super::SignEvmTypedDataFieldCriterionTypesTypesValueItem) -> Self {
                Self {
                    name: Ok(value.name),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmTypedDataResponse {
            signature: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SignEvmTypedDataResponse {
            fn default() -> Self {
                Self {
                    signature: Err("no value supplied for signature".to_string()),
                }
            }
        }
        impl SignEvmTypedDataResponse {
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signature: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmTypedDataResponse> for super::SignEvmTypedDataResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmTypedDataResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    signature: value.signature?,
                })
            }
        }
        impl ::std::convert::From<super::SignEvmTypedDataResponse> for SignEvmTypedDataResponse {
            fn from(value: super::SignEvmTypedDataResponse) -> Self {
                Self {
                    signature: Ok(value.signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmTypedDataRule {
            action: ::std::result::Result<super::SignEvmTypedDataRuleAction, ::std::string::String>,
            criteria: ::std::result::Result<super::SignEvmTypedDataCriteria, ::std::string::String>,
            operation:
                ::std::result::Result<super::SignEvmTypedDataRuleOperation, ::std::string::String>,
        }
        impl ::std::default::Default for SignEvmTypedDataRule {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    criteria: Err("no value supplied for criteria".to_string()),
                    operation: Err("no value supplied for operation".to_string()),
                }
            }
        }
        impl SignEvmTypedDataRule {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignEvmTypedDataRuleAction>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn criteria<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignEvmTypedDataCriteria>,
                T::Error: ::std::fmt::Display,
            {
                self.criteria = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for criteria: {}", e));
                self
            }
            pub fn operation<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignEvmTypedDataRuleOperation>,
                T::Error: ::std::fmt::Display,
            {
                self.operation = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operation: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmTypedDataRule> for super::SignEvmTypedDataRule {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmTypedDataRule,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    criteria: value.criteria?,
                    operation: value.operation?,
                })
            }
        }
        impl ::std::convert::From<super::SignEvmTypedDataRule> for SignEvmTypedDataRule {
            fn from(value: super::SignEvmTypedDataRule) -> Self {
                Self {
                    action: Ok(value.action),
                    criteria: Ok(value.criteria),
                    operation: Ok(value.operation),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignEvmTypedDataVerifyingContractCriterion {
            addresses: ::std::result::Result<
                ::std::vec::Vec<super::SignEvmTypedDataVerifyingContractCriterionAddressesItem>,
                ::std::string::String,
            >,
            operator: ::std::result::Result<
                super::SignEvmTypedDataVerifyingContractCriterionOperator,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                super::SignEvmTypedDataVerifyingContractCriterionType,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SignEvmTypedDataVerifyingContractCriterion {
            fn default() -> Self {
                Self {
                    addresses: Err("no value supplied for addresses".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl SignEvmTypedDataVerifyingContractCriterion {
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::SignEvmTypedDataVerifyingContractCriterionAddressesItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for addresses: {}", e));
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::SignEvmTypedDataVerifyingContractCriterionOperator,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignEvmTypedDataVerifyingContractCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignEvmTypedDataVerifyingContractCriterion>
            for super::SignEvmTypedDataVerifyingContractCriterion
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignEvmTypedDataVerifyingContractCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addresses: value.addresses?,
                    operator: value.operator?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::SignEvmTypedDataVerifyingContractCriterion>
            for SignEvmTypedDataVerifyingContractCriterion
        {
            fn from(value: super::SignEvmTypedDataVerifyingContractCriterion) -> Self {
                Self {
                    addresses: Ok(value.addresses),
                    operator: Ok(value.operator),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignSolMessageRule {
            action: ::std::result::Result<super::SignSolMessageRuleAction, ::std::string::String>,
            criteria: ::std::result::Result<super::SignSolMessageCriteria, ::std::string::String>,
            operation:
                ::std::result::Result<super::SignSolMessageRuleOperation, ::std::string::String>,
        }
        impl ::std::default::Default for SignSolMessageRule {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    criteria: Err("no value supplied for criteria".to_string()),
                    operation: Err("no value supplied for operation".to_string()),
                }
            }
        }
        impl SignSolMessageRule {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignSolMessageRuleAction>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn criteria<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignSolMessageCriteria>,
                T::Error: ::std::fmt::Display,
            {
                self.criteria = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for criteria: {}", e));
                self
            }
            pub fn operation<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignSolMessageRuleOperation>,
                T::Error: ::std::fmt::Display,
            {
                self.operation = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operation: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignSolMessageRule> for super::SignSolMessageRule {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignSolMessageRule,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    criteria: value.criteria?,
                    operation: value.operation?,
                })
            }
        }
        impl ::std::convert::From<super::SignSolMessageRule> for SignSolMessageRule {
            fn from(value: super::SignSolMessageRule) -> Self {
                Self {
                    action: Ok(value.action),
                    criteria: Ok(value.criteria),
                    operation: Ok(value.operation),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignSolTransactionRule {
            action:
                ::std::result::Result<super::SignSolTransactionRuleAction, ::std::string::String>,
            criteria:
                ::std::result::Result<super::SignSolTransactionCriteria, ::std::string::String>,
            operation: ::std::result::Result<
                super::SignSolTransactionRuleOperation,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SignSolTransactionRule {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    criteria: Err("no value supplied for criteria".to_string()),
                    operation: Err("no value supplied for operation".to_string()),
                }
            }
        }
        impl SignSolTransactionRule {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignSolTransactionRuleAction>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn criteria<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignSolTransactionCriteria>,
                T::Error: ::std::fmt::Display,
            {
                self.criteria = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for criteria: {}", e));
                self
            }
            pub fn operation<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignSolTransactionRuleOperation>,
                T::Error: ::std::fmt::Display,
            {
                self.operation = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operation: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignSolTransactionRule> for super::SignSolTransactionRule {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignSolTransactionRule,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    criteria: value.criteria?,
                    operation: value.operation?,
                })
            }
        }
        impl ::std::convert::From<super::SignSolTransactionRule> for SignSolTransactionRule {
            fn from(value: super::SignSolTransactionRule) -> Self {
                Self {
                    action: Ok(value.action),
                    criteria: Ok(value.criteria),
                    operation: Ok(value.operation),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignSolanaMessageBody {
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SignSolanaMessageBody {
            fn default() -> Self {
                Self {
                    message: Err("no value supplied for message".to_string()),
                }
            }
        }
        impl SignSolanaMessageBody {
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignSolanaMessageBody> for super::SignSolanaMessageBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignSolanaMessageBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::SignSolanaMessageBody> for SignSolanaMessageBody {
            fn from(value: super::SignSolanaMessageBody) -> Self {
                Self {
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignSolanaMessageResponse {
            signature: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SignSolanaMessageResponse {
            fn default() -> Self {
                Self {
                    signature: Err("no value supplied for signature".to_string()),
                }
            }
        }
        impl SignSolanaMessageResponse {
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signature: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignSolanaMessageResponse> for super::SignSolanaMessageResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignSolanaMessageResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    signature: value.signature?,
                })
            }
        }
        impl ::std::convert::From<super::SignSolanaMessageResponse> for SignSolanaMessageResponse {
            fn from(value: super::SignSolanaMessageResponse) -> Self {
                Self {
                    signature: Ok(value.signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignSolanaTransactionBody {
            transaction: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SignSolanaTransactionBody {
            fn default() -> Self {
                Self {
                    transaction: Err("no value supplied for transaction".to_string()),
                }
            }
        }
        impl SignSolanaTransactionBody {
            pub fn transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for transaction: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SignSolanaTransactionBody> for super::SignSolanaTransactionBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignSolanaTransactionBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    transaction: value.transaction?,
                })
            }
        }
        impl ::std::convert::From<super::SignSolanaTransactionBody> for SignSolanaTransactionBody {
            fn from(value: super::SignSolanaTransactionBody) -> Self {
                Self {
                    transaction: Ok(value.transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignSolanaTransactionResponse {
            signed_transaction: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SignSolanaTransactionResponse {
            fn default() -> Self {
                Self {
                    signed_transaction: Err("no value supplied for signed_transaction".to_string()),
                }
            }
        }
        impl SignSolanaTransactionResponse {
            pub fn signed_transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signed_transaction = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for signed_transaction: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<SignSolanaTransactionResponse>
            for super::SignSolanaTransactionResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignSolanaTransactionResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    signed_transaction: value.signed_transaction?,
                })
            }
        }
        impl ::std::convert::From<super::SignSolanaTransactionResponse> for SignSolanaTransactionResponse {
            fn from(value: super::SignSolanaTransactionResponse) -> Self {
                Self {
                    signed_transaction: Ok(value.signed_transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SmsAuthentication {
            phone_number:
                ::std::result::Result<super::SmsAuthenticationPhoneNumber, ::std::string::String>,
            type_: ::std::result::Result<super::SmsAuthenticationType, ::std::string::String>,
        }
        impl ::std::default::Default for SmsAuthentication {
            fn default() -> Self {
                Self {
                    phone_number: Err("no value supplied for phone_number".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl SmsAuthentication {
            pub fn phone_number<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SmsAuthenticationPhoneNumber>,
                T::Error: ::std::fmt::Display,
            {
                self.phone_number = value.try_into().map_err(|e| {
                    format!("error converting supplied value for phone_number: {}", e)
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SmsAuthenticationType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SmsAuthentication> for super::SmsAuthentication {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SmsAuthentication,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    phone_number: value.phone_number?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::SmsAuthentication> for SmsAuthentication {
            fn from(value: super::SmsAuthentication) -> Self {
                Self {
                    phone_number: Ok(value.phone_number),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolAddressCriterion {
            addresses: ::std::result::Result<
                ::std::vec::Vec<super::SolAddressCriterionAddressesItem>,
                ::std::string::String,
            >,
            operator:
                ::std::result::Result<super::SolAddressCriterionOperator, ::std::string::String>,
            type_: ::std::result::Result<super::SolAddressCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for SolAddressCriterion {
            fn default() -> Self {
                Self {
                    addresses: Err("no value supplied for addresses".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl SolAddressCriterion {
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::SolAddressCriterionAddressesItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for addresses: {}", e));
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolAddressCriterionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolAddressCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolAddressCriterion> for super::SolAddressCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolAddressCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addresses: value.addresses?,
                    operator: value.operator?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::SolAddressCriterion> for SolAddressCriterion {
            fn from(value: super::SolAddressCriterion) -> Self {
                Self {
                    addresses: Ok(value.addresses),
                    operator: Ok(value.operator),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolDataCondition {
            instruction: ::std::result::Result<::std::string::String, ::std::string::String>,
            params: ::std::result::Result<
                ::std::vec::Vec<super::SolDataConditionParamsItem>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SolDataCondition {
            fn default() -> Self {
                Self {
                    instruction: Err("no value supplied for instruction".to_string()),
                    params: Ok(Default::default()),
                }
            }
        }
        impl SolDataCondition {
            pub fn instruction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.instruction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for instruction: {}", e));
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SolDataConditionParamsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for params: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolDataCondition> for super::SolDataCondition {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolDataCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    instruction: value.instruction?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::SolDataCondition> for SolDataCondition {
            fn from(value: super::SolDataCondition) -> Self {
                Self {
                    instruction: Ok(value.instruction),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolDataCriterion {
            conditions: ::std::result::Result<
                ::std::vec::Vec<super::SolDataCondition>,
                ::std::string::String,
            >,
            idls: ::std::result::Result<
                ::std::vec::Vec<super::SolDataCriterionIdlsItem>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<super::SolDataCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for SolDataCriterion {
            fn default() -> Self {
                Self {
                    conditions: Err("no value supplied for conditions".to_string()),
                    idls: Err("no value supplied for idls".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl SolDataCriterion {
            pub fn conditions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SolDataCondition>>,
                T::Error: ::std::fmt::Display,
            {
                self.conditions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for conditions: {}", e));
                self
            }
            pub fn idls<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SolDataCriterionIdlsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.idls = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for idls: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolDataCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolDataCriterion> for super::SolDataCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolDataCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    conditions: value.conditions?,
                    idls: value.idls?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::SolDataCriterion> for SolDataCriterion {
            fn from(value: super::SolDataCriterion) -> Self {
                Self {
                    conditions: Ok(value.conditions),
                    idls: Ok(value.idls),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolDataParameterCondition {
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            operator: ::std::result::Result<
                super::SolDataParameterConditionOperator,
                ::std::string::String,
            >,
            value: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SolDataParameterCondition {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl SolDataParameterCondition {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolDataParameterConditionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolDataParameterCondition> for super::SolDataParameterCondition {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolDataParameterCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    operator: value.operator?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::SolDataParameterCondition> for SolDataParameterCondition {
            fn from(value: super::SolDataParameterCondition) -> Self {
                Self {
                    name: Ok(value.name),
                    operator: Ok(value.operator),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolDataParameterConditionList {
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            operator: ::std::result::Result<
                super::SolDataParameterConditionListOperator,
                ::std::string::String,
            >,
            values: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SolDataParameterConditionList {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl SolDataParameterConditionList {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolDataParameterConditionListOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for values: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolDataParameterConditionList>
            for super::SolDataParameterConditionList
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolDataParameterConditionList,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    operator: value.operator?,
                    values: value.values?,
                })
            }
        }
        impl ::std::convert::From<super::SolDataParameterConditionList> for SolDataParameterConditionList {
            fn from(value: super::SolDataParameterConditionList) -> Self {
                Self {
                    name: Ok(value.name),
                    operator: Ok(value.operator),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolMessageCriterion {
            match_: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<super::SolMessageCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for SolMessageCriterion {
            fn default() -> Self {
                Self {
                    match_: Err("no value supplied for match_".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl SolMessageCriterion {
            pub fn match_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.match_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for match_: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolMessageCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolMessageCriterion> for super::SolMessageCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolMessageCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    match_: value.match_?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::SolMessageCriterion> for SolMessageCriterion {
            fn from(value: super::SolMessageCriterion) -> Self {
                Self {
                    match_: Ok(value.match_),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolNetworkCriterion {
            networks: ::std::result::Result<
                ::std::vec::Vec<super::SolNetworkCriterionNetworksItem>,
                ::std::string::String,
            >,
            operator:
                ::std::result::Result<super::SolNetworkCriterionOperator, ::std::string::String>,
            type_: ::std::result::Result<super::SolNetworkCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for SolNetworkCriterion {
            fn default() -> Self {
                Self {
                    networks: Err("no value supplied for networks".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl SolNetworkCriterion {
            pub fn networks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SolNetworkCriterionNetworksItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.networks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for networks: {}", e));
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolNetworkCriterionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolNetworkCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolNetworkCriterion> for super::SolNetworkCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolNetworkCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    networks: value.networks?,
                    operator: value.operator?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::SolNetworkCriterion> for SolNetworkCriterion {
            fn from(value: super::SolNetworkCriterion) -> Self {
                Self {
                    networks: Ok(value.networks),
                    operator: Ok(value.operator),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolValueCriterion {
            operator:
                ::std::result::Result<super::SolValueCriterionOperator, ::std::string::String>,
            sol_value: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<super::SolValueCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for SolValueCriterion {
            fn default() -> Self {
                Self {
                    operator: Err("no value supplied for operator".to_string()),
                    sol_value: Err("no value supplied for sol_value".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl SolValueCriterion {
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolValueCriterionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn sol_value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.sol_value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sol_value: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolValueCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolValueCriterion> for super::SolValueCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolValueCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    operator: value.operator?,
                    sol_value: value.sol_value?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::SolValueCriterion> for SolValueCriterion {
            fn from(value: super::SolValueCriterion) -> Self {
                Self {
                    operator: Ok(value.operator),
                    sol_value: Ok(value.sol_value),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaAccount {
            address: ::std::result::Result<super::SolanaAccountAddress, ::std::string::String>,
            created_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<super::SolanaAccountName>,
                ::std::string::String,
            >,
            policies: ::std::result::Result<
                ::std::vec::Vec<super::SolanaAccountPoliciesItem>,
                ::std::string::String,
            >,
            updated_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SolanaAccount {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    created_at: Ok(Default::default()),
                    name: Ok(Default::default()),
                    policies: Ok(Default::default()),
                    updated_at: Ok(Default::default()),
                }
            }
        }
        impl SolanaAccount {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaAccountAddress>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::SolanaAccountName>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn policies<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SolanaAccountPoliciesItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.policies = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policies: {}", e));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaAccount> for super::SolanaAccount {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaAccount,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    created_at: value.created_at?,
                    name: value.name?,
                    policies: value.policies?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaAccount> for SolanaAccount {
            fn from(value: super::SolanaAccount) -> Self {
                Self {
                    address: Ok(value.address),
                    created_at: Ok(value.created_at),
                    name: Ok(value.name),
                    policies: Ok(value.policies),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaToken {
            mint_address:
                ::std::result::Result<super::SolanaTokenMintAddress, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            symbol: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SolanaToken {
            fn default() -> Self {
                Self {
                    mint_address: Err("no value supplied for mint_address".to_string()),
                    name: Ok(Default::default()),
                    symbol: Ok(Default::default()),
                }
            }
        }
        impl SolanaToken {
            pub fn mint_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaTokenMintAddress>,
                T::Error: ::std::fmt::Display,
            {
                self.mint_address = value.try_into().map_err(|e| {
                    format!("error converting supplied value for mint_address: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn symbol<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.symbol = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for symbol: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaToken> for super::SolanaToken {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaToken,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    mint_address: value.mint_address?,
                    name: value.name?,
                    symbol: value.symbol?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaToken> for SolanaToken {
            fn from(value: super::SolanaToken) -> Self {
                Self {
                    mint_address: Ok(value.mint_address),
                    name: Ok(value.name),
                    symbol: Ok(value.symbol),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaTokenAmount {
            amount: ::std::result::Result<super::SolanaTokenAmountAmount, ::std::string::String>,
            decimals: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for SolanaTokenAmount {
            fn default() -> Self {
                Self {
                    amount: Err("no value supplied for amount".to_string()),
                    decimals: Err("no value supplied for decimals".to_string()),
                }
            }
        }
        impl SolanaTokenAmount {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaTokenAmountAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for amount: {}", e));
                self
            }
            pub fn decimals<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.decimals = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for decimals: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaTokenAmount> for super::SolanaTokenAmount {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaTokenAmount,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    amount: value.amount?,
                    decimals: value.decimals?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaTokenAmount> for SolanaTokenAmount {
            fn from(value: super::SolanaTokenAmount) -> Self {
                Self {
                    amount: Ok(value.amount),
                    decimals: Ok(value.decimals),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaTokenBalance {
            amount: ::std::result::Result<super::SolanaTokenAmount, ::std::string::String>,
            token: ::std::result::Result<super::SolanaToken, ::std::string::String>,
        }
        impl ::std::default::Default for SolanaTokenBalance {
            fn default() -> Self {
                Self {
                    amount: Err("no value supplied for amount".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }
        impl SolanaTokenBalance {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaTokenAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for amount: {}", e));
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaToken>,
                T::Error: ::std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaTokenBalance> for super::SolanaTokenBalance {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaTokenBalance,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    amount: value.amount?,
                    token: value.token?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaTokenBalance> for SolanaTokenBalance {
            fn from(value: super::SolanaTokenBalance) -> Self {
                Self {
                    amount: Ok(value.amount),
                    token: Ok(value.token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SpendPermission {
            account: ::std::result::Result<super::SpendPermissionAccount, ::std::string::String>,
            allowance: ::std::result::Result<::std::string::String, ::std::string::String>,
            end: ::std::result::Result<::std::string::String, ::std::string::String>,
            extra_data: ::std::result::Result<::std::string::String, ::std::string::String>,
            period: ::std::result::Result<::std::string::String, ::std::string::String>,
            salt: ::std::result::Result<::std::string::String, ::std::string::String>,
            spender: ::std::result::Result<super::SpendPermissionSpender, ::std::string::String>,
            start: ::std::result::Result<::std::string::String, ::std::string::String>,
            token: ::std::result::Result<super::SpendPermissionToken, ::std::string::String>,
        }
        impl ::std::default::Default for SpendPermission {
            fn default() -> Self {
                Self {
                    account: Err("no value supplied for account".to_string()),
                    allowance: Err("no value supplied for allowance".to_string()),
                    end: Err("no value supplied for end".to_string()),
                    extra_data: Err("no value supplied for extra_data".to_string()),
                    period: Err("no value supplied for period".to_string()),
                    salt: Err("no value supplied for salt".to_string()),
                    spender: Err("no value supplied for spender".to_string()),
                    start: Err("no value supplied for start".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }
        impl SpendPermission {
            pub fn account<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SpendPermissionAccount>,
                T::Error: ::std::fmt::Display,
            {
                self.account = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for account: {}", e));
                self
            }
            pub fn allowance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.allowance = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for allowance: {}", e));
                self
            }
            pub fn end<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.end = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for end: {}", e));
                self
            }
            pub fn extra_data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.extra_data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for extra_data: {}", e));
                self
            }
            pub fn period<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.period = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for period: {}", e));
                self
            }
            pub fn salt<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.salt = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for salt: {}", e));
                self
            }
            pub fn spender<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SpendPermissionSpender>,
                T::Error: ::std::fmt::Display,
            {
                self.spender = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for spender: {}", e));
                self
            }
            pub fn start<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.start = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start: {}", e));
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SpendPermissionToken>,
                T::Error: ::std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SpendPermission> for super::SpendPermission {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SpendPermission,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account: value.account?,
                    allowance: value.allowance?,
                    end: value.end?,
                    extra_data: value.extra_data?,
                    period: value.period?,
                    salt: value.salt?,
                    spender: value.spender?,
                    start: value.start?,
                    token: value.token?,
                })
            }
        }
        impl ::std::convert::From<super::SpendPermission> for SpendPermission {
            fn from(value: super::SpendPermission) -> Self {
                Self {
                    account: Ok(value.account),
                    allowance: Ok(value.allowance),
                    end: Ok(value.end),
                    extra_data: Ok(value.extra_data),
                    period: Ok(value.period),
                    salt: Ok(value.salt),
                    spender: Ok(value.spender),
                    start: Ok(value.start),
                    token: Ok(value.token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SpendPermissionResponseObject {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            network: ::std::result::Result<super::SpendPermissionNetwork, ::std::string::String>,
            permission: ::std::result::Result<super::SpendPermission, ::std::string::String>,
            permission_hash: ::std::result::Result<::std::string::String, ::std::string::String>,
            revoked: ::std::result::Result<bool, ::std::string::String>,
            revoked_at: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SpendPermissionResponseObject {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    network: Err("no value supplied for network".to_string()),
                    permission: Err("no value supplied for permission".to_string()),
                    permission_hash: Err("no value supplied for permission_hash".to_string()),
                    revoked: Err("no value supplied for revoked".to_string()),
                    revoked_at: Ok(Default::default()),
                }
            }
        }
        impl SpendPermissionResponseObject {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SpendPermissionNetwork>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn permission<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SpendPermission>,
                T::Error: ::std::fmt::Display,
            {
                self.permission = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for permission: {}", e));
                self
            }
            pub fn permission_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.permission_hash = value.try_into().map_err(|e| {
                    format!("error converting supplied value for permission_hash: {}", e)
                });
                self
            }
            pub fn revoked<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.revoked = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for revoked: {}", e));
                self
            }
            pub fn revoked_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.revoked_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for revoked_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SpendPermissionResponseObject>
            for super::SpendPermissionResponseObject
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SpendPermissionResponseObject,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    network: value.network?,
                    permission: value.permission?,
                    permission_hash: value.permission_hash?,
                    revoked: value.revoked?,
                    revoked_at: value.revoked_at?,
                })
            }
        }
        impl ::std::convert::From<super::SpendPermissionResponseObject> for SpendPermissionResponseObject {
            fn from(value: super::SpendPermissionResponseObject) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    network: Ok(value.network),
                    permission: Ok(value.permission),
                    permission_hash: Ok(value.permission_hash),
                    revoked: Ok(value.revoked),
                    revoked_at: Ok(value.revoked_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SplAddressCriterion {
            addresses: ::std::result::Result<
                ::std::vec::Vec<super::SplAddressCriterionAddressesItem>,
                ::std::string::String,
            >,
            operator:
                ::std::result::Result<super::SplAddressCriterionOperator, ::std::string::String>,
            type_: ::std::result::Result<super::SplAddressCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for SplAddressCriterion {
            fn default() -> Self {
                Self {
                    addresses: Err("no value supplied for addresses".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl SplAddressCriterion {
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::SplAddressCriterionAddressesItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for addresses: {}", e));
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SplAddressCriterionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SplAddressCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SplAddressCriterion> for super::SplAddressCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SplAddressCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addresses: value.addresses?,
                    operator: value.operator?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::SplAddressCriterion> for SplAddressCriterion {
            fn from(value: super::SplAddressCriterion) -> Self {
                Self {
                    addresses: Ok(value.addresses),
                    operator: Ok(value.operator),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SplValueCriterion {
            operator:
                ::std::result::Result<super::SplValueCriterionOperator, ::std::string::String>,
            spl_value: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<super::SplValueCriterionType, ::std::string::String>,
        }
        impl ::std::default::Default for SplValueCriterion {
            fn default() -> Self {
                Self {
                    operator: Err("no value supplied for operator".to_string()),
                    spl_value: Err("no value supplied for spl_value".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl SplValueCriterion {
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SplValueCriterionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn spl_value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.spl_value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for spl_value: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SplValueCriterionType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SplValueCriterion> for super::SplValueCriterion {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SplValueCriterion,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    operator: value.operator?,
                    spl_value: value.spl_value?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::SplValueCriterion> for SplValueCriterion {
            fn from(value: super::SplValueCriterion) -> Self {
                Self {
                    operator: Ok(value.operator),
                    spl_value: Ok(value.spl_value),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SupportedX402PaymentKindsResponse {
            extensions: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            kinds: ::std::result::Result<
                ::std::vec::Vec<super::X402SupportedPaymentKind>,
                ::std::string::String,
            >,
            signers: ::std::result::Result<
                ::std::collections::HashMap<
                    ::std::string::String,
                    ::std::vec::Vec<::std::string::String>,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SupportedX402PaymentKindsResponse {
            fn default() -> Self {
                Self {
                    extensions: Err("no value supplied for extensions".to_string()),
                    kinds: Err("no value supplied for kinds".to_string()),
                    signers: Err("no value supplied for signers".to_string()),
                }
            }
        }
        impl SupportedX402PaymentKindsResponse {
            pub fn extensions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.extensions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for extensions: {}", e));
                self
            }
            pub fn kinds<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::X402SupportedPaymentKind>>,
                T::Error: ::std::fmt::Display,
            {
                self.kinds = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kinds: {}", e));
                self
            }
            pub fn signers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<
                        ::std::string::String,
                        ::std::vec::Vec<::std::string::String>,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.signers = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signers: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SupportedX402PaymentKindsResponse>
            for super::SupportedX402PaymentKindsResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SupportedX402PaymentKindsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    extensions: value.extensions?,
                    kinds: value.kinds?,
                    signers: value.signers?,
                })
            }
        }
        impl ::std::convert::From<super::SupportedX402PaymentKindsResponse>
            for SupportedX402PaymentKindsResponse
        {
            fn from(value: super::SupportedX402PaymentKindsResponse) -> Self {
                Self {
                    extensions: Ok(value.extensions),
                    kinds: Ok(value.kinds),
                    signers: Ok(value.signers),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SwapUnavailableResponse {
            liquidity_available: ::std::result::Result<bool, ::std::string::String>,
        }
        impl ::std::default::Default for SwapUnavailableResponse {
            fn default() -> Self {
                Self {
                    liquidity_available: Err(
                        "no value supplied for liquidity_available".to_string()
                    ),
                }
            }
        }
        impl SwapUnavailableResponse {
            pub fn liquidity_available<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.liquidity_available = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for liquidity_available: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<SwapUnavailableResponse> for super::SwapUnavailableResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwapUnavailableResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    liquidity_available: value.liquidity_available?,
                })
            }
        }
        impl ::std::convert::From<super::SwapUnavailableResponse> for SwapUnavailableResponse {
            fn from(value: super::SwapUnavailableResponse) -> Self {
                Self {
                    liquidity_available: Ok(value.liquidity_available),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Token {
            contract_address:
                ::std::result::Result<super::TokenContractAddress, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            network:
                ::std::result::Result<super::ListEvmTokenBalancesNetwork, ::std::string::String>,
            symbol: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for Token {
            fn default() -> Self {
                Self {
                    contract_address: Err("no value supplied for contract_address".to_string()),
                    name: Ok(Default::default()),
                    network: Err("no value supplied for network".to_string()),
                    symbol: Ok(Default::default()),
                }
            }
        }
        impl Token {
            pub fn contract_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TokenContractAddress>,
                T::Error: ::std::fmt::Display,
            {
                self.contract_address = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for contract_address: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ListEvmTokenBalancesNetwork>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn symbol<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.symbol = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for symbol: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<Token> for super::Token {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Token,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    contract_address: value.contract_address?,
                    name: value.name?,
                    network: value.network?,
                    symbol: value.symbol?,
                })
            }
        }
        impl ::std::convert::From<super::Token> for Token {
            fn from(value: super::Token) -> Self {
                Self {
                    contract_address: Ok(value.contract_address),
                    name: Ok(value.name),
                    network: Ok(value.network),
                    symbol: Ok(value.symbol),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TokenAmount {
            amount: ::std::result::Result<super::TokenAmountAmount, ::std::string::String>,
            decimals: ::std::result::Result<i64, ::std::string::String>,
        }
        impl ::std::default::Default for TokenAmount {
            fn default() -> Self {
                Self {
                    amount: Err("no value supplied for amount".to_string()),
                    decimals: Err("no value supplied for decimals".to_string()),
                }
            }
        }
        impl TokenAmount {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TokenAmountAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for amount: {}", e));
                self
            }
            pub fn decimals<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.decimals = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for decimals: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<TokenAmount> for super::TokenAmount {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TokenAmount,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    amount: value.amount?,
                    decimals: value.decimals?,
                })
            }
        }
        impl ::std::convert::From<super::TokenAmount> for TokenAmount {
            fn from(value: super::TokenAmount) -> Self {
                Self {
                    amount: Ok(value.amount),
                    decimals: Ok(value.decimals),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TokenBalance {
            amount: ::std::result::Result<super::TokenAmount, ::std::string::String>,
            token: ::std::result::Result<super::Token, ::std::string::String>,
        }
        impl ::std::default::Default for TokenBalance {
            fn default() -> Self {
                Self {
                    amount: Err("no value supplied for amount".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }
        impl TokenBalance {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TokenAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for amount: {}", e));
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Token>,
                T::Error: ::std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<TokenBalance> for super::TokenBalance {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TokenBalance,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    amount: value.amount?,
                    token: value.token?,
                })
            }
        }
        impl ::std::convert::From<super::TokenBalance> for TokenBalance {
            fn from(value: super::TokenBalance) -> Self {
                Self {
                    amount: Ok(value.amount),
                    token: Ok(value.token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TokenFee {
            amount: ::std::result::Result<super::TokenFeeAmount, ::std::string::String>,
            token: ::std::result::Result<super::TokenFeeToken, ::std::string::String>,
        }
        impl ::std::default::Default for TokenFee {
            fn default() -> Self {
                Self {
                    amount: Err("no value supplied for amount".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }
        impl TokenFee {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TokenFeeAmount>,
                T::Error: ::std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for amount: {}", e));
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TokenFeeToken>,
                T::Error: ::std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<TokenFee> for super::TokenFee {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TokenFee,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    amount: value.amount?,
                    token: value.token?,
                })
            }
        }
        impl ::std::convert::From<super::TokenFee> for TokenFee {
            fn from(value: super::TokenFee) -> Self {
                Self {
                    amount: Ok(value.amount),
                    token: Ok(value.token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateEvmAccountBody {
            account_policy: ::std::result::Result<
                ::std::option::Option<super::UpdateEvmAccountBodyAccountPolicy>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<super::UpdateEvmAccountBodyName>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for UpdateEvmAccountBody {
            fn default() -> Self {
                Self {
                    account_policy: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }
        impl UpdateEvmAccountBody {
            pub fn account_policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::UpdateEvmAccountBodyAccountPolicy>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.account_policy = value.try_into().map_err(|e| {
                    format!("error converting supplied value for account_policy: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::UpdateEvmAccountBodyName>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateEvmAccountBody> for super::UpdateEvmAccountBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateEvmAccountBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_policy: value.account_policy?,
                    name: value.name?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateEvmAccountBody> for UpdateEvmAccountBody {
            fn from(value: super::UpdateEvmAccountBody) -> Self {
                Self {
                    account_policy: Ok(value.account_policy),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateEvmSmartAccountBody {
            name: ::std::result::Result<
                ::std::option::Option<super::UpdateEvmSmartAccountBodyName>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for UpdateEvmSmartAccountBody {
            fn default() -> Self {
                Self {
                    name: Ok(Default::default()),
                }
            }
        }
        impl UpdateEvmSmartAccountBody {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::UpdateEvmSmartAccountBodyName>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateEvmSmartAccountBody> for super::UpdateEvmSmartAccountBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateEvmSmartAccountBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { name: value.name? })
            }
        }
        impl ::std::convert::From<super::UpdateEvmSmartAccountBody> for UpdateEvmSmartAccountBody {
            fn from(value: super::UpdateEvmSmartAccountBody) -> Self {
                Self {
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdatePolicyBody {
            description: ::std::result::Result<
                ::std::option::Option<super::UpdatePolicyBodyDescription>,
                ::std::string::String,
            >,
            rules: ::std::result::Result<::std::vec::Vec<super::Rule>, ::std::string::String>,
        }
        impl ::std::default::Default for UpdatePolicyBody {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    rules: Err("no value supplied for rules".to_string()),
                }
            }
        }
        impl UpdatePolicyBody {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::UpdatePolicyBodyDescription>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn rules<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Rule>>,
                T::Error: ::std::fmt::Display,
            {
                self.rules = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rules: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdatePolicyBody> for super::UpdatePolicyBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdatePolicyBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    rules: value.rules?,
                })
            }
        }
        impl ::std::convert::From<super::UpdatePolicyBody> for UpdatePolicyBody {
            fn from(value: super::UpdatePolicyBody) -> Self {
                Self {
                    description: Ok(value.description),
                    rules: Ok(value.rules),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateSolanaAccountBody {
            account_policy: ::std::result::Result<
                ::std::option::Option<super::UpdateSolanaAccountBodyAccountPolicy>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<super::UpdateSolanaAccountBodyName>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for UpdateSolanaAccountBody {
            fn default() -> Self {
                Self {
                    account_policy: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }
        impl UpdateSolanaAccountBody {
            pub fn account_policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::UpdateSolanaAccountBodyAccountPolicy>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.account_policy = value.try_into().map_err(|e| {
                    format!("error converting supplied value for account_policy: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::UpdateSolanaAccountBodyName>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateSolanaAccountBody> for super::UpdateSolanaAccountBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateSolanaAccountBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_policy: value.account_policy?,
                    name: value.name?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateSolanaAccountBody> for UpdateSolanaAccountBody {
            fn from(value: super::UpdateSolanaAccountBody) -> Self {
                Self {
                    account_policy: Ok(value.account_policy),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UserOperationReceipt {
            block_hash: ::std::result::Result<
                ::std::option::Option<super::UserOperationReceiptBlockHash>,
                ::std::string::String,
            >,
            block_number: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            gas_used: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            revert: ::std::result::Result<
                ::std::option::Option<super::UserOperationReceiptRevert>,
                ::std::string::String,
            >,
            transaction_hash: ::std::result::Result<
                ::std::option::Option<super::UserOperationReceiptTransactionHash>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for UserOperationReceipt {
            fn default() -> Self {
                Self {
                    block_hash: Ok(Default::default()),
                    block_number: Ok(Default::default()),
                    gas_used: Ok(Default::default()),
                    revert: Ok(Default::default()),
                    transaction_hash: Ok(Default::default()),
                }
            }
        }
        impl UserOperationReceipt {
            pub fn block_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::UserOperationReceiptBlockHash>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.block_hash = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_hash: {}", e));
                self
            }
            pub fn block_number<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.block_number = value.try_into().map_err(|e| {
                    format!("error converting supplied value for block_number: {}", e)
                });
                self
            }
            pub fn gas_used<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.gas_used = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas_used: {}", e));
                self
            }
            pub fn revert<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::UserOperationReceiptRevert>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.revert = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for revert: {}", e));
                self
            }
            pub fn transaction_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::UserOperationReceiptTransactionHash>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.transaction_hash = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for transaction_hash: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<UserOperationReceipt> for super::UserOperationReceipt {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UserOperationReceipt,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_hash: value.block_hash?,
                    block_number: value.block_number?,
                    gas_used: value.gas_used?,
                    revert: value.revert?,
                    transaction_hash: value.transaction_hash?,
                })
            }
        }
        impl ::std::convert::From<super::UserOperationReceipt> for UserOperationReceipt {
            fn from(value: super::UserOperationReceipt) -> Self {
                Self {
                    block_hash: Ok(value.block_hash),
                    block_number: Ok(value.block_number),
                    gas_used: Ok(value.gas_used),
                    revert: Ok(value.revert),
                    transaction_hash: Ok(value.transaction_hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UserOperationReceiptRevert {
            data:
                ::std::result::Result<super::UserOperationReceiptRevertData, ::std::string::String>,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for UserOperationReceiptRevert {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    message: Err("no value supplied for message".to_string()),
                }
            }
        }
        impl UserOperationReceiptRevert {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UserOperationReceiptRevertData>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<UserOperationReceiptRevert> for super::UserOperationReceiptRevert {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UserOperationReceiptRevert,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::UserOperationReceiptRevert> for UserOperationReceiptRevert {
            fn from(value: super::UserOperationReceiptRevert) -> Self {
                Self {
                    data: Ok(value.data),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ValidateEndUserAccessTokenBody {
            access_token: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ValidateEndUserAccessTokenBody {
            fn default() -> Self {
                Self {
                    access_token: Err("no value supplied for access_token".to_string()),
                }
            }
        }
        impl ValidateEndUserAccessTokenBody {
            pub fn access_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.access_token = value.try_into().map_err(|e| {
                    format!("error converting supplied value for access_token: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<ValidateEndUserAccessTokenBody>
            for super::ValidateEndUserAccessTokenBody
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ValidateEndUserAccessTokenBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    access_token: value.access_token?,
                })
            }
        }
        impl ::std::convert::From<super::ValidateEndUserAccessTokenBody>
            for ValidateEndUserAccessTokenBody
        {
            fn from(value: super::ValidateEndUserAccessTokenBody) -> Self {
                Self {
                    access_token: Ok(value.access_token),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct VerifyX402PaymentBody {
            payment_payload:
                ::std::result::Result<super::X402PaymentPayload, ::std::string::String>,
            payment_requirements:
                ::std::result::Result<super::X402PaymentRequirements, ::std::string::String>,
            x402_version: ::std::result::Result<super::X402Version, ::std::string::String>,
        }
        impl ::std::default::Default for VerifyX402PaymentBody {
            fn default() -> Self {
                Self {
                    payment_payload: Err("no value supplied for payment_payload".to_string()),
                    payment_requirements: Err(
                        "no value supplied for payment_requirements".to_string()
                    ),
                    x402_version: Err("no value supplied for x402_version".to_string()),
                }
            }
        }
        impl VerifyX402PaymentBody {
            pub fn payment_payload<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402PaymentPayload>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_payload = value.try_into().map_err(|e| {
                    format!("error converting supplied value for payment_payload: {}", e)
                });
                self
            }
            pub fn payment_requirements<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402PaymentRequirements>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_requirements = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for payment_requirements: {}",
                        e
                    )
                });
                self
            }
            pub fn x402_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402Version>,
                T::Error: ::std::fmt::Display,
            {
                self.x402_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for x402_version: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<VerifyX402PaymentBody> for super::VerifyX402PaymentBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VerifyX402PaymentBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    payment_payload: value.payment_payload?,
                    payment_requirements: value.payment_requirements?,
                    x402_version: value.x402_version?,
                })
            }
        }
        impl ::std::convert::From<super::VerifyX402PaymentBody> for VerifyX402PaymentBody {
            fn from(value: super::VerifyX402PaymentBody) -> Self {
                Self {
                    payment_payload: Ok(value.payment_payload),
                    payment_requirements: Ok(value.payment_requirements),
                    x402_version: Ok(value.x402_version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct VerifyX402PaymentResponse {
            invalid_reason: ::std::result::Result<
                ::std::option::Option<super::X402VerifyInvalidReason>,
                ::std::string::String,
            >,
            is_valid: ::std::result::Result<bool, ::std::string::String>,
            payer:
                ::std::result::Result<super::VerifyX402PaymentResponsePayer, ::std::string::String>,
        }
        impl ::std::default::Default for VerifyX402PaymentResponse {
            fn default() -> Self {
                Self {
                    invalid_reason: Ok(Default::default()),
                    is_valid: Err("no value supplied for is_valid".to_string()),
                    payer: Err("no value supplied for payer".to_string()),
                }
            }
        }
        impl VerifyX402PaymentResponse {
            pub fn invalid_reason<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::X402VerifyInvalidReason>>,
                T::Error: ::std::fmt::Display,
            {
                self.invalid_reason = value.try_into().map_err(|e| {
                    format!("error converting supplied value for invalid_reason: {}", e)
                });
                self
            }
            pub fn is_valid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_valid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_valid: {}", e));
                self
            }
            pub fn payer<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::VerifyX402PaymentResponsePayer>,
                T::Error: ::std::fmt::Display,
            {
                self.payer = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for payer: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<VerifyX402PaymentResponse> for super::VerifyX402PaymentResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VerifyX402PaymentResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    invalid_reason: value.invalid_reason?,
                    is_valid: value.is_valid?,
                    payer: value.payer?,
                })
            }
        }
        impl ::std::convert::From<super::VerifyX402PaymentResponse> for VerifyX402PaymentResponse {
            fn from(value: super::VerifyX402PaymentResponse) -> Self {
                Self {
                    invalid_reason: Ok(value.invalid_reason),
                    is_valid: Ok(value.is_valid),
                    payer: Ok(value.payer),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WebhookSubscriptionListResponse {
            next_page_token: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subscriptions: ::std::result::Result<
                ::std::vec::Vec<super::WebhookSubscriptionResponse>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for WebhookSubscriptionListResponse {
            fn default() -> Self {
                Self {
                    next_page_token: Ok(Default::default()),
                    subscriptions: Err("no value supplied for subscriptions".to_string()),
                }
            }
        }
        impl WebhookSubscriptionListResponse {
            pub fn next_page_token<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page_token = value.try_into().map_err(|e| {
                    format!("error converting supplied value for next_page_token: {}", e)
                });
                self
            }
            pub fn subscriptions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::WebhookSubscriptionResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.subscriptions = value.try_into().map_err(|e| {
                    format!("error converting supplied value for subscriptions: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<WebhookSubscriptionListResponse>
            for super::WebhookSubscriptionListResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookSubscriptionListResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    next_page_token: value.next_page_token?,
                    subscriptions: value.subscriptions?,
                })
            }
        }
        impl ::std::convert::From<super::WebhookSubscriptionListResponse>
            for WebhookSubscriptionListResponse
        {
            fn from(value: super::WebhookSubscriptionListResponse) -> Self {
                Self {
                    next_page_token: Ok(value.next_page_token),
                    subscriptions: Ok(value.subscriptions),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WebhookSubscriptionResponse {
            created_at: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            event_types: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            is_enabled: ::std::result::Result<bool, ::std::string::String>,
            label_key: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            label_value: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            labels: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                ::std::string::String,
            >,
            metadata: ::std::result::Result<
                ::std::option::Option<super::WebhookSubscriptionResponseMetadata>,
                ::std::string::String,
            >,
            secret: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            subscription_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            target: ::std::result::Result<super::WebhookTarget, ::std::string::String>,
        }
        impl ::std::default::Default for WebhookSubscriptionResponse {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    description: Ok(Default::default()),
                    event_types: Err("no value supplied for event_types".to_string()),
                    is_enabled: Err("no value supplied for is_enabled".to_string()),
                    label_key: Ok(Default::default()),
                    label_value: Ok(Default::default()),
                    labels: Ok(Default::default()),
                    metadata: Ok(Default::default()),
                    secret: Err("no value supplied for secret".to_string()),
                    subscription_id: Err("no value supplied for subscription_id".to_string()),
                    target: Err("no value supplied for target".to_string()),
                }
            }
        }
        impl WebhookSubscriptionResponse {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn event_types<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.event_types = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for event_types: {}", e));
                self
            }
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_enabled: {}", e));
                self
            }
            pub fn label_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.label_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for label_key: {}", e));
                self
            }
            pub fn label_value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.label_value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for label_value: {}", e));
                self
            }
            pub fn labels<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.labels = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for labels: {}", e));
                self
            }
            pub fn metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::WebhookSubscriptionResponseMetadata>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for metadata: {}", e));
                self
            }
            pub fn secret<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.secret = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for secret: {}", e));
                self
            }
            pub fn subscription_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.subscription_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for subscription_id: {}", e)
                });
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WebhookTarget>,
                T::Error: ::std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<WebhookSubscriptionResponse> for super::WebhookSubscriptionResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookSubscriptionResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    description: value.description?,
                    event_types: value.event_types?,
                    is_enabled: value.is_enabled?,
                    label_key: value.label_key?,
                    label_value: value.label_value?,
                    labels: value.labels?,
                    metadata: value.metadata?,
                    secret: value.secret?,
                    subscription_id: value.subscription_id?,
                    target: value.target?,
                })
            }
        }
        impl ::std::convert::From<super::WebhookSubscriptionResponse> for WebhookSubscriptionResponse {
            fn from(value: super::WebhookSubscriptionResponse) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    description: Ok(value.description),
                    event_types: Ok(value.event_types),
                    is_enabled: Ok(value.is_enabled),
                    label_key: Ok(value.label_key),
                    label_value: Ok(value.label_value),
                    labels: Ok(value.labels),
                    metadata: Ok(value.metadata),
                    secret: Ok(value.secret),
                    subscription_id: Ok(value.subscription_id),
                    target: Ok(value.target),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WebhookSubscriptionResponseMetadata {
            secret:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
        }
        impl ::std::default::Default for WebhookSubscriptionResponseMetadata {
            fn default() -> Self {
                Self {
                    secret: Ok(Default::default()),
                }
            }
        }
        impl WebhookSubscriptionResponseMetadata {
            pub fn secret<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.secret = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for secret: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<WebhookSubscriptionResponseMetadata>
            for super::WebhookSubscriptionResponseMetadata
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookSubscriptionResponseMetadata,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    secret: value.secret?,
                })
            }
        }
        impl ::std::convert::From<super::WebhookSubscriptionResponseMetadata>
            for WebhookSubscriptionResponseMetadata
        {
            fn from(value: super::WebhookSubscriptionResponseMetadata) -> Self {
                Self {
                    secret: Ok(value.secret),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WebhookTarget {
            headers: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                ::std::string::String,
            >,
            url: ::std::result::Result<super::Url, ::std::string::String>,
        }
        impl ::std::default::Default for WebhookTarget {
            fn default() -> Self {
                Self {
                    headers: Ok(Default::default()),
                    url: Err("no value supplied for url".to_string()),
                }
            }
        }
        impl WebhookTarget {
            pub fn headers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.headers = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for headers: {}", e));
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Url>,
                T::Error: ::std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<WebhookTarget> for super::WebhookTarget {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookTarget,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    headers: value.headers?,
                    url: value.url?,
                })
            }
        }
        impl ::std::convert::From<super::WebhookTarget> for WebhookTarget {
            fn from(value: super::WebhookTarget) -> Self {
                Self {
                    headers: Ok(value.headers),
                    url: Ok(value.url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct X402ExactEvmPayload {
            authorization: ::std::result::Result<
                super::X402ExactEvmPayloadAuthorization,
                ::std::string::String,
            >,
            signature: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for X402ExactEvmPayload {
            fn default() -> Self {
                Self {
                    authorization: Err("no value supplied for authorization".to_string()),
                    signature: Err("no value supplied for signature".to_string()),
                }
            }
        }
        impl X402ExactEvmPayload {
            pub fn authorization<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402ExactEvmPayloadAuthorization>,
                T::Error: ::std::fmt::Display,
            {
                self.authorization = value.try_into().map_err(|e| {
                    format!("error converting supplied value for authorization: {}", e)
                });
                self
            }
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signature: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<X402ExactEvmPayload> for super::X402ExactEvmPayload {
            type Error = super::error::ConversionError;
            fn try_from(
                value: X402ExactEvmPayload,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    authorization: value.authorization?,
                    signature: value.signature?,
                })
            }
        }
        impl ::std::convert::From<super::X402ExactEvmPayload> for X402ExactEvmPayload {
            fn from(value: super::X402ExactEvmPayload) -> Self {
                Self {
                    authorization: Ok(value.authorization),
                    signature: Ok(value.signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct X402ExactEvmPayloadAuthorization {
            from: ::std::result::Result<
                super::X402ExactEvmPayloadAuthorizationFrom,
                ::std::string::String,
            >,
            nonce: ::std::result::Result<::std::string::String, ::std::string::String>,
            to: ::std::result::Result<
                super::X402ExactEvmPayloadAuthorizationTo,
                ::std::string::String,
            >,
            valid_after: ::std::result::Result<::std::string::String, ::std::string::String>,
            valid_before: ::std::result::Result<::std::string::String, ::std::string::String>,
            value: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for X402ExactEvmPayloadAuthorization {
            fn default() -> Self {
                Self {
                    from: Err("no value supplied for from".to_string()),
                    nonce: Err("no value supplied for nonce".to_string()),
                    to: Err("no value supplied for to".to_string()),
                    valid_after: Err("no value supplied for valid_after".to_string()),
                    valid_before: Err("no value supplied for valid_before".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl X402ExactEvmPayloadAuthorization {
            pub fn from<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402ExactEvmPayloadAuthorizationFrom>,
                T::Error: ::std::fmt::Display,
            {
                self.from = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for from: {}", e));
                self
            }
            pub fn nonce<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.nonce = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for nonce: {}", e));
                self
            }
            pub fn to<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402ExactEvmPayloadAuthorizationTo>,
                T::Error: ::std::fmt::Display,
            {
                self.to = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to: {}", e));
                self
            }
            pub fn valid_after<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.valid_after = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for valid_after: {}", e));
                self
            }
            pub fn valid_before<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.valid_before = value.try_into().map_err(|e| {
                    format!("error converting supplied value for valid_before: {}", e)
                });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<X402ExactEvmPayloadAuthorization>
            for super::X402ExactEvmPayloadAuthorization
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: X402ExactEvmPayloadAuthorization,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    from: value.from?,
                    nonce: value.nonce?,
                    to: value.to?,
                    valid_after: value.valid_after?,
                    valid_before: value.valid_before?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::X402ExactEvmPayloadAuthorization>
            for X402ExactEvmPayloadAuthorization
        {
            fn from(value: super::X402ExactEvmPayloadAuthorization) -> Self {
                Self {
                    from: Ok(value.from),
                    nonce: Ok(value.nonce),
                    to: Ok(value.to),
                    valid_after: Ok(value.valid_after),
                    valid_before: Ok(value.valid_before),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct X402ExactSolanaPayload {
            transaction: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for X402ExactSolanaPayload {
            fn default() -> Self {
                Self {
                    transaction: Err("no value supplied for transaction".to_string()),
                }
            }
        }
        impl X402ExactSolanaPayload {
            pub fn transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for transaction: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<X402ExactSolanaPayload> for super::X402ExactSolanaPayload {
            type Error = super::error::ConversionError;
            fn try_from(
                value: X402ExactSolanaPayload,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    transaction: value.transaction?,
                })
            }
        }
        impl ::std::convert::From<super::X402ExactSolanaPayload> for X402ExactSolanaPayload {
            fn from(value: super::X402ExactSolanaPayload) -> Self {
                Self {
                    transaction: Ok(value.transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct X402ResourceInfo {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            mime_type: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for X402ResourceInfo {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    mime_type: Ok(Default::default()),
                    url: Ok(Default::default()),
                }
            }
        }
        impl X402ResourceInfo {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn mime_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.mime_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for mime_type: {}", e));
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<X402ResourceInfo> for super::X402ResourceInfo {
            type Error = super::error::ConversionError;
            fn try_from(
                value: X402ResourceInfo,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    mime_type: value.mime_type?,
                    url: value.url?,
                })
            }
        }
        impl ::std::convert::From<super::X402ResourceInfo> for X402ResourceInfo {
            fn from(value: super::X402ResourceInfo) -> Self {
                Self {
                    description: Ok(value.description),
                    mime_type: Ok(value.mime_type),
                    url: Ok(value.url),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct X402SupportedPaymentKind {
            extra: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            network: ::std::result::Result<::std::string::String, ::std::string::String>,
            scheme:
                ::std::result::Result<super::X402SupportedPaymentKindScheme, ::std::string::String>,
            x402_version: ::std::result::Result<super::X402Version, ::std::string::String>,
        }
        impl ::std::default::Default for X402SupportedPaymentKind {
            fn default() -> Self {
                Self {
                    extra: Ok(Default::default()),
                    network: Err("no value supplied for network".to_string()),
                    scheme: Err("no value supplied for scheme".to_string()),
                    x402_version: Err("no value supplied for x402_version".to_string()),
                }
            }
        }
        impl X402SupportedPaymentKind {
            pub fn extra<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.extra = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for extra: {}", e));
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn scheme<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402SupportedPaymentKindScheme>,
                T::Error: ::std::fmt::Display,
            {
                self.scheme = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scheme: {}", e));
                self
            }
            pub fn x402_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402Version>,
                T::Error: ::std::fmt::Display,
            {
                self.x402_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for x402_version: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<X402SupportedPaymentKind> for super::X402SupportedPaymentKind {
            type Error = super::error::ConversionError;
            fn try_from(
                value: X402SupportedPaymentKind,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    extra: value.extra?,
                    network: value.network?,
                    scheme: value.scheme?,
                    x402_version: value.x402_version?,
                })
            }
        }
        impl ::std::convert::From<super::X402SupportedPaymentKind> for X402SupportedPaymentKind {
            fn from(value: super::X402SupportedPaymentKind) -> Self {
                Self {
                    extra: Ok(value.extra),
                    network: Ok(value.network),
                    scheme: Ok(value.scheme),
                    x402_version: Ok(value.x402_version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct X402V1PaymentPayload {
            network:
                ::std::result::Result<super::X402v1PaymentPayloadNetwork, ::std::string::String>,
            payload:
                ::std::result::Result<super::X402v1PaymentPayloadPayload, ::std::string::String>,
            scheme: ::std::result::Result<super::X402v1PaymentPayloadScheme, ::std::string::String>,
            x402_version: ::std::result::Result<super::X402Version, ::std::string::String>,
        }
        impl ::std::default::Default for X402V1PaymentPayload {
            fn default() -> Self {
                Self {
                    network: Err("no value supplied for network".to_string()),
                    payload: Err("no value supplied for payload".to_string()),
                    scheme: Err("no value supplied for scheme".to_string()),
                    x402_version: Err("no value supplied for x402_version".to_string()),
                }
            }
        }
        impl X402V1PaymentPayload {
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402v1PaymentPayloadNetwork>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn payload<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402v1PaymentPayloadPayload>,
                T::Error: ::std::fmt::Display,
            {
                self.payload = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for payload: {}", e));
                self
            }
            pub fn scheme<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402v1PaymentPayloadScheme>,
                T::Error: ::std::fmt::Display,
            {
                self.scheme = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scheme: {}", e));
                self
            }
            pub fn x402_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402Version>,
                T::Error: ::std::fmt::Display,
            {
                self.x402_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for x402_version: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<X402V1PaymentPayload> for super::X402V1PaymentPayload {
            type Error = super::error::ConversionError;
            fn try_from(
                value: X402V1PaymentPayload,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    network: value.network?,
                    payload: value.payload?,
                    scheme: value.scheme?,
                    x402_version: value.x402_version?,
                })
            }
        }
        impl ::std::convert::From<super::X402V1PaymentPayload> for X402V1PaymentPayload {
            fn from(value: super::X402V1PaymentPayload) -> Self {
                Self {
                    network: Ok(value.network),
                    payload: Ok(value.payload),
                    scheme: Ok(value.scheme),
                    x402_version: Ok(value.x402_version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct X402V1PaymentRequirements {
            asset:
                ::std::result::Result<super::X402v1PaymentRequirementsAsset, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            extra: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            max_amount_required:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            max_timeout_seconds: ::std::result::Result<i64, ::std::string::String>,
            mime_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            network: ::std::result::Result<
                super::X402v1PaymentRequirementsNetwork,
                ::std::string::String,
            >,
            output_schema: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            pay_to:
                ::std::result::Result<super::X402v1PaymentRequirementsPayTo, ::std::string::String>,
            resource: ::std::result::Result<::std::string::String, ::std::string::String>,
            scheme: ::std::result::Result<
                super::X402v1PaymentRequirementsScheme,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for X402V1PaymentRequirements {
            fn default() -> Self {
                Self {
                    asset: Err("no value supplied for asset".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    extra: Ok(Default::default()),
                    max_amount_required: Err(
                        "no value supplied for max_amount_required".to_string()
                    ),
                    max_timeout_seconds: Err(
                        "no value supplied for max_timeout_seconds".to_string()
                    ),
                    mime_type: Err("no value supplied for mime_type".to_string()),
                    network: Err("no value supplied for network".to_string()),
                    output_schema: Ok(Default::default()),
                    pay_to: Err("no value supplied for pay_to".to_string()),
                    resource: Err("no value supplied for resource".to_string()),
                    scheme: Err("no value supplied for scheme".to_string()),
                }
            }
        }
        impl X402V1PaymentRequirements {
            pub fn asset<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402v1PaymentRequirementsAsset>,
                T::Error: ::std::fmt::Display,
            {
                self.asset = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for asset: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn extra<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.extra = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for extra: {}", e));
                self
            }
            pub fn max_amount_required<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.max_amount_required = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for max_amount_required: {}",
                        e
                    )
                });
                self
            }
            pub fn max_timeout_seconds<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.max_timeout_seconds = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for max_timeout_seconds: {}",
                        e
                    )
                });
                self
            }
            pub fn mime_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.mime_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for mime_type: {}", e));
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402v1PaymentRequirementsNetwork>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn output_schema<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.output_schema = value.try_into().map_err(|e| {
                    format!("error converting supplied value for output_schema: {}", e)
                });
                self
            }
            pub fn pay_to<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402v1PaymentRequirementsPayTo>,
                T::Error: ::std::fmt::Display,
            {
                self.pay_to = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pay_to: {}", e));
                self
            }
            pub fn resource<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.resource = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for resource: {}", e));
                self
            }
            pub fn scheme<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402v1PaymentRequirementsScheme>,
                T::Error: ::std::fmt::Display,
            {
                self.scheme = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scheme: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<X402V1PaymentRequirements> for super::X402V1PaymentRequirements {
            type Error = super::error::ConversionError;
            fn try_from(
                value: X402V1PaymentRequirements,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    asset: value.asset?,
                    description: value.description?,
                    extra: value.extra?,
                    max_amount_required: value.max_amount_required?,
                    max_timeout_seconds: value.max_timeout_seconds?,
                    mime_type: value.mime_type?,
                    network: value.network?,
                    output_schema: value.output_schema?,
                    pay_to: value.pay_to?,
                    resource: value.resource?,
                    scheme: value.scheme?,
                })
            }
        }
        impl ::std::convert::From<super::X402V1PaymentRequirements> for X402V1PaymentRequirements {
            fn from(value: super::X402V1PaymentRequirements) -> Self {
                Self {
                    asset: Ok(value.asset),
                    description: Ok(value.description),
                    extra: Ok(value.extra),
                    max_amount_required: Ok(value.max_amount_required),
                    max_timeout_seconds: Ok(value.max_timeout_seconds),
                    mime_type: Ok(value.mime_type),
                    network: Ok(value.network),
                    output_schema: Ok(value.output_schema),
                    pay_to: Ok(value.pay_to),
                    resource: Ok(value.resource),
                    scheme: Ok(value.scheme),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct X402V2PaymentPayload {
            accepted:
                ::std::result::Result<super::X402V2PaymentRequirements, ::std::string::String>,
            extensions: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            payload:
                ::std::result::Result<super::X402v2PaymentPayloadPayload, ::std::string::String>,
            resource: ::std::result::Result<
                ::std::option::Option<super::X402ResourceInfo>,
                ::std::string::String,
            >,
            x402_version: ::std::result::Result<super::X402Version, ::std::string::String>,
        }
        impl ::std::default::Default for X402V2PaymentPayload {
            fn default() -> Self {
                Self {
                    accepted: Err("no value supplied for accepted".to_string()),
                    extensions: Ok(Default::default()),
                    payload: Err("no value supplied for payload".to_string()),
                    resource: Ok(Default::default()),
                    x402_version: Err("no value supplied for x402_version".to_string()),
                }
            }
        }
        impl X402V2PaymentPayload {
            pub fn accepted<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402V2PaymentRequirements>,
                T::Error: ::std::fmt::Display,
            {
                self.accepted = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for accepted: {}", e));
                self
            }
            pub fn extensions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.extensions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for extensions: {}", e));
                self
            }
            pub fn payload<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402v2PaymentPayloadPayload>,
                T::Error: ::std::fmt::Display,
            {
                self.payload = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for payload: {}", e));
                self
            }
            pub fn resource<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::X402ResourceInfo>>,
                T::Error: ::std::fmt::Display,
            {
                self.resource = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for resource: {}", e));
                self
            }
            pub fn x402_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402Version>,
                T::Error: ::std::fmt::Display,
            {
                self.x402_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for x402_version: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<X402V2PaymentPayload> for super::X402V2PaymentPayload {
            type Error = super::error::ConversionError;
            fn try_from(
                value: X402V2PaymentPayload,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    accepted: value.accepted?,
                    extensions: value.extensions?,
                    payload: value.payload?,
                    resource: value.resource?,
                    x402_version: value.x402_version?,
                })
            }
        }
        impl ::std::convert::From<super::X402V2PaymentPayload> for X402V2PaymentPayload {
            fn from(value: super::X402V2PaymentPayload) -> Self {
                Self {
                    accepted: Ok(value.accepted),
                    extensions: Ok(value.extensions),
                    payload: Ok(value.payload),
                    resource: Ok(value.resource),
                    x402_version: Ok(value.x402_version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct X402V2PaymentRequirements {
            amount: ::std::result::Result<::std::string::String, ::std::string::String>,
            asset:
                ::std::result::Result<super::X402v2PaymentRequirementsAsset, ::std::string::String>,
            extra: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            max_timeout_seconds: ::std::result::Result<i64, ::std::string::String>,
            network: ::std::result::Result<::std::string::String, ::std::string::String>,
            pay_to:
                ::std::result::Result<super::X402v2PaymentRequirementsPayTo, ::std::string::String>,
            scheme: ::std::result::Result<
                super::X402v2PaymentRequirementsScheme,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for X402V2PaymentRequirements {
            fn default() -> Self {
                Self {
                    amount: Err("no value supplied for amount".to_string()),
                    asset: Err("no value supplied for asset".to_string()),
                    extra: Ok(Default::default()),
                    max_timeout_seconds: Err(
                        "no value supplied for max_timeout_seconds".to_string()
                    ),
                    network: Err("no value supplied for network".to_string()),
                    pay_to: Err("no value supplied for pay_to".to_string()),
                    scheme: Err("no value supplied for scheme".to_string()),
                }
            }
        }
        impl X402V2PaymentRequirements {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for amount: {}", e));
                self
            }
            pub fn asset<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402v2PaymentRequirementsAsset>,
                T::Error: ::std::fmt::Display,
            {
                self.asset = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for asset: {}", e));
                self
            }
            pub fn extra<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.extra = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for extra: {}", e));
                self
            }
            pub fn max_timeout_seconds<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.max_timeout_seconds = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for max_timeout_seconds: {}",
                        e
                    )
                });
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
            pub fn pay_to<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402v2PaymentRequirementsPayTo>,
                T::Error: ::std::fmt::Display,
            {
                self.pay_to = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pay_to: {}", e));
                self
            }
            pub fn scheme<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::X402v2PaymentRequirementsScheme>,
                T::Error: ::std::fmt::Display,
            {
                self.scheme = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for scheme: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<X402V2PaymentRequirements> for super::X402V2PaymentRequirements {
            type Error = super::error::ConversionError;
            fn try_from(
                value: X402V2PaymentRequirements,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    amount: value.amount?,
                    asset: value.asset?,
                    extra: value.extra?,
                    max_timeout_seconds: value.max_timeout_seconds?,
                    network: value.network?,
                    pay_to: value.pay_to?,
                    scheme: value.scheme?,
                })
            }
        }
        impl ::std::convert::From<super::X402V2PaymentRequirements> for X402V2PaymentRequirements {
            fn from(value: super::X402V2PaymentRequirements) -> Self {
                Self {
                    amount: Ok(value.amount),
                    asset: Ok(value.asset),
                    extra: Ok(value.extra),
                    max_timeout_seconds: Ok(value.max_timeout_seconds),
                    network: Ok(value.network),
                    pay_to: Ok(value.pay_to),
                    scheme: Ok(value.scheme),
                }
            }
        }
    }
    /// Generation of default values for serde.
    pub mod defaults {
        pub(super) fn default_u64<T, const V: u64>() -> T
        where
            T: ::std::convert::TryFrom<u64>,
            <T as ::std::convert::TryFrom<u64>>::Error: ::std::fmt::Debug,
        {
            T::try_from(V).unwrap()
        }
    }
}
#[derive(Clone, Debug)]
/**Client for Coinbase Developer Platform APIs

The Coinbase Developer Platform APIs - leading the world's transition onchain.

Version: 2.0.0*/
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest_middleware::ClientWithMiddleware,
}
impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = std::time::Duration::from_secs(15);
            let reqwest_client = reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
                .build()
                .unwrap();
            reqwest_middleware::ClientBuilder::new(reqwest_client).build()
        };
        #[cfg(target_arch = "wasm32")]
        let client = {
            let reqwest_client = reqwest::ClientBuilder::new().build().unwrap();
            reqwest_middleware::ClientBuilder::new(reqwest_client).build()
        };
        Self::new_with_client(baseurl, client)
    }
    /// Construct a new client with an existing `reqwest_middleware::ClientWithMiddleware`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest_middleware::ClientWithMiddleware`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(
        baseurl: &str,
        client: reqwest_middleware::ClientWithMiddleware,
    ) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }
}
impl ClientInfo<()> for Client {
    fn api_version() -> &'static str {
        "2.0.0"
    }
    fn baseurl(&self) -> &str {
        self.baseurl.as_str()
    }
    fn client(&self) -> &reqwest_middleware::ClientWithMiddleware {
        &self.client
    }
    fn inner(&self) -> &() {
        &()
    }
}
impl ClientHooks<()> for &Client {}
impl Client {
    /**List EVM token balances

    Lists the token balances of an EVM address on a given network. The balances include ERC-20 tokens and the native gas token (usually ETH). The response is paginated, and by default, returns 20 balances per page.

    **Note:** This endpoint provides <1 second freshness from chain tip, <500ms response latency for wallets with reasonable token history, and 99.9% uptime for production use.

    Sends a `GET` request to `/v2/data/evm/token-balances/{network}/{address}`

    Arguments:
    - `network`: The human-readable network name to get the balances for.
    - `address`: The 0x-prefixed EVM address to get balances for. The address does not need to be checksummed.
    - `page_size`: The number of resources to return per page.
    - `page_token`: The token for the next page of resources, if any.
    ```ignore
    let response = client.list_data_token_balances()
        .network(network)
        .address(address)
        .page_size(page_size)
        .page_token(page_token)
        .send()
        .await;
    ```*/
    pub fn list_data_token_balances(&self) -> builder::ListDataTokenBalances<'_> {
        builder::ListDataTokenBalances::new(self)
    }
    /**List token addresses for account

    Retrieve all ERC-20 token contract addresses that an account has ever received tokens from.
    Analyzes transaction history to discover token interactions.


    Sends a `GET` request to `/v2/data/evm/token-ownership/{network}/{address}`

    Arguments:
    - `network`: The blockchain network to query.
    - `address`: The account address to analyze for token interactions.
    ```ignore
    let response = client.list_tokens_for_account()
        .network(network)
        .address(address)
        .send()
        .await;
    ```*/
    pub fn list_tokens_for_account(&self) -> builder::ListTokensForAccount<'_> {
        builder::ListTokensForAccount::new(self)
    }
    /**Get SQL grammar

    Retrieve the SQL grammar for the SQL API.

    The SQL queries that are supported by the SQL API are defined via an ANTLR4 grammar which is evaluated by server before executing the query. This ensures the safety and soundness of the SQL API.

    This endpoint returns the ANTLR4 grammar that is used to evaluate the SQL queries so that developers can understand the SQL API and build SQL queries with high confidence and correctness. LLMs interact well with ANTLR4 grammar as well.


    Sends a `GET` request to `/v2/data/query/grammar`

    ```ignore
    let response = client.get_sql_grammar()
        .send()
        .await;
    ```*/
    pub fn get_sql_grammar(&self) -> builder::GetSqlGrammar<'_> {
        builder::GetSqlGrammar::new(self)
    }
    /**Run SQL Query

    Run a read-only SQL query against indexed blockchain data including transactions, events, and decoded logs.

    This endpoint provides direct SQL access to comprehensive blockchain data across supported networks.
    Queries are executed against optimized data structures for high-performance analytics.

    ### Allowed Queries

      - Standard SQL syntax (ClickHouse dialect)
      - Read-only queries (SELECT statements)
      - No DDL or DML operations
      - No cartesian products

    ### Supported Tables

      - `base.events` - Base mainnet decoded event logs with parameters, event signature, topics, and more.
      - `base.transactions` - Base mainnet transaction data including hash, block number, gas usage.
      - `base.blocks` - Base mainnet block information.
      - `base.encoded_logs` - Encoded log data of event logs that aren't able to be decoded by our event decoder (ex: log0 opcode).
      - `base.transfers` - All event logs with event signature `Transfer(address,address,uint256)`. ERC-20, ERC-721, and ERC-1155 transfers are all included.

    ### Query Limits

      - Maximum result set: 100,000 rows
      - Query timeout: 30 seconds


    Sends a `POST` request to `/v2/data/query/run`

    ```ignore
    let response = client.run_sql_query()
        .body(body)
        .send()
        .await;
    ```*/
    pub fn run_sql_query(&self) -> builder::RunSqlQuery<'_> {
        builder::RunSqlQuery::new(self)
    }
    /**List webhook subscriptions

    Retrieve a paginated list of webhook subscriptions for the authenticated project.
    Returns subscriptions for all CDP product events (onchain, onramp/offramp, wallet, etc.)
    in descending order by creation time.

    ### Use Cases
    - Monitor all active webhook subscriptions across CDP products
    - Audit webhook configurations
    - Manage subscription lifecycle


    Sends a `GET` request to `/v2/data/webhooks/subscriptions`

    Arguments:
    - `page_size`: The number of subscriptions to return per page.
    - `page_token`: The token for the next page of subscriptions, if any.
    ```ignore
    let response = client.list_webhook_subscriptions()
        .page_size(page_size)
        .page_token(page_token)
        .send()
        .await;
    ```*/
    pub fn list_webhook_subscriptions(&self) -> builder::ListWebhookSubscriptions<'_> {
        builder::ListWebhookSubscriptions::new(self)
    }
    /**Create webhook subscription

    Subscribe to real-time events across CDP products using flexible filtering.

    ### Event Types

    **Onchain Events** - Monitor Base mainnet with microsecond precision:
    - `onchain.activity.detected` - Smart contract events, transfers, swaps, NFT activity
    - **Requires** `labels` for filtering (e.g., `contract_address`, `event_name`)

    **Onramp/Offramp Events** - Transaction lifecycle notifications:
    - `onramp.transaction.created`, `onramp.transaction.updated`
    - `onramp.transaction.success`, `onramp.transaction.failed`
    - `offramp.transaction.created`, `offramp.transaction.updated`
    - `offramp.transaction.success`, `offramp.transaction.failed`
    - **No labels required** - maximum simplicity for transaction monitoring

    **Wallet Events** - Wallet activity notifications:
    - `wallet.activity.detected`

    ### Webhook Signature Verification
    All webhooks include cryptographic signatures for security.
    The signature secret is returned in `metadata.secret` when creating a subscription.

    **Note:** Webhooks are in beta and this interface is subject to change.

    See the [verification guide](https://docs.cdp.coinbase.com/onramp-&-offramp/webhooks#webhook-signature-verification) for implementation details.

    ### Onchain Label Filtering

    For `onchain.activity.detected` events, use `labels` for precise filtering with AND logic (max 20 labels per webhook).

    **Allowed labels** (all in snake_case format):
    - `network` (required) - Blockchain network
    - `contract_address` - Smart contract address
    - `event_name` - Event name (e.g., "Transfer", "Burn")
    - `event_signature` - Event signature hash
    - `transaction_from` - Transaction sender address
    - `transaction_to` - Transaction recipient address
    - `params.*` - Any event parameter (e.g., `params.from`, `params.to`, `params.sender`, `params.tokenId`)

    **Examples**:
    - **Liquidity Pool Monitor**: `{"network": "base-mainnet", "contract_address": "0xcd1f9777571493aeacb7eae45cd30a226d3e612d", "event_name": "Burn"}`
    - **Price Oracle Tracker**: `{"network": "base-mainnet", "contract_address": "0xbac4a9428ea707c51f171ed9890c3c2fa810305d", "event_name": "PriceUpdated"}`
    - **DeFi Protocol Activity**: `{"network": "base-mainnet", "contract_address": "0x45c6e6a47a711b14d8357d5243f46704904578e3", "event_name": "Deposit"}`


    Sends a `POST` request to `/v2/data/webhooks/subscriptions`

    ```ignore
    let response = client.create_webhook_subscription()
        .body(body)
        .send()
        .await;
    ```*/
    pub fn create_webhook_subscription(&self) -> builder::CreateWebhookSubscription<'_> {
        builder::CreateWebhookSubscription::new(self)
    }
    /**Get webhook subscription details

    Retrieve detailed information about a specific webhook subscription including
    configuration, status, creation timestamp, and webhook signature secret.

    ### Response Includes
    - Subscription configuration and filters
    - Target URL and custom headers
    - Webhook signature secret for verification
    - Creation timestamp and status


    Sends a `GET` request to `/v2/data/webhooks/subscriptions/{subscriptionId}`

    Arguments:
    - `subscription_id`: Unique identifier for the webhook subscription.
    ```ignore
    let response = client.get_webhook_subscription()
        .subscription_id(subscription_id)
        .send()
        .await;
    ```*/
    pub fn get_webhook_subscription(&self) -> builder::GetWebhookSubscription<'_> {
        builder::GetWebhookSubscription::new(self)
    }
    /**Update webhook subscription

    Update an existing webhook subscription's configuration including
    event types, target URL, filtering criteria, and enabled status.
    All required fields must be provided, even if they are not being changed.

    ### Common Updates
    - Change target URL or headers
    - Add/remove event type filters
    - Update multi-label filtering criteria
    - Enable/disable subscription


    Sends a `PUT` request to `/v2/data/webhooks/subscriptions/{subscriptionId}`

    Arguments:
    - `subscription_id`: Unique identifier for the webhook subscription.
    - `body`
    ```ignore
    let response = client.update_webhook_subscription()
        .subscription_id(subscription_id)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn update_webhook_subscription(&self) -> builder::UpdateWebhookSubscription<'_> {
        builder::UpdateWebhookSubscription::new(self)
    }
    /**Delete webhook subscription

    Permanently delete a webhook subscription and stop all event deliveries.
    This action cannot be undone.

    ### Important Notes
    - All webhook deliveries will cease immediately
    - Subscription cannot be recovered after deletion
    - Consider disabling instead of deleting for temporary pauses


    Sends a `DELETE` request to `/v2/data/webhooks/subscriptions/{subscriptionId}`

    Arguments:
    - `subscription_id`: Unique identifier for the webhook subscription.
    ```ignore
    let response = client.delete_webhook_subscription()
        .subscription_id(subscription_id)
        .send()
        .await;
    ```*/
    pub fn delete_webhook_subscription(&self) -> builder::DeleteWebhookSubscription<'_> {
        builder::DeleteWebhookSubscription::new(self)
    }
    /**List end users

    Lists the end users belonging to the developer's CDP Project.
    By default, the response is sorted by creation date in ascending order and paginated to 20 users per page.

    Sends a `GET` request to `/v2/end-users`

    Arguments:
    - `page_size`: The number of end users to return per page.
    - `page_token`: The token for the desired page of end users. Will be empty if there are no more end users to fetch.
    - `sort`: Sort end users. Defaults to ascending order (oldest first).
    ```ignore
    let response = client.list_end_users()
        .page_size(page_size)
        .page_token(page_token)
        .sort(sort)
        .send()
        .await;
    ```*/
    pub fn list_end_users(&self) -> builder::ListEndUsers<'_> {
        builder::ListEndUsers::new(self)
    }
    /**Create an end user

    Creates an end user. An end user is an entity that can own CDP EVM accounts, EVM smart accounts, and/or Solana accounts. 1 or more authentication methods must be associated with an end user. By default, no accounts are created unless the optional `evmAccount` and/or `solanaAccount` fields are provided.
    This API is intended to be used by the developer's own backend, and is authenticated using the developer's CDP API key.

    Sends a `POST` request to `/v2/end-users`

    Arguments:
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.create_end_user()
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn create_end_user(&self) -> builder::CreateEndUser<'_> {
        builder::CreateEndUser::new(self)
    }
    /**Validate end user access token

    Validates the end user's access token and returns the end user's information. Returns an error if the access token is invalid or expired.

    This API is intended to be used by the developer's own backend, and is authenticated using the developer's CDP API key.

    Sends a `POST` request to `/v2/end-users/auth/validate-token`

    ```ignore
    let response = client.validate_end_user_access_token()
        .body(body)
        .send()
        .await;
    ```*/
    pub fn validate_end_user_access_token(&self) -> builder::ValidateEndUserAccessToken<'_> {
        builder::ValidateEndUserAccessToken::new(self)
    }
    /**Get an end user

    Gets an end user by ID.

    This API is intended to be used by the developer's own backend, and is authenticated using the developer's CDP API key.

    Sends a `GET` request to `/v2/end-users/{userId}`

    Arguments:
    - `user_id`: The ID of the end user to get.
    ```ignore
    let response = client.get_end_user()
        .user_id(user_id)
        .send()
        .await;
    ```*/
    pub fn get_end_user(&self) -> builder::GetEndUser<'_> {
        builder::GetEndUser::new(self)
    }
    /**List EVM accounts

    Lists the EVM accounts belonging to the developer's CDP Project.
    The response is paginated, and by default, returns 20 accounts per page.

    Sends a `GET` request to `/v2/evm/accounts`

    Arguments:
    - `page_size`: The number of resources to return per page.
    - `page_token`: The token for the next page of resources, if any.
    ```ignore
    let response = client.list_evm_accounts()
        .page_size(page_size)
        .page_token(page_token)
        .send()
        .await;
    ```*/
    pub fn list_evm_accounts(&self) -> builder::ListEvmAccounts<'_> {
        builder::ListEvmAccounts::new(self)
    }
    /**Create an EVM account

    Creates a new EVM account.

    Sends a `POST` request to `/v2/evm/accounts`

    Arguments:
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.create_evm_account()
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn create_evm_account(&self) -> builder::CreateEvmAccount<'_> {
        builder::CreateEvmAccount::new(self)
    }
    /**Get an EVM account by name

    Gets an EVM account by its name.

    Sends a `GET` request to `/v2/evm/accounts/by-name/{name}`

    Arguments:
    - `name`: The name of the EVM account.
    ```ignore
    let response = client.get_evm_account_by_name()
        .name(name)
        .send()
        .await;
    ```*/
    pub fn get_evm_account_by_name(&self) -> builder::GetEvmAccountByName<'_> {
        builder::GetEvmAccountByName::new(self)
    }
    /**Export an EVM account by name

    Export an existing EVM account's private key by its name. It is important to store the private key in a secure place after it's exported.

    Sends a `POST` request to `/v2/evm/accounts/export/by-name/{name}`

    Arguments:
    - `name`: The name of the EVM account.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.export_evm_account_by_name()
        .name(name)
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn export_evm_account_by_name(&self) -> builder::ExportEvmAccountByName<'_> {
        builder::ExportEvmAccountByName::new(self)
    }
    /**Import an EVM account

    Import an existing EVM account into the developer's CDP Project. This API should be called from the [CDP SDK](https://github.com/coinbase/cdp-sdk) to ensure that the associated private key is properly encrypted.

    Sends a `POST` request to `/v2/evm/accounts/import`

    Arguments:
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.import_evm_account()
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn import_evm_account(&self) -> builder::ImportEvmAccount<'_> {
        builder::ImportEvmAccount::new(self)
    }
    /**Get an EVM account by address

    Gets an EVM account by its address.

    Sends a `GET` request to `/v2/evm/accounts/{address}`

    Arguments:
    - `address`: The 0x-prefixed address of the EVM account. The address does not need to be checksummed.
    ```ignore
    let response = client.get_evm_account()
        .address(address)
        .send()
        .await;
    ```*/
    pub fn get_evm_account(&self) -> builder::GetEvmAccount<'_> {
        builder::GetEvmAccount::new(self)
    }
    /**Update an EVM account

    Updates an existing EVM account. Use this to update the account's name or account-level policy.

    Sends a `PUT` request to `/v2/evm/accounts/{address}`

    Arguments:
    - `address`: The 0x-prefixed address of the EVM account. The address does not need to be checksummed.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `body`
    ```ignore
    let response = client.update_evm_account()
        .address(address)
        .x_idempotency_key(x_idempotency_key)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn update_evm_account(&self) -> builder::UpdateEvmAccount<'_> {
        builder::UpdateEvmAccount::new(self)
    }
    /**Export an EVM account

    Export an existing EVM account's private key. It is important to store the private key in a secure place after it's exported.

    Sends a `POST` request to `/v2/evm/accounts/{address}/export`

    Arguments:
    - `address`: The 0x-prefixed address of the EVM account. The address does not need to be checksummed.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.export_evm_account()
        .address(address)
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn export_evm_account(&self) -> builder::ExportEvmAccount<'_> {
        builder::ExportEvmAccount::new(self)
    }
    /**Send a transaction

    Signs a transaction with the given EVM account and sends it to the indicated supported network. This API handles nonce management and gas estimation, leaving the developer to provide only the minimal set of fields necessary to send the transaction. The transaction should be serialized as a hex string using [RLP](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/).

    The transaction must be an [EIP-1559 dynamic fee transaction](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md).


    **Transaction fields and API behavior**

    - `to` *(Required)*: The address of the contract or account to send the transaction to.
    - `chainId` *(Ignored)*: The value of the `chainId` field in the transaction is ignored.
      The transaction will be sent to the network indicated by the `network` field in the request body.

    - `nonce` *(Optional)*: The nonce to use for the transaction. If not provided, the API will assign
       a nonce to the transaction based on the current state of the account.

    - `maxPriorityFeePerGas` *(Optional)*: The maximum priority fee per gas to use for the transaction.
       If not provided, the API will estimate a value based on current network conditions.

    - `maxFeePerGas` *(Optional)*: The maximum fee per gas to use for the transaction.
       If not provided, the API will estimate a value based on current network conditions.

    - `gasLimit` *(Optional)*: The gas limit to use for the transaction. If not provided, the API will estimate a value
      based on the `to` and `data` fields of the transaction.

    - `value` *(Optional)*: The amount of ETH, in wei, to send with the transaction.
    - `data` *(Optional)*: The data to send with the transaction; only used for contract calls.
    - `accessList` *(Optional)*: The access list to use for the transaction.

    Sends a `POST` request to `/v2/evm/accounts/{address}/send/transaction`

    Arguments:
    - `address`: The 0x-prefixed address of the Ethereum account.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.send_evm_transaction()
        .address(address)
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn send_evm_transaction(&self) -> builder::SendEvmTransaction<'_> {
        builder::SendEvmTransaction::new(self)
    }
    /**Sign a hash

    Signs an arbitrary 32 byte hash with the given EVM account.

    Sends a `POST` request to `/v2/evm/accounts/{address}/sign`

    Arguments:
    - `address`: The 0x-prefixed address of the EVM account.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.sign_evm_hash()
        .address(address)
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn sign_evm_hash(&self) -> builder::SignEvmHash<'_> {
        builder::SignEvmHash::new(self)
    }
    /**Sign an EIP-191 message

    Signs an [EIP-191](https://eips.ethereum.org/EIPS/eip-191) message with the given EVM account.

    Per the specification, the message in the request body is prepended with `0x19 <0x45 (E)> <thereum Signed Message:\n" + len(message)>` before being signed.

    Sends a `POST` request to `/v2/evm/accounts/{address}/sign/message`

    Arguments:
    - `address`: The 0x-prefixed address of the EVM account.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.sign_evm_message()
        .address(address)
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn sign_evm_message(&self) -> builder::SignEvmMessage<'_> {
        builder::SignEvmMessage::new(self)
    }
    /**Sign a transaction

    Signs a transaction with the given EVM account.
    The transaction should be serialized as a hex string using [RLP](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/).

    The transaction must be an [EIP-1559 dynamic fee transaction](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md). The developer is responsible for ensuring that the unsigned transaction is valid, as the API will not validate the transaction.

    Sends a `POST` request to `/v2/evm/accounts/{address}/sign/transaction`

    Arguments:
    - `address`: The 0x-prefixed address of the EVM account.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.sign_evm_transaction()
        .address(address)
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn sign_evm_transaction(&self) -> builder::SignEvmTransaction<'_> {
        builder::SignEvmTransaction::new(self)
    }
    /**Sign EIP-712 typed data

    Signs [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data with the given EVM account.

    Sends a `POST` request to `/v2/evm/accounts/{address}/sign/typed-data`

    Arguments:
    - `address`: The 0x-prefixed address of the EVM account.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.sign_evm_typed_data()
        .address(address)
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn sign_evm_typed_data(&self) -> builder::SignEvmTypedData<'_> {
        builder::SignEvmTypedData::new(self)
    }
    /**Request funds on EVM test networks

    Request funds from the CDP Faucet on supported EVM test networks.

    Faucets are available for ETH, USDC, EURC, and cbBTC on Base Sepolia and Ethereum Sepolia, and for ETH only on Ethereum Hoodi.

    To prevent abuse, we enforce rate limits within a rolling 24-hour window to control the amount of funds that can be requested.
    These limits are applied at both the CDP User level and the blockchain address level.
    A single blockchain address cannot exceed the specified limits, even if multiple users submit requests to the same address.

    | Token | Amount per Faucet Request |Rolling 24-hour window Rate Limits|
    |:-----:|:-------------------------:|:--------------------------------:|
    | ETH   | 0.0001 ETH                | 0.1 ETH                          |
    | USDC  | 1 USDC                    | 10 USDC                          |
    | EURC  | 1 EURC                    | 10 EURC                          |
    | cbBTC | 0.0001 cbBTC              | 0.001 cbBTC                      |


    Sends a `POST` request to `/v2/evm/faucet`

    ```ignore
    let response = client.request_evm_faucet()
        .body(body)
        .send()
        .await;
    ```*/
    pub fn request_evm_faucet(&self) -> builder::RequestEvmFaucet<'_> {
        builder::RequestEvmFaucet::new(self)
    }
    /**List Smart Accounts

    Lists the Smart Accounts belonging to the developer's CDP Project.
    The response is paginated, and by default, returns 20 accounts per page.

    Sends a `GET` request to `/v2/evm/smart-accounts`

    Arguments:
    - `page_size`: The number of resources to return per page.
    - `page_token`: The token for the next page of resources, if any.
    ```ignore
    let response = client.list_evm_smart_accounts()
        .page_size(page_size)
        .page_token(page_token)
        .send()
        .await;
    ```*/
    pub fn list_evm_smart_accounts(&self) -> builder::ListEvmSmartAccounts<'_> {
        builder::ListEvmSmartAccounts::new(self)
    }
    /**Create a Smart Account

    Creates a new Smart Account.

    Sends a `POST` request to `/v2/evm/smart-accounts`

    Arguments:
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `body`
    ```ignore
    let response = client.create_evm_smart_account()
        .x_idempotency_key(x_idempotency_key)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn create_evm_smart_account(&self) -> builder::CreateEvmSmartAccount<'_> {
        builder::CreateEvmSmartAccount::new(self)
    }
    /**Get a Smart Account by name

    Gets a Smart Account by its name.

    Sends a `GET` request to `/v2/evm/smart-accounts/by-name/{name}`

    Arguments:
    - `name`: The name of the Smart Account.
    ```ignore
    let response = client.get_evm_smart_account_by_name()
        .name(name)
        .send()
        .await;
    ```*/
    pub fn get_evm_smart_account_by_name(&self) -> builder::GetEvmSmartAccountByName<'_> {
        builder::GetEvmSmartAccountByName::new(self)
    }
    /**Get a Smart Account by address

    Gets a Smart Account by its address.

    Sends a `GET` request to `/v2/evm/smart-accounts/{address}`

    Arguments:
    - `address`: The 0x-prefixed address of the Smart Account.
    ```ignore
    let response = client.get_evm_smart_account()
        .address(address)
        .send()
        .await;
    ```*/
    pub fn get_evm_smart_account(&self) -> builder::GetEvmSmartAccount<'_> {
        builder::GetEvmSmartAccount::new(self)
    }
    /**Update an EVM Smart Account

    Updates an existing EVM smart account. Use this to update the smart account's name.

    Sends a `PUT` request to `/v2/evm/smart-accounts/{address}`

    Arguments:
    - `address`: The 0x-prefixed address of the EVM smart account. The address does not need to be checksummed.
    - `body`
    ```ignore
    let response = client.update_evm_smart_account()
        .address(address)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn update_evm_smart_account(&self) -> builder::UpdateEvmSmartAccount<'_> {
        builder::UpdateEvmSmartAccount::new(self)
    }
    /**Create a spend permission

    Creates a spend permission for the given smart account address.

    Sends a `POST` request to `/v2/evm/smart-accounts/{address}/spend-permissions`

    Arguments:
    - `address`: The address of the Smart Account to create the spend permission for.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.create_spend_permission()
        .address(address)
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn create_spend_permission(&self) -> builder::CreateSpendPermission<'_> {
        builder::CreateSpendPermission::new(self)
    }
    /**List spend permissions

    Lists spend permission for the given smart account address.

    Sends a `GET` request to `/v2/evm/smart-accounts/{address}/spend-permissions/list`

    Arguments:
    - `address`: The address of the Smart account to list spend permissions for.
    - `page_size`: The number of spend permissions to return per page.
    - `page_token`: The token for the next page of spend permissions. Will be empty if there are no more spend permissions to fetch.
    ```ignore
    let response = client.list_spend_permissions()
        .address(address)
        .page_size(page_size)
        .page_token(page_token)
        .send()
        .await;
    ```*/
    pub fn list_spend_permissions(&self) -> builder::ListSpendPermissions<'_> {
        builder::ListSpendPermissions::new(self)
    }
    /**Revoke a spend permission

    Revokes an existing spend permission.

    Sends a `POST` request to `/v2/evm/smart-accounts/{address}/spend-permissions/revoke`

    Arguments:
    - `address`: The address of the Smart account this spend permission is valid for.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.revoke_spend_permission()
        .address(address)
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn revoke_spend_permission(&self) -> builder::RevokeSpendPermission<'_> {
        builder::RevokeSpendPermission::new(self)
    }
    /**Prepare a user operation

    Prepares a new user operation on a Smart Account for a specific network.

    Sends a `POST` request to `/v2/evm/smart-accounts/{address}/user-operations`

    Arguments:
    - `address`: The address of the Smart Account to create the user operation on.
    - `body`
    ```ignore
    let response = client.prepare_user_operation()
        .address(address)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn prepare_user_operation(&self) -> builder::PrepareUserOperation<'_> {
        builder::PrepareUserOperation::new(self)
    }
    /**Prepare and send a user operation for EVM Smart Account

    Prepares, signs, and sends a user operation for an EVM Smart Account. This API can be used only if the owner on Smart Account is a CDP EVM Account.

    Sends a `POST` request to `/v2/evm/smart-accounts/{address}/user-operations/prepare-and-send`

    Arguments:
    - `address`: The address of the EVM Smart Account to execute the user operation from.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.prepare_and_send_user_operation()
        .address(address)
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn prepare_and_send_user_operation(&self) -> builder::PrepareAndSendUserOperation<'_> {
        builder::PrepareAndSendUserOperation::new(self)
    }
    /**Get a user operation

    Gets a user operation by its hash.

    Sends a `GET` request to `/v2/evm/smart-accounts/{address}/user-operations/{userOpHash}`

    Arguments:
    - `address`: The address of the Smart Account the user operation belongs to.
    - `user_op_hash`: The hash of the user operation to fetch.
    ```ignore
    let response = client.get_user_operation()
        .address(address)
        .user_op_hash(user_op_hash)
        .send()
        .await;
    ```*/
    pub fn get_user_operation(&self) -> builder::GetUserOperation<'_> {
        builder::GetUserOperation::new(self)
    }
    /**Send a user operation

    Sends a user operation with a signature.
    The payload to sign must be the `userOpHash` field of the user operation. This hash should be signed directly (not using `personal_sign` or EIP-191 message hashing).
    The signature must be 65 bytes in length, consisting of: - 32 bytes for the `r` value - 32 bytes for the `s` value - 1 byte for the `v` value (must be 27 or 28)
    If using the CDP Paymaster, the user operation must be signed and sent within 2 minutes of being prepared.

    Sends a `POST` request to `/v2/evm/smart-accounts/{address}/user-operations/{userOpHash}/send`

    Arguments:
    - `address`: The address of the Smart Account to send the user operation from.
    - `user_op_hash`: The hash of the user operation to send.
    - `body`
    ```ignore
    let response = client.send_user_operation()
        .address(address)
        .user_op_hash(user_op_hash)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn send_user_operation(&self) -> builder::SendUserOperation<'_> {
        builder::SendUserOperation::new(self)
    }
    /**Create a swap quote

    Create a swap quote, which includes the payload to sign as well as the transaction data needed to execute the swap. The developer is responsible for signing the payload and submitting the transaction to the network in order to execute the swap.

    Sends a `POST` request to `/v2/evm/swaps`

    Arguments:
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `body`
    ```ignore
    let response = client.create_evm_swap_quote()
        .x_idempotency_key(x_idempotency_key)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn create_evm_swap_quote(&self) -> builder::CreateEvmSwapQuote<'_> {
        builder::CreateEvmSwapQuote::new(self)
    }
    /**Get a price estimate for a swap

    Get a price estimate for a swap between two tokens on an EVM network.

    Sends a `GET` request to `/v2/evm/swaps/quote`

    ```ignore
    let response = client.get_evm_swap_price()
        .from_amount(from_amount)
        .from_token(from_token)
        .gas_price(gas_price)
        .network(network)
        .signer_address(signer_address)
        .slippage_bps(slippage_bps)
        .taker(taker)
        .to_token(to_token)
        .send()
        .await;
    ```*/
    pub fn get_evm_swap_price(&self) -> builder::GetEvmSwapPrice<'_> {
        builder::GetEvmSwapPrice::new(self)
    }
    /**List EVM token balances

    Lists the token balances of an EVM address on a given network. The balances include ERC-20 tokens and the native gas token (usually ETH). The response is paginated, and by default, returns 20 balances per page.
    **Note:** This endpoint is still under development and does not yet provide strong freshness guarantees. Specifically, balances of new tokens can, on occasion, take up to ~30 seconds to appear, while balances of tokens already belonging to an address will generally be close to chain tip. Freshness of new token balances will improve over the coming weeks.

    Sends a `GET` request to `/v2/evm/token-balances/{network}/{address}`

    Arguments:
    - `network`: The human-readable network name to get the balances for.
    - `address`: The 0x-prefixed EVM address to get balances for. The address does not need to be checksummed.
    - `page_size`: The number of resources to return per page.
    - `page_token`: The token for the next page of resources, if any.
    ```ignore
    let response = client.list_evm_token_balances()
        .network(network)
        .address(address)
        .page_size(page_size)
        .page_token(page_token)
        .send()
        .await;
    ```*/
    pub fn list_evm_token_balances(&self) -> builder::ListEvmTokenBalances<'_> {
        builder::ListEvmTokenBalances::new(self)
    }
    /**Create an onramp order

    Create a new Onramp order or get a quote for an Onramp order. Either `paymentAmount` or `purchaseAmount` must be provided.

    This API currently only supports the payment method `GUEST_CHECKOUT_APPLE_PAY`.

    For detailed integration instructions and to get access to this API, refer to the  [Apple Pay Onramp API docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/apple-pay-onramp-api).

    Sends a `POST` request to `/v2/onramp/orders`

    ```ignore
    let response = client.create_onramp_order()
        .body(body)
        .send()
        .await;
    ```*/
    pub fn create_onramp_order(&self) -> builder::CreateOnrampOrder<'_> {
        builder::CreateOnrampOrder::new(self)
    }
    /**Get an onramp order by ID

    Get an onramp order by ID.

    Sends a `GET` request to `/v2/onramp/orders/{orderId}`

    Arguments:
    - `order_id`: The ID of the onramp order to retrieve.
    ```ignore
    let response = client.get_onramp_order_by_id()
        .order_id(order_id)
        .send()
        .await;
    ```*/
    pub fn get_onramp_order_by_id(&self) -> builder::GetOnrampOrderById<'_> {
        builder::GetOnrampOrderById::new(self)
    }
    /**Create an onramp session

    Returns a single-use URL for an Onramp session. This API provides flexible  functionality based on the parameters provided, supporting three cases:

    **Important**: The returned URL is single-use only. Once a user visits the URL,  no one else can access it.
    ## Use Cases
    ### 1. Basic Session (Minimum Parameters)
    **Required**: `destinationAddress`, `purchaseCurrency`, `destinationNetwork`

    **Returns**: Basic single-use onramp URL. The `quote` object will not be included in the response.
    ### 2. One-Click Onramp URL
    **Required**: Basic parameters + `paymentAmount`, `paymentCurrency`

    **Returns**: One-click onramp URL for streamlined checkout. The `quote` object will not be included in the response.
    ### 3. One-Click Onramp URL with Quote
    **Required**: One-Click Onramp parameters + `paymentMethod`, `country`, `subdivision`

    **Returns**: Complete pricing quote and one-click onramp URL. Both `session` and `quote` objects will be included in the response.

    Sends a `POST` request to `/v2/onramp/sessions`

    ```ignore
    let response = client.create_onramp_session()
        .body(body)
        .send()
        .await;
    ```*/
    pub fn create_onramp_session(&self) -> builder::CreateOnrampSession<'_> {
        builder::CreateOnrampSession::new(self)
    }
    /**List policies

    Lists the policies belonging to the developer's CDP Project. Use the `scope` parameter to filter the policies by scope.
    The response is paginated, and by default, returns 20 policies per page.

    Sends a `GET` request to `/v2/policy-engine/policies`

    Arguments:
    - `page_size`: The number of resources to return per page.
    - `page_token`: The token for the next page of resources, if any.
    - `scope`: The scope of the policies to return. If `project`, the response will include exactly one policy, which is the project-level policy. If `account`, the response will include all account-level policies for the developer's CDP Project.
    ```ignore
    let response = client.list_policies()
        .page_size(page_size)
        .page_token(page_token)
        .scope(scope)
        .send()
        .await;
    ```*/
    pub fn list_policies(&self) -> builder::ListPolicies<'_> {
        builder::ListPolicies::new(self)
    }
    /**Create a policy

    Create a policy that can be used to govern the behavior of accounts.

    Sends a `POST` request to `/v2/policy-engine/policies`

    Arguments:
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `body`
    ```ignore
    let response = client.create_policy()
        .x_idempotency_key(x_idempotency_key)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn create_policy(&self) -> builder::CreatePolicy<'_> {
        builder::CreatePolicy::new(self)
    }
    /**Get a policy by ID

    Get a policy by its ID.

    Sends a `GET` request to `/v2/policy-engine/policies/{policyId}`

    Arguments:
    - `policy_id`: The ID of the policy to get.
    ```ignore
    let response = client.get_policy_by_id()
        .policy_id(policy_id)
        .send()
        .await;
    ```*/
    pub fn get_policy_by_id(&self) -> builder::GetPolicyById<'_> {
        builder::GetPolicyById::new(self)
    }
    /**Update a policy

    Updates a policy by its ID. This will have the effect of applying the updated policy to all accounts that are currently using it.

    Sends a `PUT` request to `/v2/policy-engine/policies/{policyId}`

    Arguments:
    - `policy_id`: The ID of the policy to update.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `body`
    ```ignore
    let response = client.update_policy()
        .policy_id(policy_id)
        .x_idempotency_key(x_idempotency_key)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn update_policy(&self) -> builder::UpdatePolicy<'_> {
        builder::UpdatePolicy::new(self)
    }
    /**Delete a policy

    Delete a policy by its ID. This will have the effect of removing the policy from all accounts that are currently using it.

    Sends a `DELETE` request to `/v2/policy-engine/policies/{policyId}`

    Arguments:
    - `policy_id`: The ID of the policy to delete.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    ```ignore
    let response = client.delete_policy()
        .policy_id(policy_id)
        .x_idempotency_key(x_idempotency_key)
        .send()
        .await;
    ```*/
    pub fn delete_policy(&self) -> builder::DeletePolicy<'_> {
        builder::DeletePolicy::new(self)
    }
    /**List Solana accounts or get account by name

    Lists the Solana accounts belonging to the developer.
    The response is paginated, and by default, returns 20 accounts per page.

    If a name is provided, the response will contain only the account with that name.

    Sends a `GET` request to `/v2/solana/accounts`

    Arguments:
    - `page_size`: The number of resources to return per page.
    - `page_token`: The token for the next page of resources, if any.
    ```ignore
    let response = client.list_solana_accounts()
        .page_size(page_size)
        .page_token(page_token)
        .send()
        .await;
    ```*/
    pub fn list_solana_accounts(&self) -> builder::ListSolanaAccounts<'_> {
        builder::ListSolanaAccounts::new(self)
    }
    /**Create a Solana account

    Creates a new Solana account.

    Sends a `POST` request to `/v2/solana/accounts`

    Arguments:
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.create_solana_account()
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn create_solana_account(&self) -> builder::CreateSolanaAccount<'_> {
        builder::CreateSolanaAccount::new(self)
    }
    /**Get a Solana account by name

    Gets a Solana account by its name.

    Sends a `GET` request to `/v2/solana/accounts/by-name/{name}`

    Arguments:
    - `name`: The name of the Solana account.
    ```ignore
    let response = client.get_solana_account_by_name()
        .name(name)
        .send()
        .await;
    ```*/
    pub fn get_solana_account_by_name(&self) -> builder::GetSolanaAccountByName<'_> {
        builder::GetSolanaAccountByName::new(self)
    }
    /**Export a Solana account by name

    Export an existing Solana account's private key by its name. It is important to store the private key in a secure place after it's exported.

    Sends a `POST` request to `/v2/solana/accounts/export/by-name/{name}`

    Arguments:
    - `name`: The name of the Solana account.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.export_solana_account_by_name()
        .name(name)
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn export_solana_account_by_name(&self) -> builder::ExportSolanaAccountByName<'_> {
        builder::ExportSolanaAccountByName::new(self)
    }
    /**Import a Solana account

    Import an existing Solana account into the developer's CDP Project. This API should be called from the [CDP SDK](https://github.com/coinbase/cdp-sdk) to ensure that the associated private key is properly encrypted.

    Sends a `POST` request to `/v2/solana/accounts/import`

    Arguments:
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.import_solana_account()
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn import_solana_account(&self) -> builder::ImportSolanaAccount<'_> {
        builder::ImportSolanaAccount::new(self)
    }
    /**Send a Solana transaction

    Signs and sends a single Solana transaction using multiple Solana accounts. The transaction may contain contain several instructions, each of which may require signatures from different account keys.

    The transaction should be serialized into a byte array and base64 encoded. The API handles recent blockhash management and fee estimation, leaving the developer to provide only the minimal set of fields necessary to send the transaction.

    **Transaction types**

    The following transaction types are supported:
    * [Legacy transactions](https://solana.com/developers/guides/advanced/versions#current-transaction-versions)
    * [Versioned transactions](https://solana.com/developers/guides/advanced/versions)

    **Instruction Batching**

    To batch multiple operations, include multiple instructions within a single transaction. All instructions within a transaction are executed atomically - if any instruction fails, the entire transaction fails and is rolled back.

    **Network Support**

    The following Solana networks are supported:
    * `solana` - Solana Mainnet
    * `solana-devnet` - Solana Devnet

    The developer is responsible for ensuring that the unsigned transaction is valid, as the API will not validate the transaction.

    Sends a `POST` request to `/v2/solana/accounts/send/transaction`

    Arguments:
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.send_solana_transaction()
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn send_solana_transaction(&self) -> builder::SendSolanaTransaction<'_> {
        builder::SendSolanaTransaction::new(self)
    }
    /**Get a Solana account by address

    Gets a Solana account by its address.

    Sends a `GET` request to `/v2/solana/accounts/{address}`

    Arguments:
    - `address`: The base58 encoded address of the Solana account.
    ```ignore
    let response = client.get_solana_account()
        .address(address)
        .send()
        .await;
    ```*/
    pub fn get_solana_account(&self) -> builder::GetSolanaAccount<'_> {
        builder::GetSolanaAccount::new(self)
    }
    /**Update a Solana account

    Updates an existing Solana account. Use this to update the account's name or account-level policy.

    Sends a `PUT` request to `/v2/solana/accounts/{address}`

    Arguments:
    - `address`: The base58 encoded address of the Solana account.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `body`
    ```ignore
    let response = client.update_solana_account()
        .address(address)
        .x_idempotency_key(x_idempotency_key)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn update_solana_account(&self) -> builder::UpdateSolanaAccount<'_> {
        builder::UpdateSolanaAccount::new(self)
    }
    /**Export an Solana account

    Export an existing Solana account's private key. It is important to store the private key in a secure place after it's exported.

    Sends a `POST` request to `/v2/solana/accounts/{address}/export`

    Arguments:
    - `address`: The base58 encoded address of the Solana account.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.export_solana_account()
        .address(address)
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn export_solana_account(&self) -> builder::ExportSolanaAccount<'_> {
        builder::ExportSolanaAccount::new(self)
    }
    /**Sign a message

    Signs an arbitrary message with the given Solana account.

    **WARNING:** Never sign a message that you didn't generate, as it can be an arbitrary transaction. For example, it might send all of your funds to an attacker.

    Sends a `POST` request to `/v2/solana/accounts/{address}/sign/message`

    Arguments:
    - `address`: The base58 encoded address of the Solana account.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.sign_solana_message()
        .address(address)
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn sign_solana_message(&self) -> builder::SignSolanaMessage<'_> {
        builder::SignSolanaMessage::new(self)
    }
    /**Sign a transaction

    Signs a transaction with the given Solana account.
    The unsigned transaction should be serialized into a byte array and then encoded as base64.

    **Transaction types**

    The following transaction types are supported:
    * [Legacy transactions](https://solana-labs.github.io/solana-web3.js/classes/Transaction.html)
    * [Versioned transactions](https://solana-labs.github.io/solana-web3.js/classes/VersionedTransaction.html)

    The developer is responsible for ensuring that the unsigned transaction is valid, as the API will not validate the transaction.

    Sends a `POST` request to `/v2/solana/accounts/{address}/sign/transaction`

    Arguments:
    - `address`: The base58 encoded address of the Solana account.
    - `x_idempotency_key`: An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
    When included, duplicate requests with the same key will return identical responses.
    Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.

    - `x_wallet_auth`: A JWT signed using your Wallet Secret, encoded in base64. Refer to the
    [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
    section of our Authentication docs for more details on how to generate your Wallet Token.

    - `body`
    ```ignore
    let response = client.sign_solana_transaction()
        .address(address)
        .x_idempotency_key(x_idempotency_key)
        .x_wallet_auth(x_wallet_auth)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn sign_solana_transaction(&self) -> builder::SignSolanaTransaction<'_> {
        builder::SignSolanaTransaction::new(self)
    }
    /**Request funds on Solana devnet

    Request funds from the CDP Faucet on Solana devnet.

    Faucets are available for SOL.

    To prevent abuse, we enforce rate limits within a rolling 24-hour window to control the amount of funds that can be requested.
    These limits are applied at both the CDP Project level and the blockchain address level.
    A single blockchain address cannot exceed the specified limits, even if multiple users submit requests to the same address.

    | Token | Amount per Faucet Request |Rolling 24-hour window Rate Limits|
    |:-----:|:-------------------------:|:--------------------------------:|
    | SOL   | 0.00125 SOL               | 0.0125 SOL                       |
    | USDC  | 1 USDC                    | 10 USDC                          |


    Sends a `POST` request to `/v2/solana/faucet`

    ```ignore
    let response = client.request_solana_faucet()
        .body(body)
        .send()
        .await;
    ```*/
    pub fn request_solana_faucet(&self) -> builder::RequestSolanaFaucet<'_> {
        builder::RequestSolanaFaucet::new(self)
    }
    /**List Solana token balances

    Lists the token balances of a Solana address on a given network. The balances include SPL tokens and the native SOL token. The response is paginated, and by default, returns 20 balances per page.

    **Note:** This endpoint is still under development and does not yet provide strong availability or freshness guarantees. Freshness and availability of new token balances will improve over the coming weeks.

    Sends a `GET` request to `/v2/solana/token-balances/{network}/{address}`

    Arguments:
    - `network`: The human-readable network name to get the balances for.
    - `address`: The base58 encoded Solana address to get balances for.
    - `page_size`: The number of balances to return per page.
    - `page_token`: The token for the next page of balances. Will be empty if there are no more balances to fetch.
    ```ignore
    let response = client.list_solana_token_balances()
        .network(network)
        .address(address)
        .page_size(page_size)
        .page_token(page_token)
        .send()
        .await;
    ```*/
    pub fn list_solana_token_balances(&self) -> builder::ListSolanaTokenBalances<'_> {
        builder::ListSolanaTokenBalances::new(self)
    }
    /**Settle a payment

    Settle an x402 protocol payment with a specific scheme and network.

    Sends a `POST` request to `/v2/x402/settle`

    ```ignore
    let response = client.settle_x402_payment()
        .body(body)
        .send()
        .await;
    ```*/
    pub fn settle_x402_payment(&self) -> builder::SettleX402Payment<'_> {
        builder::SettleX402Payment::new(self)
    }
    /**Get supported payment schemes and networks

    Get the supported x402 protocol payment schemes and networks that the facilitator is able to verify and settle payments for.

    Sends a `GET` request to `/v2/x402/supported`

    ```ignore
    let response = client.supported_x402_payment_kinds()
        .send()
        .await;
    ```*/
    pub fn supported_x402_payment_kinds(&self) -> builder::SupportedX402PaymentKinds<'_> {
        builder::SupportedX402PaymentKinds::new(self)
    }
    /**Verify a payment

    Verify an x402 protocol payment with a specific scheme and network.

    Sends a `POST` request to `/v2/x402/verify`

    ```ignore
    let response = client.verify_x402_payment()
        .body(body)
        .send()
        .await;
    ```*/
    pub fn verify_x402_payment(&self) -> builder::VerifyX402Payment<'_> {
        builder::VerifyX402Payment::new(self)
    }
}
/// Types for composing operation parameters.
#[allow(clippy::all)]
pub mod builder {
    use super::types;
    #[allow(unused_imports)]
    use super::{
        encode_path, ByteStream, ClientHooks, ClientInfo, Error, OperationInfo, RequestBuilderExt,
        ResponseValue,
    };
    /**Builder for [`Client::list_data_token_balances`]

    [`Client::list_data_token_balances`]: super::Client::list_data_token_balances*/
    #[derive(Debug, Clone)]
    pub struct ListDataTokenBalances<'a> {
        client: &'a super::Client,
        network: Result<types::ListEvmTokenBalancesNetwork, String>,
        address: Result<types::ListDataTokenBalancesAddress, String>,
        page_size: Result<Option<i64>, String>,
        page_token: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListDataTokenBalances<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                network: Err("network was not initialized".to_string()),
                address: Err("address was not initialized".to_string()),
                page_size: Ok(None),
                page_token: Ok(None),
            }
        }
        pub fn network<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ListEvmTokenBalancesNetwork>,
        {
            self.network = value.try_into().map_err(|_| {
                "conversion to `ListEvmTokenBalancesNetwork` for network failed".to_string()
            });
            self
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ListDataTokenBalancesAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `ListDataTokenBalancesAddress` for address failed".to_string()
            });
            self
        }
        pub fn page_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.page_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for page_size failed".to_string());
            self
        }
        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/data/evm/token-balances/{network}/{address}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ListDataTokenBalancesResponse>, Error<types::Error>>
        {
            let Self {
                client,
                network,
                address,
                page_size,
                page_token,
            } = self;
            let network = network.map_err(Error::InvalidRequest)?;
            let address = address.map_err(Error::InvalidRequest)?;
            let page_size = page_size.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/data/evm/token-balances/{}/{}",
                client.baseurl,
                encode_path(&network.to_string()),
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageSize", &page_size,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageToken",
                    &page_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_data_token_balances",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::list_tokens_for_account`]

    [`Client::list_tokens_for_account`]: super::Client::list_tokens_for_account*/
    #[derive(Debug, Clone)]
    pub struct ListTokensForAccount<'a> {
        client: &'a super::Client,
        network: Result<types::ListTokensForAccountNetwork, String>,
        address: Result<types::ListTokensForAccountAddress, String>,
    }
    impl<'a> ListTokensForAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                network: Err("network was not initialized".to_string()),
                address: Err("address was not initialized".to_string()),
            }
        }
        pub fn network<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ListTokensForAccountNetwork>,
        {
            self.network = value.try_into().map_err(|_| {
                "conversion to `ListTokensForAccountNetwork` for network failed".to_string()
            });
            self
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ListTokensForAccountAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `ListTokensForAccountAddress` for address failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/data/evm/token-ownership/{network}/{address}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AccountTokenAddressesResponse>, Error<types::Error>>
        {
            let Self {
                client,
                network,
                address,
            } = self;
            let network = network.map_err(Error::InvalidRequest)?;
            let address = address.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/data/evm/token-ownership/{}/{}",
                client.baseurl,
                encode_path(&network.to_string()),
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_tokens_for_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::get_sql_grammar`]

    [`Client::get_sql_grammar`]: super::Client::get_sql_grammar*/
    #[derive(Debug, Clone)]
    pub struct GetSqlGrammar<'a> {
        client: &'a super::Client,
    }
    impl<'a> GetSqlGrammar<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        ///Sends a `GET` request to `/v2/data/query/grammar`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::string::String>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v2/data/query/grammar", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_sql_grammar",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                504u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::run_sql_query`]

    [`Client::run_sql_query`]: super::Client::run_sql_query*/
    #[derive(Debug, Clone)]
    pub struct RunSqlQuery<'a> {
        client: &'a super::Client,
        body: Result<types::builder::OnchainDataQuery, String>,
    }
    impl<'a> RunSqlQuery<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OnchainDataQuery>,
            <V as std::convert::TryInto<types::OnchainDataQuery>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `OnchainDataQuery` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::OnchainDataQuery,
            ) -> types::builder::OnchainDataQuery,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/data/query/run`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OnchainDataResult>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::OnchainDataQuery::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/data/query/run", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "run_sql_query",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                408u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                504u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::list_webhook_subscriptions`]

    [`Client::list_webhook_subscriptions`]: super::Client::list_webhook_subscriptions*/
    #[derive(Debug, Clone)]
    pub struct ListWebhookSubscriptions<'a> {
        client: &'a super::Client,
        page_size: Result<Option<::std::num::NonZeroU64>, String>,
        page_token: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListWebhookSubscriptions<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page_size: Ok(None),
                page_token: Ok(None),
            }
        }
        pub fn page_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU64>,
        {
            self.page_size = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU64` for page_size failed".to_string()
            });
            self
        }
        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/data/webhooks/subscriptions`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WebhookSubscriptionListResponse>, Error<types::Error>>
        {
            let Self {
                client,
                page_size,
                page_token,
            } = self;
            let page_size = page_size.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/data/webhooks/subscriptions", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageSize", &page_size,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageToken",
                    &page_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_webhook_subscriptions",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::create_webhook_subscription`]

    [`Client::create_webhook_subscription`]: super::Client::create_webhook_subscription*/
    #[derive(Debug, Clone)]
    pub struct CreateWebhookSubscription<'a> {
        client: &'a super::Client,
        body: Result<types::WebhookSubscriptionRequest, String>,
    }
    impl<'a> CreateWebhookSubscription<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Err("body was not initialized".to_string()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WebhookSubscriptionRequest>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `WebhookSubscriptionRequest` for body failed".to_string()
            });
            self
        }
        ///Sends a `POST` request to `/v2/data/webhooks/subscriptions`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WebhookSubscriptionResponse>, Error<types::Error>>
        {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/data/webhooks/subscriptions", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_webhook_subscription",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::get_webhook_subscription`]

    [`Client::get_webhook_subscription`]: super::Client::get_webhook_subscription*/
    #[derive(Debug, Clone)]
    pub struct GetWebhookSubscription<'a> {
        client: &'a super::Client,
        subscription_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> GetWebhookSubscription<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                subscription_id: Err("subscription_id was not initialized".to_string()),
            }
        }
        pub fn subscription_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.subscription_id = value.try_into().map_err(|_| {
                "conversion to `:: uuid :: Uuid` for subscription_id failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/data/webhooks/subscriptions/{subscriptionId}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WebhookSubscriptionResponse>, Error<types::Error>>
        {
            let Self {
                client,
                subscription_id,
            } = self;
            let subscription_id = subscription_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/data/webhooks/subscriptions/{}",
                client.baseurl,
                encode_path(&subscription_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_webhook_subscription",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::update_webhook_subscription`]

    [`Client::update_webhook_subscription`]: super::Client::update_webhook_subscription*/
    #[derive(Debug, Clone)]
    pub struct UpdateWebhookSubscription<'a> {
        client: &'a super::Client,
        subscription_id: Result<::uuid::Uuid, String>,
        body: Result<types::WebhookSubscriptionUpdateRequest, String>,
    }
    impl<'a> UpdateWebhookSubscription<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                subscription_id: Err("subscription_id was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }
        pub fn subscription_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.subscription_id = value.try_into().map_err(|_| {
                "conversion to `:: uuid :: Uuid` for subscription_id failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WebhookSubscriptionUpdateRequest>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `WebhookSubscriptionUpdateRequest` for body failed".to_string()
            });
            self
        }
        ///Sends a `PUT` request to `/v2/data/webhooks/subscriptions/{subscriptionId}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WebhookSubscriptionResponse>, Error<types::Error>>
        {
            let Self {
                client,
                subscription_id,
                body,
            } = self;
            let subscription_id = subscription_id.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/data/webhooks/subscriptions/{}",
                client.baseurl,
                encode_path(&subscription_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_webhook_subscription",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::delete_webhook_subscription`]

    [`Client::delete_webhook_subscription`]: super::Client::delete_webhook_subscription*/
    #[derive(Debug, Clone)]
    pub struct DeleteWebhookSubscription<'a> {
        client: &'a super::Client,
        subscription_id: Result<::uuid::Uuid, String>,
    }
    impl<'a> DeleteWebhookSubscription<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                subscription_id: Err("subscription_id was not initialized".to_string()),
            }
        }
        pub fn subscription_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.subscription_id = value.try_into().map_err(|_| {
                "conversion to `:: uuid :: Uuid` for subscription_id failed".to_string()
            });
            self
        }
        ///Sends a `DELETE` request to `/v2/data/webhooks/subscriptions/{subscriptionId}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                subscription_id,
            } = self;
            let subscription_id = subscription_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/data/webhooks/subscriptions/{}",
                client.baseurl,
                encode_path(&subscription_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "delete_webhook_subscription",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::list_end_users`]

    [`Client::list_end_users`]: super::Client::list_end_users*/
    #[derive(Debug, Clone)]
    pub struct ListEndUsers<'a> {
        client: &'a super::Client,
        page_size: Result<Option<::std::num::NonZeroU64>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort: Result<Option<::std::vec::Vec<types::ListEndUsersSortItem>>, String>,
    }
    impl<'a> ListEndUsers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page_size: Ok(None),
                page_token: Ok(None),
                sort: Ok(None),
            }
        }
        pub fn page_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU64>,
        {
            self.page_size = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU64` for page_size failed".to_string()
            });
            self
        }
        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }
        pub fn sort<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::vec::Vec<types::ListEndUsersSortItem>>,
        {
            self.sort = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: vec :: Vec < ListEndUsersSortItem >` for sort failed"
                    .to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/end-users`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ListEndUsersResponse>, Error<types::Error>> {
            let Self {
                client,
                page_size,
                page_token,
                sort,
            } = self;
            let page_size = page_size.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort = sort.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/end-users", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageSize", &page_size,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageToken",
                    &page_token,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "sort", &sort,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_end_users",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::create_end_user`]

    [`Client::create_end_user`]: super::Client::create_end_user*/
    #[derive(Debug, Clone)]
    pub struct CreateEndUser<'a> {
        client: &'a super::Client,
        x_idempotency_key: Result<Option<types::CreateEndUserXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::CreateEndUserBody, String>,
    }
    impl<'a> CreateEndUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateEndUserXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `CreateEndUserXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateEndUserBody>,
            <V as std::convert::TryInto<types::CreateEndUserBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreateEndUserBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CreateEndUserBody,
            ) -> types::builder::CreateEndUserBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/end-users`
        pub async fn send(self) -> Result<ResponseValue<types::EndUser>, Error<types::Error>> {
            let Self {
                client,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::CreateEndUserBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/end-users", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_end_user",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::validate_end_user_access_token`]

    [`Client::validate_end_user_access_token`]: super::Client::validate_end_user_access_token*/
    #[derive(Debug, Clone)]
    pub struct ValidateEndUserAccessToken<'a> {
        client: &'a super::Client,
        body: Result<types::builder::ValidateEndUserAccessTokenBody, String>,
    }
    impl<'a> ValidateEndUserAccessToken<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ValidateEndUserAccessTokenBody>,
            <V as std::convert::TryInto<types::ValidateEndUserAccessTokenBody>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `ValidateEndUserAccessTokenBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ValidateEndUserAccessTokenBody,
            ) -> types::builder::ValidateEndUserAccessTokenBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/end-users/auth/validate-token`
        pub async fn send(self) -> Result<ResponseValue<types::EndUser>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::ValidateEndUserAccessTokenBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/end-users/auth/validate-token", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "validate_end_user_access_token",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::get_end_user`]

    [`Client::get_end_user`]: super::Client::get_end_user*/
    #[derive(Debug, Clone)]
    pub struct GetEndUser<'a> {
        client: &'a super::Client,
        user_id: Result<types::GetEndUserUserId, String>,
    }
    impl<'a> GetEndUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                user_id: Err("user_id was not initialized".to_string()),
            }
        }
        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetEndUserUserId>,
        {
            self.user_id = value
                .try_into()
                .map_err(|_| "conversion to `GetEndUserUserId` for user_id failed".to_string());
            self
        }
        ///Sends a `GET` request to `/v2/end-users/{userId}`
        pub async fn send(self) -> Result<ResponseValue<types::EndUser>, Error<types::Error>> {
            let Self { client, user_id } = self;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/end-users/{}",
                client.baseurl,
                encode_path(&user_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_end_user",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::list_evm_accounts`]

    [`Client::list_evm_accounts`]: super::Client::list_evm_accounts*/
    #[derive(Debug, Clone)]
    pub struct ListEvmAccounts<'a> {
        client: &'a super::Client,
        page_size: Result<Option<i64>, String>,
        page_token: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListEvmAccounts<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page_size: Ok(None),
                page_token: Ok(None),
            }
        }
        pub fn page_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.page_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for page_size failed".to_string());
            self
        }
        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/evm/accounts`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ListEvmAccountsResponse>, Error<types::Error>> {
            let Self {
                client,
                page_size,
                page_token,
            } = self;
            let page_size = page_size.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/evm/accounts", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageSize", &page_size,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageToken",
                    &page_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_evm_accounts",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::create_evm_account`]

    [`Client::create_evm_account`]: super::Client::create_evm_account*/
    #[derive(Debug, Clone)]
    pub struct CreateEvmAccount<'a> {
        client: &'a super::Client,
        x_idempotency_key: Result<Option<types::CreateEvmAccountXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::CreateEvmAccountBody, String>,
    }
    impl<'a> CreateEvmAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateEvmAccountXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `CreateEvmAccountXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateEvmAccountBody>,
            <V as std::convert::TryInto<types::CreateEvmAccountBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateEvmAccountBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CreateEvmAccountBody,
            ) -> types::builder::CreateEvmAccountBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/accounts`
        pub async fn send(self) -> Result<ResponseValue<types::EvmAccount>, Error<types::Error>> {
            let Self {
                client,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::CreateEvmAccountBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/evm/accounts", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_evm_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::get_evm_account_by_name`]

    [`Client::get_evm_account_by_name`]: super::Client::get_evm_account_by_name*/
    #[derive(Debug, Clone)]
    pub struct GetEvmAccountByName<'a> {
        client: &'a super::Client,
        name: Result<::std::string::String, String>,
    }
    impl<'a> GetEvmAccountByName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                name: Err("name was not initialized".to_string()),
            }
        }
        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for name failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/evm/accounts/by-name/{name}`
        pub async fn send(self) -> Result<ResponseValue<types::EvmAccount>, Error<types::Error>> {
            let Self { client, name } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/accounts/by-name/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_evm_account_by_name",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::export_evm_account_by_name`]

    [`Client::export_evm_account_by_name`]: super::Client::export_evm_account_by_name*/
    #[derive(Debug, Clone)]
    pub struct ExportEvmAccountByName<'a> {
        client: &'a super::Client,
        name: Result<::std::string::String, String>,
        x_idempotency_key: Result<Option<types::ExportEvmAccountByNameXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::ExportEvmAccountByNameBody, String>,
    }
    impl<'a> ExportEvmAccountByName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                name: Err("name was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for name failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExportEvmAccountByNameXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExportEvmAccountByNameXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExportEvmAccountByNameBody>,
            <V as std::convert::TryInto<types::ExportEvmAccountByNameBody>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `ExportEvmAccountByNameBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ExportEvmAccountByNameBody,
            ) -> types::builder::ExportEvmAccountByNameBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/accounts/export/by-name/{name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ExportEvmAccountByNameResponse>, Error<types::Error>>
        {
            let Self {
                client,
                name,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::ExportEvmAccountByNameBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/accounts/export/by-name/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "export_evm_account_by_name",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::import_evm_account`]

    [`Client::import_evm_account`]: super::Client::import_evm_account*/
    #[derive(Debug, Clone)]
    pub struct ImportEvmAccount<'a> {
        client: &'a super::Client,
        x_idempotency_key: Result<Option<types::ImportEvmAccountXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::ImportEvmAccountBody, String>,
    }
    impl<'a> ImportEvmAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ImportEvmAccountXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `ImportEvmAccountXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ImportEvmAccountBody>,
            <V as std::convert::TryInto<types::ImportEvmAccountBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `ImportEvmAccountBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ImportEvmAccountBody,
            ) -> types::builder::ImportEvmAccountBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/accounts/import`
        pub async fn send(self) -> Result<ResponseValue<types::EvmAccount>, Error<types::Error>> {
            let Self {
                client,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ImportEvmAccountBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/evm/accounts/import", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "import_evm_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::get_evm_account`]

    [`Client::get_evm_account`]: super::Client::get_evm_account*/
    #[derive(Debug, Clone)]
    pub struct GetEvmAccount<'a> {
        client: &'a super::Client,
        address: Result<types::GetEvmAccountAddress, String>,
    }
    impl<'a> GetEvmAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetEvmAccountAddress>,
        {
            self.address = value
                .try_into()
                .map_err(|_| "conversion to `GetEvmAccountAddress` for address failed".to_string());
            self
        }
        ///Sends a `GET` request to `/v2/evm/accounts/{address}`
        pub async fn send(self) -> Result<ResponseValue<types::EvmAccount>, Error<types::Error>> {
            let Self { client, address } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/accounts/{}",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_evm_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::update_evm_account`]

    [`Client::update_evm_account`]: super::Client::update_evm_account*/
    #[derive(Debug, Clone)]
    pub struct UpdateEvmAccount<'a> {
        client: &'a super::Client,
        address: Result<types::UpdateEvmAccountAddress, String>,
        x_idempotency_key: Result<Option<types::UpdateEvmAccountXIdempotencyKey>, String>,
        body: Result<types::builder::UpdateEvmAccountBody, String>,
    }
    impl<'a> UpdateEvmAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateEvmAccountAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `UpdateEvmAccountAddress` for address failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateEvmAccountXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `UpdateEvmAccountXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateEvmAccountBody>,
            <V as std::convert::TryInto<types::UpdateEvmAccountBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpdateEvmAccountBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::UpdateEvmAccountBody,
            ) -> types::builder::UpdateEvmAccountBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `PUT` request to `/v2/evm/accounts/{address}`
        pub async fn send(self) -> Result<ResponseValue<types::EvmAccount>, Error<types::Error>> {
            let Self {
                client,
                address,
                x_idempotency_key,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::UpdateEvmAccountBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/accounts/{}",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_evm_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::export_evm_account`]

    [`Client::export_evm_account`]: super::Client::export_evm_account*/
    #[derive(Debug, Clone)]
    pub struct ExportEvmAccount<'a> {
        client: &'a super::Client,
        address: Result<types::ExportEvmAccountAddress, String>,
        x_idempotency_key: Result<Option<types::ExportEvmAccountXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::ExportEvmAccountBody, String>,
    }
    impl<'a> ExportEvmAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExportEvmAccountAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `ExportEvmAccountAddress` for address failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExportEvmAccountXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExportEvmAccountXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExportEvmAccountBody>,
            <V as std::convert::TryInto<types::ExportEvmAccountBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `ExportEvmAccountBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ExportEvmAccountBody,
            ) -> types::builder::ExportEvmAccountBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/accounts/{address}/export`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ExportEvmAccountResponse>, Error<types::Error>> {
            let Self {
                client,
                address,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ExportEvmAccountBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/accounts/{}/export",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "export_evm_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::send_evm_transaction`]

    [`Client::send_evm_transaction`]: super::Client::send_evm_transaction*/
    #[derive(Debug, Clone)]
    pub struct SendEvmTransaction<'a> {
        client: &'a super::Client,
        address: Result<types::SendEvmTransactionAddress, String>,
        x_idempotency_key: Result<Option<types::SendEvmTransactionXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::SendEvmTransactionBody, String>,
    }
    impl<'a> SendEvmTransaction<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SendEvmTransactionAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `SendEvmTransactionAddress` for address failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SendEvmTransactionXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `SendEvmTransactionXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SendEvmTransactionBody>,
            <V as std::convert::TryInto<types::SendEvmTransactionBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SendEvmTransactionBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SendEvmTransactionBody,
            ) -> types::builder::SendEvmTransactionBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/accounts/{address}/send/transaction`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SendEvmTransactionResponse>, Error<types::Error>> {
            let Self {
                client,
                address,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SendEvmTransactionBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/accounts/{}/send/transaction",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "send_evm_transaction",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                403u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::sign_evm_hash`]

    [`Client::sign_evm_hash`]: super::Client::sign_evm_hash*/
    #[derive(Debug, Clone)]
    pub struct SignEvmHash<'a> {
        client: &'a super::Client,
        address: Result<types::SignEvmHashAddress, String>,
        x_idempotency_key: Result<Option<types::SignEvmHashXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::SignEvmHashBody, String>,
    }
    impl<'a> SignEvmHash<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignEvmHashAddress>,
        {
            self.address = value
                .try_into()
                .map_err(|_| "conversion to `SignEvmHashAddress` for address failed".to_string());
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignEvmHashXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `SignEvmHashXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignEvmHashBody>,
            <V as std::convert::TryInto<types::SignEvmHashBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SignEvmHashBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SignEvmHashBody) -> types::builder::SignEvmHashBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/accounts/{address}/sign`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SignEvmHashResponse>, Error<types::Error>> {
            let Self {
                client,
                address,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SignEvmHashBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/accounts/{}/sign",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "sign_evm_hash",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::sign_evm_message`]

    [`Client::sign_evm_message`]: super::Client::sign_evm_message*/
    #[derive(Debug, Clone)]
    pub struct SignEvmMessage<'a> {
        client: &'a super::Client,
        address: Result<types::SignEvmMessageAddress, String>,
        x_idempotency_key: Result<Option<types::SignEvmMessageXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::SignEvmMessageBody, String>,
    }
    impl<'a> SignEvmMessage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignEvmMessageAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `SignEvmMessageAddress` for address failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignEvmMessageXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `SignEvmMessageXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignEvmMessageBody>,
            <V as std::convert::TryInto<types::SignEvmMessageBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SignEvmMessageBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SignEvmMessageBody,
            ) -> types::builder::SignEvmMessageBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/accounts/{address}/sign/message`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SignEvmMessageResponse>, Error<types::Error>> {
            let Self {
                client,
                address,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SignEvmMessageBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/accounts/{}/sign/message",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "sign_evm_message",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::sign_evm_transaction`]

    [`Client::sign_evm_transaction`]: super::Client::sign_evm_transaction*/
    #[derive(Debug, Clone)]
    pub struct SignEvmTransaction<'a> {
        client: &'a super::Client,
        address: Result<types::SignEvmTransactionAddress, String>,
        x_idempotency_key: Result<Option<types::SignEvmTransactionXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::SignEvmTransactionBody, String>,
    }
    impl<'a> SignEvmTransaction<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignEvmTransactionAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `SignEvmTransactionAddress` for address failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignEvmTransactionXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `SignEvmTransactionXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignEvmTransactionBody>,
            <V as std::convert::TryInto<types::SignEvmTransactionBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SignEvmTransactionBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SignEvmTransactionBody,
            ) -> types::builder::SignEvmTransactionBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/accounts/{address}/sign/transaction`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SignEvmTransactionResponse>, Error<types::Error>> {
            let Self {
                client,
                address,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SignEvmTransactionBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/accounts/{}/sign/transaction",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "sign_evm_transaction",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                403u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::sign_evm_typed_data`]

    [`Client::sign_evm_typed_data`]: super::Client::sign_evm_typed_data*/
    #[derive(Debug, Clone)]
    pub struct SignEvmTypedData<'a> {
        client: &'a super::Client,
        address: Result<types::SignEvmTypedDataAddress, String>,
        x_idempotency_key: Result<Option<types::SignEvmTypedDataXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::Eip712Message, String>,
    }
    impl<'a> SignEvmTypedData<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignEvmTypedDataAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `SignEvmTypedDataAddress` for address failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignEvmTypedDataXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `SignEvmTypedDataXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Eip712Message>,
            <V as std::convert::TryInto<types::Eip712Message>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `Eip712Message` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::Eip712Message) -> types::builder::Eip712Message,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/accounts/{address}/sign/typed-data`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SignEvmTypedDataResponse>, Error<types::Error>> {
            let Self {
                client,
                address,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::Eip712Message::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/accounts/{}/sign/typed-data",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "sign_evm_typed_data",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::request_evm_faucet`]

    [`Client::request_evm_faucet`]: super::Client::request_evm_faucet*/
    #[derive(Debug, Clone)]
    pub struct RequestEvmFaucet<'a> {
        client: &'a super::Client,
        body: Result<types::builder::RequestEvmFaucetBody, String>,
    }
    impl<'a> RequestEvmFaucet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RequestEvmFaucetBody>,
            <V as std::convert::TryInto<types::RequestEvmFaucetBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `RequestEvmFaucetBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::RequestEvmFaucetBody,
            ) -> types::builder::RequestEvmFaucetBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/faucet`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RequestEvmFaucetResponse>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::RequestEvmFaucetBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/evm/faucet", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "request_evm_faucet",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                403u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::list_evm_smart_accounts`]

    [`Client::list_evm_smart_accounts`]: super::Client::list_evm_smart_accounts*/
    #[derive(Debug, Clone)]
    pub struct ListEvmSmartAccounts<'a> {
        client: &'a super::Client,
        page_size: Result<Option<i64>, String>,
        page_token: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListEvmSmartAccounts<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page_size: Ok(None),
                page_token: Ok(None),
            }
        }
        pub fn page_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.page_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for page_size failed".to_string());
            self
        }
        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/evm/smart-accounts`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ListEvmSmartAccountsResponse>, Error<types::Error>>
        {
            let Self {
                client,
                page_size,
                page_token,
            } = self;
            let page_size = page_size.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/evm/smart-accounts", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageSize", &page_size,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageToken",
                    &page_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_evm_smart_accounts",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::create_evm_smart_account`]

    [`Client::create_evm_smart_account`]: super::Client::create_evm_smart_account*/
    #[derive(Debug, Clone)]
    pub struct CreateEvmSmartAccount<'a> {
        client: &'a super::Client,
        x_idempotency_key: Result<Option<types::CreateEvmSmartAccountXIdempotencyKey>, String>,
        body: Result<types::builder::CreateEvmSmartAccountBody, String>,
    }
    impl<'a> CreateEvmSmartAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                x_idempotency_key: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateEvmSmartAccountXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `CreateEvmSmartAccountXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateEvmSmartAccountBody>,
            <V as std::convert::TryInto<types::CreateEvmSmartAccountBody>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateEvmSmartAccountBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CreateEvmSmartAccountBody,
            ) -> types::builder::CreateEvmSmartAccountBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/smart-accounts`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::EvmSmartAccount>, Error<types::Error>> {
            let Self {
                client,
                x_idempotency_key,
                body,
            } = self;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::CreateEvmSmartAccountBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/evm/smart-accounts", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_evm_smart_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::get_evm_smart_account_by_name`]

    [`Client::get_evm_smart_account_by_name`]: super::Client::get_evm_smart_account_by_name*/
    #[derive(Debug, Clone)]
    pub struct GetEvmSmartAccountByName<'a> {
        client: &'a super::Client,
        name: Result<::std::string::String, String>,
    }
    impl<'a> GetEvmSmartAccountByName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                name: Err("name was not initialized".to_string()),
            }
        }
        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for name failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/evm/smart-accounts/by-name/{name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::EvmSmartAccount>, Error<types::Error>> {
            let Self { client, name } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/smart-accounts/by-name/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_evm_smart_account_by_name",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::get_evm_smart_account`]

    [`Client::get_evm_smart_account`]: super::Client::get_evm_smart_account*/
    #[derive(Debug, Clone)]
    pub struct GetEvmSmartAccount<'a> {
        client: &'a super::Client,
        address: Result<types::GetEvmSmartAccountAddress, String>,
    }
    impl<'a> GetEvmSmartAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetEvmSmartAccountAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `GetEvmSmartAccountAddress` for address failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/evm/smart-accounts/{address}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::EvmSmartAccount>, Error<types::Error>> {
            let Self { client, address } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/smart-accounts/{}",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_evm_smart_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::update_evm_smart_account`]

    [`Client::update_evm_smart_account`]: super::Client::update_evm_smart_account*/
    #[derive(Debug, Clone)]
    pub struct UpdateEvmSmartAccount<'a> {
        client: &'a super::Client,
        address: Result<types::UpdateEvmSmartAccountAddress, String>,
        body: Result<types::builder::UpdateEvmSmartAccountBody, String>,
    }
    impl<'a> UpdateEvmSmartAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateEvmSmartAccountAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `UpdateEvmSmartAccountAddress` for address failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateEvmSmartAccountBody>,
            <V as std::convert::TryInto<types::UpdateEvmSmartAccountBody>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpdateEvmSmartAccountBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::UpdateEvmSmartAccountBody,
            ) -> types::builder::UpdateEvmSmartAccountBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `PUT` request to `/v2/evm/smart-accounts/{address}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::EvmSmartAccount>, Error<types::Error>> {
            let Self {
                client,
                address,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::UpdateEvmSmartAccountBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/smart-accounts/{}",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_evm_smart_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::create_spend_permission`]

    [`Client::create_spend_permission`]: super::Client::create_spend_permission*/
    #[derive(Debug, Clone)]
    pub struct CreateSpendPermission<'a> {
        client: &'a super::Client,
        address: Result<types::CreateSpendPermissionAddress, String>,
        x_idempotency_key: Result<Option<types::CreateSpendPermissionXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::CreateSpendPermissionRequest, String>,
    }
    impl<'a> CreateSpendPermission<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateSpendPermissionAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `CreateSpendPermissionAddress` for address failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateSpendPermissionXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `CreateSpendPermissionXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateSpendPermissionRequest>,
            <V as std::convert::TryInto<types::CreateSpendPermissionRequest>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateSpendPermissionRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CreateSpendPermissionRequest,
            ) -> types::builder::CreateSpendPermissionRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/smart-accounts/{address}/spend-permissions`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::EvmUserOperation>, Error<types::Error>> {
            let Self {
                client,
                address,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::CreateSpendPermissionRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/smart-accounts/{}/spend-permissions",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_spend_permission",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::list_spend_permissions`]

    [`Client::list_spend_permissions`]: super::Client::list_spend_permissions*/
    #[derive(Debug, Clone)]
    pub struct ListSpendPermissions<'a> {
        client: &'a super::Client,
        address: Result<types::ListSpendPermissionsAddress, String>,
        page_size: Result<Option<i64>, String>,
        page_token: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListSpendPermissions<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                page_size: Ok(None),
                page_token: Ok(None),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ListSpendPermissionsAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `ListSpendPermissionsAddress` for address failed".to_string()
            });
            self
        }
        pub fn page_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.page_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for page_size failed".to_string());
            self
        }
        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/evm/smart-accounts/{address}/spend-permissions/list`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ListSpendPermissionsResponse>, Error<types::Error>>
        {
            let Self {
                client,
                address,
                page_size,
                page_token,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let page_size = page_size.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/smart-accounts/{}/spend-permissions/list",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageSize", &page_size,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageToken",
                    &page_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_spend_permissions",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::revoke_spend_permission`]

    [`Client::revoke_spend_permission`]: super::Client::revoke_spend_permission*/
    #[derive(Debug, Clone)]
    pub struct RevokeSpendPermission<'a> {
        client: &'a super::Client,
        address: Result<types::RevokeSpendPermissionAddress, String>,
        x_idempotency_key: Result<Option<types::RevokeSpendPermissionXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::RevokeSpendPermissionRequest, String>,
    }
    impl<'a> RevokeSpendPermission<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RevokeSpendPermissionAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `RevokeSpendPermissionAddress` for address failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RevokeSpendPermissionXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `RevokeSpendPermissionXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RevokeSpendPermissionRequest>,
            <V as std::convert::TryInto<types::RevokeSpendPermissionRequest>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `RevokeSpendPermissionRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::RevokeSpendPermissionRequest,
            ) -> types::builder::RevokeSpendPermissionRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/smart-accounts/{address}/spend-permissions/revoke`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::EvmUserOperation>, Error<types::Error>> {
            let Self {
                client,
                address,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::RevokeSpendPermissionRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/smart-accounts/{}/spend-permissions/revoke",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "revoke_spend_permission",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::prepare_user_operation`]

    [`Client::prepare_user_operation`]: super::Client::prepare_user_operation*/
    #[derive(Debug, Clone)]
    pub struct PrepareUserOperation<'a> {
        client: &'a super::Client,
        address: Result<types::PrepareUserOperationAddress, String>,
        body: Result<types::builder::PrepareUserOperationBody, String>,
    }
    impl<'a> PrepareUserOperation<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PrepareUserOperationAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `PrepareUserOperationAddress` for address failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PrepareUserOperationBody>,
            <V as std::convert::TryInto<types::PrepareUserOperationBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `PrepareUserOperationBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PrepareUserOperationBody,
            ) -> types::builder::PrepareUserOperationBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/smart-accounts/{address}/user-operations`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::EvmUserOperation>, Error<types::Error>> {
            let Self {
                client,
                address,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::PrepareUserOperationBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/smart-accounts/{}/user-operations",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "prepare_user_operation",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                403u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::prepare_and_send_user_operation`]

    [`Client::prepare_and_send_user_operation`]: super::Client::prepare_and_send_user_operation*/
    #[derive(Debug, Clone)]
    pub struct PrepareAndSendUserOperation<'a> {
        client: &'a super::Client,
        address: Result<types::PrepareAndSendUserOperationAddress, String>,
        x_idempotency_key:
            Result<Option<types::PrepareAndSendUserOperationXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::PrepareAndSendUserOperationBody, String>,
    }
    impl<'a> PrepareAndSendUserOperation<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PrepareAndSendUserOperationAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `PrepareAndSendUserOperationAddress` for address failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PrepareAndSendUserOperationXIdempotencyKey>,
        {
            self.x_idempotency_key = value
                .try_into()
                .map(Some)
                .map_err(|_| {
                    "conversion to `PrepareAndSendUserOperationXIdempotencyKey` for x_idempotency_key failed"
                        .to_string()
                });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PrepareAndSendUserOperationBody>,
            <V as std::convert::TryInto<types::PrepareAndSendUserOperationBody>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `PrepareAndSendUserOperationBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PrepareAndSendUserOperationBody,
            ) -> types::builder::PrepareAndSendUserOperationBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/smart-accounts/{address}/user-operations/prepare-and-send`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::EvmUserOperation>, Error<types::Error>> {
            let Self {
                client,
                address,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::PrepareAndSendUserOperationBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/smart-accounts/{}/user-operations/prepare-and-send",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "prepare_and_send_user_operation",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                403u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::get_user_operation`]

    [`Client::get_user_operation`]: super::Client::get_user_operation*/
    #[derive(Debug, Clone)]
    pub struct GetUserOperation<'a> {
        client: &'a super::Client,
        address: Result<types::GetUserOperationAddress, String>,
        user_op_hash: Result<types::GetUserOperationUserOpHash, String>,
    }
    impl<'a> GetUserOperation<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                user_op_hash: Err("user_op_hash was not initialized".to_string()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetUserOperationAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `GetUserOperationAddress` for address failed".to_string()
            });
            self
        }
        pub fn user_op_hash<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetUserOperationUserOpHash>,
        {
            self.user_op_hash = value.try_into().map_err(|_| {
                "conversion to `GetUserOperationUserOpHash` for user_op_hash failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/evm/smart-accounts/{address}/user-operations/{userOpHash}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::EvmUserOperation>, Error<types::Error>> {
            let Self {
                client,
                address,
                user_op_hash,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let user_op_hash = user_op_hash.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/smart-accounts/{}/user-operations/{}",
                client.baseurl,
                encode_path(&address.to_string()),
                encode_path(&user_op_hash.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_user_operation",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::send_user_operation`]

    [`Client::send_user_operation`]: super::Client::send_user_operation*/
    #[derive(Debug, Clone)]
    pub struct SendUserOperation<'a> {
        client: &'a super::Client,
        address: Result<types::SendUserOperationAddress, String>,
        user_op_hash: Result<types::SendUserOperationUserOpHash, String>,
        body: Result<types::builder::SendUserOperationBody, String>,
    }
    impl<'a> SendUserOperation<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                user_op_hash: Err("user_op_hash was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SendUserOperationAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `SendUserOperationAddress` for address failed".to_string()
            });
            self
        }
        pub fn user_op_hash<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SendUserOperationUserOpHash>,
        {
            self.user_op_hash = value.try_into().map_err(|_| {
                "conversion to `SendUserOperationUserOpHash` for user_op_hash failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SendUserOperationBody>,
            <V as std::convert::TryInto<types::SendUserOperationBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SendUserOperationBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SendUserOperationBody,
            ) -> types::builder::SendUserOperationBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/smart-accounts/{address}/user-operations/{userOpHash}/send`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::EvmUserOperation>, Error<types::Error>> {
            let Self {
                client,
                address,
                user_op_hash,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let user_op_hash = user_op_hash.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SendUserOperationBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/smart-accounts/{}/user-operations/{}/send",
                client.baseurl,
                encode_path(&address.to_string()),
                encode_path(&user_op_hash.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "send_user_operation",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                403u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::create_evm_swap_quote`]

    [`Client::create_evm_swap_quote`]: super::Client::create_evm_swap_quote*/
    #[derive(Debug, Clone)]
    pub struct CreateEvmSwapQuote<'a> {
        client: &'a super::Client,
        x_idempotency_key: Result<Option<types::CreateEvmSwapQuoteXIdempotencyKey>, String>,
        body: Result<types::builder::CreateEvmSwapQuoteBody, String>,
    }
    impl<'a> CreateEvmSwapQuote<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                x_idempotency_key: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateEvmSwapQuoteXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `CreateEvmSwapQuoteXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateEvmSwapQuoteBody>,
            <V as std::convert::TryInto<types::CreateEvmSwapQuoteBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateEvmSwapQuoteBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CreateEvmSwapQuoteBody,
            ) -> types::builder::CreateEvmSwapQuoteBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/evm/swaps`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CreateSwapQuoteResponseWrapper>, Error<types::Error>>
        {
            let Self {
                client,
                x_idempotency_key,
                body,
            } = self;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::CreateEvmSwapQuoteBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/evm/swaps", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_evm_swap_quote",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                403u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::get_evm_swap_price`]

    [`Client::get_evm_swap_price`]: super::Client::get_evm_swap_price*/
    #[derive(Debug, Clone)]
    pub struct GetEvmSwapPrice<'a> {
        client: &'a super::Client,
        from_amount: Result<types::FromAmount, String>,
        from_token: Result<types::FromToken, String>,
        gas_price: Result<Option<types::GasPrice>, String>,
        network: Result<types::EvmSwapsNetwork, String>,
        signer_address: Result<Option<types::SignerAddress>, String>,
        slippage_bps: Result<Option<types::SlippageBps>, String>,
        taker: Result<types::Taker, String>,
        to_token: Result<types::ToToken, String>,
    }
    impl<'a> GetEvmSwapPrice<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                from_amount: Err("from_amount was not initialized".to_string()),
                from_token: Err("from_token was not initialized".to_string()),
                gas_price: Ok(None),
                network: Err("network was not initialized".to_string()),
                signer_address: Ok(None),
                slippage_bps: Ok(None),
                taker: Err("taker was not initialized".to_string()),
                to_token: Err("to_token was not initialized".to_string()),
            }
        }
        pub fn from_amount<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FromAmount>,
        {
            self.from_amount = value
                .try_into()
                .map_err(|_| "conversion to `FromAmount` for from_amount failed".to_string());
            self
        }
        pub fn from_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FromToken>,
        {
            self.from_token = value
                .try_into()
                .map_err(|_| "conversion to `FromToken` for from_token failed".to_string());
            self
        }
        pub fn gas_price<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GasPrice>,
        {
            self.gas_price = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `GasPrice` for gas_price failed".to_string());
            self
        }
        pub fn network<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::EvmSwapsNetwork>,
        {
            self.network = value
                .try_into()
                .map_err(|_| "conversion to `EvmSwapsNetwork` for network failed".to_string());
            self
        }
        pub fn signer_address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignerAddress>,
        {
            self.signer_address = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SignerAddress` for signer_address failed".to_string());
            self
        }
        pub fn slippage_bps<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SlippageBps>,
        {
            self.slippage_bps = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SlippageBps` for slippage_bps failed".to_string());
            self
        }
        pub fn taker<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Taker>,
        {
            self.taker = value
                .try_into()
                .map_err(|_| "conversion to `Taker` for taker failed".to_string());
            self
        }
        pub fn to_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ToToken>,
        {
            self.to_token = value
                .try_into()
                .map_err(|_| "conversion to `ToToken` for to_token failed".to_string());
            self
        }
        ///Sends a `GET` request to `/v2/evm/swaps/quote`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GetSwapPriceResponseWrapper>, Error<types::Error>>
        {
            let Self {
                client,
                from_amount,
                from_token,
                gas_price,
                network,
                signer_address,
                slippage_bps,
                taker,
                to_token,
            } = self;
            let from_amount = from_amount.map_err(Error::InvalidRequest)?;
            let from_token = from_token.map_err(Error::InvalidRequest)?;
            let gas_price = gas_price.map_err(Error::InvalidRequest)?;
            let network = network.map_err(Error::InvalidRequest)?;
            let signer_address = signer_address.map_err(Error::InvalidRequest)?;
            let slippage_bps = slippage_bps.map_err(Error::InvalidRequest)?;
            let taker = taker.map_err(Error::InvalidRequest)?;
            let to_token = to_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/evm/swaps/quote", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_middleware_client::QueryParam::new(
                    "fromAmount",
                    &from_amount,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "fromToken",
                    &from_token,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "gasPrice", &gas_price,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "network", &network,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "signerAddress",
                    &signer_address,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "slippageBps",
                    &slippage_bps,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "taker", &taker,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "toToken", &to_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_evm_swap_price",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                403u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::list_evm_token_balances`]

    [`Client::list_evm_token_balances`]: super::Client::list_evm_token_balances*/
    #[derive(Debug, Clone)]
    pub struct ListEvmTokenBalances<'a> {
        client: &'a super::Client,
        network: Result<types::ListEvmTokenBalancesNetwork, String>,
        address: Result<types::ListEvmTokenBalancesAddress, String>,
        page_size: Result<Option<i64>, String>,
        page_token: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListEvmTokenBalances<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                network: Err("network was not initialized".to_string()),
                address: Err("address was not initialized".to_string()),
                page_size: Ok(None),
                page_token: Ok(None),
            }
        }
        pub fn network<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ListEvmTokenBalancesNetwork>,
        {
            self.network = value.try_into().map_err(|_| {
                "conversion to `ListEvmTokenBalancesNetwork` for network failed".to_string()
            });
            self
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ListEvmTokenBalancesAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `ListEvmTokenBalancesAddress` for address failed".to_string()
            });
            self
        }
        pub fn page_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.page_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for page_size failed".to_string());
            self
        }
        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/evm/token-balances/{network}/{address}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ListEvmTokenBalancesResponse>, Error<types::Error>>
        {
            let Self {
                client,
                network,
                address,
                page_size,
                page_token,
            } = self;
            let network = network.map_err(Error::InvalidRequest)?;
            let address = address.map_err(Error::InvalidRequest)?;
            let page_size = page_size.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/evm/token-balances/{}/{}",
                client.baseurl,
                encode_path(&network.to_string()),
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageSize", &page_size,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageToken",
                    &page_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_evm_token_balances",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::create_onramp_order`]

    [`Client::create_onramp_order`]: super::Client::create_onramp_order*/
    #[derive(Debug, Clone)]
    pub struct CreateOnrampOrder<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateOnrampOrderBody, String>,
    }
    impl<'a> CreateOnrampOrder<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateOnrampOrderBody>,
            <V as std::convert::TryInto<types::CreateOnrampOrderBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateOnrampOrderBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CreateOnrampOrderBody,
            ) -> types::builder::CreateOnrampOrderBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/onramp/orders`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CreateOnrampOrderResponse>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreateOnrampOrderBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/onramp/orders", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_onramp_order",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::get_onramp_order_by_id`]

    [`Client::get_onramp_order_by_id`]: super::Client::get_onramp_order_by_id*/
    #[derive(Debug, Clone)]
    pub struct GetOnrampOrderById<'a> {
        client: &'a super::Client,
        order_id: Result<::std::string::String, String>,
    }
    impl<'a> GetOnrampOrderById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                order_id: Err("order_id was not initialized".to_string()),
            }
        }
        pub fn order_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.order_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for order_id failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/onramp/orders/{orderId}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GetOnrampOrderByIdResponse>, Error<types::Error>> {
            let Self { client, order_id } = self;
            let order_id = order_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/onramp/orders/{}",
                client.baseurl,
                encode_path(&order_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_onramp_order_by_id",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::create_onramp_session`]

    [`Client::create_onramp_session`]: super::Client::create_onramp_session*/
    #[derive(Debug, Clone)]
    pub struct CreateOnrampSession<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateOnrampSessionBody, String>,
    }
    impl<'a> CreateOnrampSession<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateOnrampSessionBody>,
            <V as std::convert::TryInto<types::CreateOnrampSessionBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateOnrampSessionBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CreateOnrampSessionBody,
            ) -> types::builder::CreateOnrampSessionBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/onramp/sessions`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CreateOnrampSessionResponse>, Error<types::Error>>
        {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::CreateOnrampSessionBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/onramp/sessions", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_onramp_session",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::list_policies`]

    [`Client::list_policies`]: super::Client::list_policies*/
    #[derive(Debug, Clone)]
    pub struct ListPolicies<'a> {
        client: &'a super::Client,
        page_size: Result<Option<i64>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        scope: Result<Option<types::ListPoliciesScope>, String>,
    }
    impl<'a> ListPolicies<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page_size: Ok(None),
                page_token: Ok(None),
                scope: Ok(None),
            }
        }
        pub fn page_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.page_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for page_size failed".to_string());
            self
        }
        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }
        pub fn scope<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ListPoliciesScope>,
        {
            self.scope = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `ListPoliciesScope` for scope failed".to_string());
            self
        }
        ///Sends a `GET` request to `/v2/policy-engine/policies`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ListPoliciesResponse>, Error<types::Error>> {
            let Self {
                client,
                page_size,
                page_token,
                scope,
            } = self;
            let page_size = page_size.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let scope = scope.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/policy-engine/policies", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageSize", &page_size,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageToken",
                    &page_token,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "scope", &scope,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_policies",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::create_policy`]

    [`Client::create_policy`]: super::Client::create_policy*/
    #[derive(Debug, Clone)]
    pub struct CreatePolicy<'a> {
        client: &'a super::Client,
        x_idempotency_key: Result<Option<types::CreatePolicyXIdempotencyKey>, String>,
        body: Result<types::builder::CreatePolicyBody, String>,
    }
    impl<'a> CreatePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                x_idempotency_key: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreatePolicyXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `CreatePolicyXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreatePolicyBody>,
            <V as std::convert::TryInto<types::CreatePolicyBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreatePolicyBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CreatePolicyBody,
            ) -> types::builder::CreatePolicyBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/policy-engine/policies`
        pub async fn send(self) -> Result<ResponseValue<types::Policy>, Error<types::Error>> {
            let Self {
                client,
                x_idempotency_key,
                body,
            } = self;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::CreatePolicyBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/policy-engine/policies", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::get_policy_by_id`]

    [`Client::get_policy_by_id`]: super::Client::get_policy_by_id*/
    #[derive(Debug, Clone)]
    pub struct GetPolicyById<'a> {
        client: &'a super::Client,
        policy_id: Result<types::GetPolicyByIdPolicyId, String>,
    }
    impl<'a> GetPolicyById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                policy_id: Err("policy_id was not initialized".to_string()),
            }
        }
        pub fn policy_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetPolicyByIdPolicyId>,
        {
            self.policy_id = value.try_into().map_err(|_| {
                "conversion to `GetPolicyByIdPolicyId` for policy_id failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/policy-engine/policies/{policyId}`
        pub async fn send(self) -> Result<ResponseValue<types::Policy>, Error<types::Error>> {
            let Self { client, policy_id } = self;
            let policy_id = policy_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/policy-engine/policies/{}",
                client.baseurl,
                encode_path(&policy_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_policy_by_id",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::update_policy`]

    [`Client::update_policy`]: super::Client::update_policy*/
    #[derive(Debug, Clone)]
    pub struct UpdatePolicy<'a> {
        client: &'a super::Client,
        policy_id: Result<types::UpdatePolicyPolicyId, String>,
        x_idempotency_key: Result<Option<types::UpdatePolicyXIdempotencyKey>, String>,
        body: Result<types::builder::UpdatePolicyBody, String>,
    }
    impl<'a> UpdatePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                policy_id: Err("policy_id was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn policy_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdatePolicyPolicyId>,
        {
            self.policy_id = value.try_into().map_err(|_| {
                "conversion to `UpdatePolicyPolicyId` for policy_id failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdatePolicyXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `UpdatePolicyXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdatePolicyBody>,
            <V as std::convert::TryInto<types::UpdatePolicyBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `UpdatePolicyBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::UpdatePolicyBody,
            ) -> types::builder::UpdatePolicyBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `PUT` request to `/v2/policy-engine/policies/{policyId}`
        pub async fn send(self) -> Result<ResponseValue<types::Policy>, Error<types::Error>> {
            let Self {
                client,
                policy_id,
                x_idempotency_key,
                body,
            } = self;
            let policy_id = policy_id.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::UpdatePolicyBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/policy-engine/policies/{}",
                client.baseurl,
                encode_path(&policy_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::delete_policy`]

    [`Client::delete_policy`]: super::Client::delete_policy*/
    #[derive(Debug, Clone)]
    pub struct DeletePolicy<'a> {
        client: &'a super::Client,
        policy_id: Result<types::DeletePolicyPolicyId, String>,
        x_idempotency_key: Result<Option<types::DeletePolicyXIdempotencyKey>, String>,
    }
    impl<'a> DeletePolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                policy_id: Err("policy_id was not initialized".to_string()),
                x_idempotency_key: Ok(None),
            }
        }
        pub fn policy_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeletePolicyPolicyId>,
        {
            self.policy_id = value.try_into().map_err(|_| {
                "conversion to `DeletePolicyPolicyId` for policy_id failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeletePolicyXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `DeletePolicyXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        ///Sends a `DELETE` request to `/v2/policy-engine/policies/{policyId}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                policy_id,
                x_idempotency_key,
            } = self;
            let policy_id = policy_id.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/policy-engine/policies/{}",
                client.baseurl,
                encode_path(&policy_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "delete_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::list_solana_accounts`]

    [`Client::list_solana_accounts`]: super::Client::list_solana_accounts*/
    #[derive(Debug, Clone)]
    pub struct ListSolanaAccounts<'a> {
        client: &'a super::Client,
        page_size: Result<Option<i64>, String>,
        page_token: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListSolanaAccounts<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                page_size: Ok(None),
                page_token: Ok(None),
            }
        }
        pub fn page_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.page_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for page_size failed".to_string());
            self
        }
        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/solana/accounts`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ListSolanaAccountsResponse>, Error<types::Error>> {
            let Self {
                client,
                page_size,
                page_token,
            } = self;
            let page_size = page_size.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/solana/accounts", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageSize", &page_size,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageToken",
                    &page_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_solana_accounts",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::create_solana_account`]

    [`Client::create_solana_account`]: super::Client::create_solana_account*/
    #[derive(Debug, Clone)]
    pub struct CreateSolanaAccount<'a> {
        client: &'a super::Client,
        x_idempotency_key: Result<Option<types::CreateSolanaAccountXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::CreateSolanaAccountBody, String>,
    }
    impl<'a> CreateSolanaAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateSolanaAccountXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `CreateSolanaAccountXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateSolanaAccountBody>,
            <V as std::convert::TryInto<types::CreateSolanaAccountBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateSolanaAccountBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CreateSolanaAccountBody,
            ) -> types::builder::CreateSolanaAccountBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/solana/accounts`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SolanaAccount>, Error<types::Error>> {
            let Self {
                client,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::CreateSolanaAccountBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/solana/accounts", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_solana_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::get_solana_account_by_name`]

    [`Client::get_solana_account_by_name`]: super::Client::get_solana_account_by_name*/
    #[derive(Debug, Clone)]
    pub struct GetSolanaAccountByName<'a> {
        client: &'a super::Client,
        name: Result<::std::string::String, String>,
    }
    impl<'a> GetSolanaAccountByName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                name: Err("name was not initialized".to_string()),
            }
        }
        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for name failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/solana/accounts/by-name/{name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SolanaAccount>, Error<types::Error>> {
            let Self { client, name } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/solana/accounts/by-name/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_solana_account_by_name",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::export_solana_account_by_name`]

    [`Client::export_solana_account_by_name`]: super::Client::export_solana_account_by_name*/
    #[derive(Debug, Clone)]
    pub struct ExportSolanaAccountByName<'a> {
        client: &'a super::Client,
        name: Result<::std::string::String, String>,
        x_idempotency_key: Result<Option<types::ExportSolanaAccountByNameXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::ExportSolanaAccountByNameBody, String>,
    }
    impl<'a> ExportSolanaAccountByName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                name: Err("name was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for name failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExportSolanaAccountByNameXIdempotencyKey>,
        {
            self.x_idempotency_key = value
                .try_into()
                .map(Some)
                .map_err(|_| {
                    "conversion to `ExportSolanaAccountByNameXIdempotencyKey` for x_idempotency_key failed"
                        .to_string()
                });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExportSolanaAccountByNameBody>,
            <V as std::convert::TryInto<types::ExportSolanaAccountByNameBody>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `ExportSolanaAccountByNameBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ExportSolanaAccountByNameBody,
            ) -> types::builder::ExportSolanaAccountByNameBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/solana/accounts/export/by-name/{name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ExportSolanaAccountByNameResponse>, Error<types::Error>>
        {
            let Self {
                client,
                name,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::ExportSolanaAccountByNameBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/solana/accounts/export/by-name/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "export_solana_account_by_name",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::import_solana_account`]

    [`Client::import_solana_account`]: super::Client::import_solana_account*/
    #[derive(Debug, Clone)]
    pub struct ImportSolanaAccount<'a> {
        client: &'a super::Client,
        x_idempotency_key: Result<Option<types::ImportSolanaAccountXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::ImportSolanaAccountBody, String>,
    }
    impl<'a> ImportSolanaAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ImportSolanaAccountXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `ImportSolanaAccountXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ImportSolanaAccountBody>,
            <V as std::convert::TryInto<types::ImportSolanaAccountBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `ImportSolanaAccountBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ImportSolanaAccountBody,
            ) -> types::builder::ImportSolanaAccountBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/solana/accounts/import`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SolanaAccount>, Error<types::Error>> {
            let Self {
                client,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::ImportSolanaAccountBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/solana/accounts/import", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "import_solana_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::send_solana_transaction`]

    [`Client::send_solana_transaction`]: super::Client::send_solana_transaction*/
    #[derive(Debug, Clone)]
    pub struct SendSolanaTransaction<'a> {
        client: &'a super::Client,
        x_idempotency_key: Result<Option<types::SendSolanaTransactionXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::SendSolanaTransactionBody, String>,
    }
    impl<'a> SendSolanaTransaction<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SendSolanaTransactionXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `SendSolanaTransactionXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SendSolanaTransactionBody>,
            <V as std::convert::TryInto<types::SendSolanaTransactionBody>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SendSolanaTransactionBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SendSolanaTransactionBody,
            ) -> types::builder::SendSolanaTransactionBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/solana/accounts/send/transaction`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SendSolanaTransactionResponse>, Error<types::Error>>
        {
            let Self {
                client,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::SendSolanaTransactionBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/solana/accounts/send/transaction", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "send_solana_transaction",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                403u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::get_solana_account`]

    [`Client::get_solana_account`]: super::Client::get_solana_account*/
    #[derive(Debug, Clone)]
    pub struct GetSolanaAccount<'a> {
        client: &'a super::Client,
        address: Result<types::GetSolanaAccountAddress, String>,
    }
    impl<'a> GetSolanaAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetSolanaAccountAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `GetSolanaAccountAddress` for address failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/solana/accounts/{address}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SolanaAccount>, Error<types::Error>> {
            let Self { client, address } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/solana/accounts/{}",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_solana_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::update_solana_account`]

    [`Client::update_solana_account`]: super::Client::update_solana_account*/
    #[derive(Debug, Clone)]
    pub struct UpdateSolanaAccount<'a> {
        client: &'a super::Client,
        address: Result<types::UpdateSolanaAccountAddress, String>,
        x_idempotency_key: Result<Option<types::UpdateSolanaAccountXIdempotencyKey>, String>,
        body: Result<types::builder::UpdateSolanaAccountBody, String>,
    }
    impl<'a> UpdateSolanaAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateSolanaAccountAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `UpdateSolanaAccountAddress` for address failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateSolanaAccountXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `UpdateSolanaAccountXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateSolanaAccountBody>,
            <V as std::convert::TryInto<types::UpdateSolanaAccountBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UpdateSolanaAccountBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::UpdateSolanaAccountBody,
            ) -> types::builder::UpdateSolanaAccountBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `PUT` request to `/v2/solana/accounts/{address}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SolanaAccount>, Error<types::Error>> {
            let Self {
                client,
                address,
                x_idempotency_key,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::UpdateSolanaAccountBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/solana/accounts/{}",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_solana_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::export_solana_account`]

    [`Client::export_solana_account`]: super::Client::export_solana_account*/
    #[derive(Debug, Clone)]
    pub struct ExportSolanaAccount<'a> {
        client: &'a super::Client,
        address: Result<types::ExportSolanaAccountAddress, String>,
        x_idempotency_key: Result<Option<types::ExportSolanaAccountXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::ExportSolanaAccountBody, String>,
    }
    impl<'a> ExportSolanaAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExportSolanaAccountAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `ExportSolanaAccountAddress` for address failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExportSolanaAccountXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExportSolanaAccountXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExportSolanaAccountBody>,
            <V as std::convert::TryInto<types::ExportSolanaAccountBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `ExportSolanaAccountBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ExportSolanaAccountBody,
            ) -> types::builder::ExportSolanaAccountBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/solana/accounts/{address}/export`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ExportSolanaAccountResponse>, Error<types::Error>>
        {
            let Self {
                client,
                address,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::ExportSolanaAccountBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/solana/accounts/{}/export",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "export_solana_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::sign_solana_message`]

    [`Client::sign_solana_message`]: super::Client::sign_solana_message*/
    #[derive(Debug, Clone)]
    pub struct SignSolanaMessage<'a> {
        client: &'a super::Client,
        address: Result<types::SignSolanaMessageAddress, String>,
        x_idempotency_key: Result<Option<types::SignSolanaMessageXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::SignSolanaMessageBody, String>,
    }
    impl<'a> SignSolanaMessage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignSolanaMessageAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `SignSolanaMessageAddress` for address failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignSolanaMessageXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `SignSolanaMessageXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignSolanaMessageBody>,
            <V as std::convert::TryInto<types::SignSolanaMessageBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SignSolanaMessageBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SignSolanaMessageBody,
            ) -> types::builder::SignSolanaMessageBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/solana/accounts/{address}/sign/message`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SignSolanaMessageResponse>, Error<types::Error>> {
            let Self {
                client,
                address,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SignSolanaMessageBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/solana/accounts/{}/sign/message",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "sign_solana_message",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::sign_solana_transaction`]

    [`Client::sign_solana_transaction`]: super::Client::sign_solana_transaction*/
    #[derive(Debug, Clone)]
    pub struct SignSolanaTransaction<'a> {
        client: &'a super::Client,
        address: Result<types::SignSolanaTransactionAddress, String>,
        x_idempotency_key: Result<Option<types::SignSolanaTransactionXIdempotencyKey>, String>,
        x_wallet_auth: Result<::std::string::String, String>,
        body: Result<types::builder::SignSolanaTransactionBody, String>,
    }
    impl<'a> SignSolanaTransaction<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                x_idempotency_key: Ok(None),
                x_wallet_auth: Err("x_wallet_auth was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignSolanaTransactionAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `SignSolanaTransactionAddress` for address failed".to_string()
            });
            self
        }
        pub fn x_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignSolanaTransactionXIdempotencyKey>,
        {
            self.x_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `SignSolanaTransactionXIdempotencyKey` for x_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn x_wallet_auth<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.x_wallet_auth = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for x_wallet_auth failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SignSolanaTransactionBody>,
            <V as std::convert::TryInto<types::SignSolanaTransactionBody>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SignSolanaTransactionBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SignSolanaTransactionBody,
            ) -> types::builder::SignSolanaTransactionBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/solana/accounts/{address}/sign/transaction`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SignSolanaTransactionResponse>, Error<types::Error>>
        {
            let Self {
                client,
                address,
                x_idempotency_key,
                x_wallet_auth,
                body,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let x_idempotency_key = x_idempotency_key.map_err(Error::InvalidRequest)?;
            let x_wallet_auth = x_wallet_auth.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::SignSolanaTransactionBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/solana/accounts/{}/sign/transaction",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            if let Some(value) = x_idempotency_key {
                header_map.append("X-Idempotency-Key", value.to_string().try_into()?);
            }
            header_map.append("X-Wallet-Auth", x_wallet_auth.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "sign_solana_transaction",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                401u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                402u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                403u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                422u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::request_solana_faucet`]

    [`Client::request_solana_faucet`]: super::Client::request_solana_faucet*/
    #[derive(Debug, Clone)]
    pub struct RequestSolanaFaucet<'a> {
        client: &'a super::Client,
        body: Result<types::builder::RequestSolanaFaucetBody, String>,
    }
    impl<'a> RequestSolanaFaucet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RequestSolanaFaucetBody>,
            <V as std::convert::TryInto<types::RequestSolanaFaucetBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `RequestSolanaFaucetBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::RequestSolanaFaucetBody,
            ) -> types::builder::RequestSolanaFaucetBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/solana/faucet`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RequestSolanaFaucetResponse>, Error<types::Error>>
        {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::RequestSolanaFaucetBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/solana/faucet", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "request_solana_faucet",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                403u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                429u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::list_solana_token_balances`]

    [`Client::list_solana_token_balances`]: super::Client::list_solana_token_balances*/
    #[derive(Debug, Clone)]
    pub struct ListSolanaTokenBalances<'a> {
        client: &'a super::Client,
        network: Result<types::ListSolanaTokenBalancesNetwork, String>,
        address: Result<types::ListSolanaTokenBalancesAddress, String>,
        page_size: Result<Option<i64>, String>,
        page_token: Result<Option<::std::string::String>, String>,
    }
    impl<'a> ListSolanaTokenBalances<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                network: Err("network was not initialized".to_string()),
                address: Err("address was not initialized".to_string()),
                page_size: Ok(None),
                page_token: Ok(None),
            }
        }
        pub fn network<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ListSolanaTokenBalancesNetwork>,
        {
            self.network = value.try_into().map_err(|_| {
                "conversion to `ListSolanaTokenBalancesNetwork` for network failed".to_string()
            });
            self
        }
        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ListSolanaTokenBalancesAddress>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `ListSolanaTokenBalancesAddress` for address failed".to_string()
            });
            self
        }
        pub fn page_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i64>,
        {
            self.page_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i64` for page_size failed".to_string());
            self
        }
        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/v2/solana/token-balances/{network}/{address}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ListSolanaTokenBalancesResponse>, Error<types::Error>>
        {
            let Self {
                client,
                network,
                address,
                page_size,
                page_token,
            } = self;
            let network = network.map_err(Error::InvalidRequest)?;
            let address = address.map_err(Error::InvalidRequest)?;
            let page_size = page_size.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v2/solana/token-balances/{}/{}",
                client.baseurl,
                encode_path(&network.to_string()),
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageSize", &page_size,
                ))
                .query(&progenitor_middleware_client::QueryParam::new(
                    "pageToken",
                    &page_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_solana_token_balances",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::settle_x402_payment`]

    [`Client::settle_x402_payment`]: super::Client::settle_x402_payment*/
    #[derive(Debug, Clone)]
    pub struct SettleX402Payment<'a> {
        client: &'a super::Client,
        body: Result<types::builder::SettleX402PaymentBody, String>,
    }
    impl<'a> SettleX402Payment<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SettleX402PaymentBody>,
            <V as std::convert::TryInto<types::SettleX402PaymentBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SettleX402PaymentBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SettleX402PaymentBody,
            ) -> types::builder::SettleX402PaymentBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/x402/settle`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SettleX402PaymentResponse>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::SettleX402PaymentBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/x402/settle", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "settle_x402_payment",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::supported_x402_payment_kinds`]

    [`Client::supported_x402_payment_kinds`]: super::Client::supported_x402_payment_kinds*/
    #[derive(Debug, Clone)]
    pub struct SupportedX402PaymentKinds<'a> {
        client: &'a super::Client,
    }
    impl<'a> SupportedX402PaymentKinds<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        ///Sends a `GET` request to `/v2/x402/supported`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SupportedX402PaymentKindsResponse>, Error<types::Error>>
        {
            let Self { client } = self;
            let url = format!("{}/v2/x402/supported", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "supported_x402_payment_kinds",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::verify_x402_payment`]

    [`Client::verify_x402_payment`]: super::Client::verify_x402_payment*/
    #[derive(Debug, Clone)]
    pub struct VerifyX402Payment<'a> {
        client: &'a super::Client,
        body: Result<types::builder::VerifyX402PaymentBody, String>,
    }
    impl<'a> VerifyX402Payment<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VerifyX402PaymentBody>,
            <V as std::convert::TryInto<types::VerifyX402PaymentBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `VerifyX402PaymentBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::VerifyX402PaymentBody,
            ) -> types::builder::VerifyX402PaymentBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/v2/x402/verify`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VerifyX402PaymentResponse>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::VerifyX402PaymentBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v2/x402/verify", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "verify_x402_payment",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                502u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                503u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
}
/// Items consumers will typically use such as the Client.
pub mod prelude {
    pub use self::super::Client;
}
