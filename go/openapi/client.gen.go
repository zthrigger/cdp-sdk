// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package openapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes = "apiKeyAuth.Scopes"
)

// Defines values for AbiFunctionType.
const (
	Function AbiFunctionType = "function"
)

// Defines values for AbiInputType.
const (
	AbiInputTypeConstructor AbiInputType = "constructor"
	AbiInputTypeError       AbiInputType = "error"
	AbiInputTypeEvent       AbiInputType = "event"
	AbiInputTypeFallback    AbiInputType = "fallback"
	AbiInputTypeReceive     AbiInputType = "receive"
)

// Defines values for AbiStateMutability.
const (
	Nonpayable AbiStateMutability = "nonpayable"
	Payable    AbiStateMutability = "payable"
	Pure       AbiStateMutability = "pure"
	View       AbiStateMutability = "view"
)

// Defines values for CommonSwapResponseLiquidityAvailable.
const (
	CommonSwapResponseLiquidityAvailableTrue CommonSwapResponseLiquidityAvailable = true
)

// Defines values for CreateSwapQuoteResponseLiquidityAvailable.
const (
	CreateSwapQuoteResponseLiquidityAvailableTrue CreateSwapQuoteResponseLiquidityAvailable = true
)

// Defines values for DeveloperJWTAuthenticationType.
const (
	Jwt DeveloperJWTAuthenticationType = "jwt"
)

// Defines values for EmailAuthenticationType.
const (
	Email EmailAuthenticationType = "email"
)

// Defines values for ErrorType.
const (
	ErrorTypeAccountLimitExceeded            ErrorType = "account_limit_exceeded"
	ErrorTypeAlreadyExists                   ErrorType = "already_exists"
	ErrorTypeBadGateway                      ErrorType = "bad_gateway"
	ErrorTypeDocumentVerificationFailed      ErrorType = "document_verification_failed"
	ErrorTypeFaucetLimitExceeded             ErrorType = "faucet_limit_exceeded"
	ErrorTypeForbidden                       ErrorType = "forbidden"
	ErrorTypeGuestPermissionDenied           ErrorType = "guest_permission_denied"
	ErrorTypeGuestRegionForbidden            ErrorType = "guest_region_forbidden"
	ErrorTypeGuestTransactionCount           ErrorType = "guest_transaction_count"
	ErrorTypeGuestTransactionLimit           ErrorType = "guest_transaction_limit"
	ErrorTypeIdempotencyError                ErrorType = "idempotency_error"
	ErrorTypeInternalServerError             ErrorType = "internal_server_error"
	ErrorTypeInvalidRequest                  ErrorType = "invalid_request"
	ErrorTypeInvalidSignature                ErrorType = "invalid_signature"
	ErrorTypeInvalidSqlQuery                 ErrorType = "invalid_sql_query"
	ErrorTypeMalformedTransaction            ErrorType = "malformed_transaction"
	ErrorTypeMfaAlreadyEnrolled              ErrorType = "mfa_already_enrolled"
	ErrorTypeMfaFlowExpired                  ErrorType = "mfa_flow_expired"
	ErrorTypeMfaInvalidCode                  ErrorType = "mfa_invalid_code"
	ErrorTypeMfaInvalidMethod                ErrorType = "mfa_invalid_method"
	ErrorTypeMfaMultipleMethodsAvailable     ErrorType = "mfa_multiple_methods_available"
	ErrorTypeMfaNotEnrolled                  ErrorType = "mfa_not_enrolled"
	ErrorTypeMfaRequired                     ErrorType = "mfa_required"
	ErrorTypeNetworkNotTradable              ErrorType = "network_not_tradable"
	ErrorTypeNotFound                        ErrorType = "not_found"
	ErrorTypePaymentMethodRequired           ErrorType = "payment_method_required"
	ErrorTypePhoneNumberVerificationExpired  ErrorType = "phone_number_verification_expired"
	ErrorTypePolicyInUse                     ErrorType = "policy_in_use"
	ErrorTypePolicyViolation                 ErrorType = "policy_violation"
	ErrorTypeRateLimitExceeded               ErrorType = "rate_limit_exceeded"
	ErrorTypeRecipientAllowlistPending       ErrorType = "recipient_allowlist_pending"
	ErrorTypeRecipientAllowlistViolation     ErrorType = "recipient_allowlist_violation"
	ErrorTypeRequestCanceled                 ErrorType = "request_canceled"
	ErrorTypeServiceUnavailable              ErrorType = "service_unavailable"
	ErrorTypeTimedOut                        ErrorType = "timed_out"
	ErrorTypeTransferAmountOutOfBounds       ErrorType = "transfer_amount_out_of_bounds"
	ErrorTypeTransferQuoteExpired            ErrorType = "transfer_quote_expired"
	ErrorTypeTransferRecipientAddressInvalid ErrorType = "transfer_recipient_address_invalid"
	ErrorTypeTravelRulesRecipientViolation   ErrorType = "travel_rules_recipient_violation"
	ErrorTypeUnauthorized                    ErrorType = "unauthorized"
)

// Defines values for EthValueCriterionOperator.
const (
	EthValueCriterionOperatorEmpty      EthValueCriterionOperator = ">"
	EthValueCriterionOperatorEqualEqual EthValueCriterionOperator = "=="
	EthValueCriterionOperatorN1         EthValueCriterionOperator = ">="
	EthValueCriterionOperatorN2         EthValueCriterionOperator = "<"
	EthValueCriterionOperatorN3         EthValueCriterionOperator = "<="
)

// Defines values for EthValueCriterionType.
const (
	EthValue EthValueCriterionType = "ethValue"
)

// Defines values for EvmAddressCriterionOperator.
const (
	EvmAddressCriterionOperatorIn    EvmAddressCriterionOperator = "in"
	EvmAddressCriterionOperatorNotIn EvmAddressCriterionOperator = "not in"
)

// Defines values for EvmAddressCriterionType.
const (
	EvmAddress EvmAddressCriterionType = "evmAddress"
)

// Defines values for EvmDataCriterionType.
const (
	EvmData EvmDataCriterionType = "evmData"
)

// Defines values for EvmDataParameterConditionOperator.
const (
	EvmDataParameterConditionOperatorEmpty      EvmDataParameterConditionOperator = ">"
	EvmDataParameterConditionOperatorEqualEqual EvmDataParameterConditionOperator = "=="
	EvmDataParameterConditionOperatorN1         EvmDataParameterConditionOperator = ">="
	EvmDataParameterConditionOperatorN2         EvmDataParameterConditionOperator = "<"
	EvmDataParameterConditionOperatorN3         EvmDataParameterConditionOperator = "<="
)

// Defines values for EvmDataParameterConditionListOperator.
const (
	EvmDataParameterConditionListOperatorIn    EvmDataParameterConditionListOperator = "in"
	EvmDataParameterConditionListOperatorNotIn EvmDataParameterConditionListOperator = "not in"
)

// Defines values for EvmMessageCriterionType.
const (
	EvmMessage EvmMessageCriterionType = "evmMessage"
)

// Defines values for EvmNetworkCriterionNetworks.
const (
	EvmNetworkCriterionNetworksArbitrum        EvmNetworkCriterionNetworks = "arbitrum"
	EvmNetworkCriterionNetworksAvalanche       EvmNetworkCriterionNetworks = "avalanche"
	EvmNetworkCriterionNetworksBase            EvmNetworkCriterionNetworks = "base"
	EvmNetworkCriterionNetworksBaseSepolia     EvmNetworkCriterionNetworks = "base-sepolia"
	EvmNetworkCriterionNetworksBnb             EvmNetworkCriterionNetworks = "bnb"
	EvmNetworkCriterionNetworksEthereum        EvmNetworkCriterionNetworks = "ethereum"
	EvmNetworkCriterionNetworksEthereumSepolia EvmNetworkCriterionNetworks = "ethereum-sepolia"
	EvmNetworkCriterionNetworksOptimism        EvmNetworkCriterionNetworks = "optimism"
	EvmNetworkCriterionNetworksPolygon         EvmNetworkCriterionNetworks = "polygon"
	EvmNetworkCriterionNetworksZora            EvmNetworkCriterionNetworks = "zora"
)

// Defines values for EvmNetworkCriterionOperator.
const (
	EvmNetworkCriterionOperatorIn    EvmNetworkCriterionOperator = "in"
	EvmNetworkCriterionOperatorNotIn EvmNetworkCriterionOperator = "not in"
)

// Defines values for EvmNetworkCriterionType.
const (
	EvmNetwork EvmNetworkCriterionType = "evmNetwork"
)

// Defines values for EvmSwapsNetwork.
const (
	EvmSwapsNetworkArbitrum EvmSwapsNetwork = "arbitrum"
	EvmSwapsNetworkBase     EvmSwapsNetwork = "base"
	EvmSwapsNetworkEthereum EvmSwapsNetwork = "ethereum"
	EvmSwapsNetworkOptimism EvmSwapsNetwork = "optimism"
)

// Defines values for EvmTypedAddressConditionOperator.
const (
	EvmTypedAddressConditionOperatorIn    EvmTypedAddressConditionOperator = "in"
	EvmTypedAddressConditionOperatorNotIn EvmTypedAddressConditionOperator = "not in"
)

// Defines values for EvmTypedNumericalConditionOperator.
const (
	EvmTypedNumericalConditionOperatorEmpty      EvmTypedNumericalConditionOperator = ">"
	EvmTypedNumericalConditionOperatorEqualEqual EvmTypedNumericalConditionOperator = "=="
	EvmTypedNumericalConditionOperatorN1         EvmTypedNumericalConditionOperator = ">="
	EvmTypedNumericalConditionOperatorN2         EvmTypedNumericalConditionOperator = "<"
	EvmTypedNumericalConditionOperatorN3         EvmTypedNumericalConditionOperator = "<="
)

// Defines values for EvmUserOperationStatus.
const (
	Broadcast EvmUserOperationStatus = "broadcast"
	Complete  EvmUserOperationStatus = "complete"
	Dropped   EvmUserOperationStatus = "dropped"
	Failed    EvmUserOperationStatus = "failed"
	Pending   EvmUserOperationStatus = "pending"
	Signed    EvmUserOperationStatus = "signed"
)

// Defines values for EvmUserOperationNetwork.
const (
	EvmUserOperationNetworkArbitrum        EvmUserOperationNetwork = "arbitrum"
	EvmUserOperationNetworkAvalanche       EvmUserOperationNetwork = "avalanche"
	EvmUserOperationNetworkBase            EvmUserOperationNetwork = "base"
	EvmUserOperationNetworkBaseSepolia     EvmUserOperationNetwork = "base-sepolia"
	EvmUserOperationNetworkBnb             EvmUserOperationNetwork = "bnb"
	EvmUserOperationNetworkEthereum        EvmUserOperationNetwork = "ethereum"
	EvmUserOperationNetworkEthereumSepolia EvmUserOperationNetwork = "ethereum-sepolia"
	EvmUserOperationNetworkOptimism        EvmUserOperationNetwork = "optimism"
	EvmUserOperationNetworkPolygon         EvmUserOperationNetwork = "polygon"
	EvmUserOperationNetworkZora            EvmUserOperationNetwork = "zora"
)

// Defines values for GetSwapPriceResponseLiquidityAvailable.
const (
	True GetSwapPriceResponseLiquidityAvailable = true
)

// Defines values for KnownAbiType.
const (
	Erc1155 KnownAbiType = "erc1155"
	Erc20   KnownAbiType = "erc20"
	Erc721  KnownAbiType = "erc721"
)

// Defines values for KnownIdlType.
const (
	AssociatedTokenProgram KnownIdlType = "AssociatedTokenProgram"
	SystemProgram          KnownIdlType = "SystemProgram"
	TokenProgram           KnownIdlType = "TokenProgram"
)

// Defines values for ListEvmTokenBalancesNetwork.
const (
	ListEvmTokenBalancesNetworkBase        ListEvmTokenBalancesNetwork = "base"
	ListEvmTokenBalancesNetworkBaseSepolia ListEvmTokenBalancesNetwork = "base-sepolia"
	ListEvmTokenBalancesNetworkEthereum    ListEvmTokenBalancesNetwork = "ethereum"
)

// Defines values for ListSolanaTokenBalancesNetwork.
const (
	ListSolanaTokenBalancesNetworkSolana       ListSolanaTokenBalancesNetwork = "solana"
	ListSolanaTokenBalancesNetworkSolanaDevnet ListSolanaTokenBalancesNetwork = "solana-devnet"
)

// Defines values for MintAddressCriterionOperator.
const (
	MintAddressCriterionOperatorIn    MintAddressCriterionOperator = "in"
	MintAddressCriterionOperatorNotIn MintAddressCriterionOperator = "not in"
)

// Defines values for MintAddressCriterionType.
const (
	MintAddress MintAddressCriterionType = "mintAddress"
)

// Defines values for NetUSDChangeCriterionOperator.
const (
	NetUSDChangeCriterionOperatorEmpty      NetUSDChangeCriterionOperator = ">"
	NetUSDChangeCriterionOperatorEqualEqual NetUSDChangeCriterionOperator = "=="
	NetUSDChangeCriterionOperatorN1         NetUSDChangeCriterionOperator = ">="
	NetUSDChangeCriterionOperatorN2         NetUSDChangeCriterionOperator = "<"
	NetUSDChangeCriterionOperatorN3         NetUSDChangeCriterionOperator = "<="
)

// Defines values for NetUSDChangeCriterionType.
const (
	NetUSDChange NetUSDChangeCriterionType = "netUSDChange"
)

// Defines values for OAuth2ProviderType.
const (
	Apple  OAuth2ProviderType = "apple"
	Google OAuth2ProviderType = "google"
	X      OAuth2ProviderType = "x"
)

// Defines values for OnchainDataResultSchemaColumnsType.
const (
	Bool       OnchainDataResultSchemaColumnsType = "Bool"
	Date       OnchainDataResultSchemaColumnsType = "Date"
	DateTime   OnchainDataResultSchemaColumnsType = "DateTime"
	DateTime64 OnchainDataResultSchemaColumnsType = "DateTime64"
	Float32    OnchainDataResultSchemaColumnsType = "Float32"
	Float64    OnchainDataResultSchemaColumnsType = "Float64"
	Int128     OnchainDataResultSchemaColumnsType = "Int128"
	Int16      OnchainDataResultSchemaColumnsType = "Int16"
	Int256     OnchainDataResultSchemaColumnsType = "Int256"
	Int32      OnchainDataResultSchemaColumnsType = "Int32"
	Int64      OnchainDataResultSchemaColumnsType = "Int64"
	Int8       OnchainDataResultSchemaColumnsType = "Int8"
	String     OnchainDataResultSchemaColumnsType = "String"
	UInt128    OnchainDataResultSchemaColumnsType = "UInt128"
	UInt16     OnchainDataResultSchemaColumnsType = "UInt16"
	UInt256    OnchainDataResultSchemaColumnsType = "UInt256"
	UInt32     OnchainDataResultSchemaColumnsType = "UInt32"
	UInt64     OnchainDataResultSchemaColumnsType = "UInt64"
	UInt8      OnchainDataResultSchemaColumnsType = "UInt8"
	UUID       OnchainDataResultSchemaColumnsType = "UUID"
)

// Defines values for OnrampOrderFeeType.
const (
	FEETYPEEXCHANGE OnrampOrderFeeType = "FEE_TYPE_EXCHANGE"
	FEETYPENETWORK  OnrampOrderFeeType = "FEE_TYPE_NETWORK"
)

// Defines values for OnrampOrderPaymentMethodTypeId.
const (
	GUESTCHECKOUTAPPLEPAY OnrampOrderPaymentMethodTypeId = "GUEST_CHECKOUT_APPLE_PAY"
)

// Defines values for OnrampOrderStatus.
const (
	ONRAMPORDERSTATUSCOMPLETED      OnrampOrderStatus = "ONRAMP_ORDER_STATUS_COMPLETED"
	ONRAMPORDERSTATUSFAILED         OnrampOrderStatus = "ONRAMP_ORDER_STATUS_FAILED"
	ONRAMPORDERSTATUSPENDINGAUTH    OnrampOrderStatus = "ONRAMP_ORDER_STATUS_PENDING_AUTH"
	ONRAMPORDERSTATUSPENDINGPAYMENT OnrampOrderStatus = "ONRAMP_ORDER_STATUS_PENDING_PAYMENT"
	ONRAMPORDERSTATUSPROCESSING     OnrampOrderStatus = "ONRAMP_ORDER_STATUS_PROCESSING"
)

// Defines values for OnrampPaymentLinkType.
const (
	PAYMENTLINKTYPEAPPLEPAYBUTTON OnrampPaymentLinkType = "PAYMENT_LINK_TYPE_APPLE_PAY_BUTTON"
)

// Defines values for OnrampQuotePaymentMethodTypeId.
const (
	ACH          OnrampQuotePaymentMethodTypeId = "ACH"
	APPLEPAY     OnrampQuotePaymentMethodTypeId = "APPLE_PAY"
	CARD         OnrampQuotePaymentMethodTypeId = "CARD"
	CRYPTOWALLET OnrampQuotePaymentMethodTypeId = "CRYPTO_WALLET"
	FIATWALLET   OnrampQuotePaymentMethodTypeId = "FIAT_WALLET"
	PAYPAL       OnrampQuotePaymentMethodTypeId = "PAYPAL"
)

// Defines values for PolicyScope.
const (
	PolicyScopeAccount PolicyScope = "account"
	PolicyScopeProject PolicyScope = "project"
)

// Defines values for PrepareUserOperationRuleAction.
const (
	PrepareUserOperationRuleActionAccept PrepareUserOperationRuleAction = "accept"
	PrepareUserOperationRuleActionReject PrepareUserOperationRuleAction = "reject"
)

// Defines values for PrepareUserOperationRuleOperation.
const (
	PrepareUserOperation PrepareUserOperationRuleOperation = "prepareUserOperation"
)

// Defines values for ProgramIdCriterionOperator.
const (
	ProgramIdCriterionOperatorIn    ProgramIdCriterionOperator = "in"
	ProgramIdCriterionOperatorNotIn ProgramIdCriterionOperator = "not in"
)

// Defines values for ProgramIdCriterionType.
const (
	ProgramId ProgramIdCriterionType = "programId"
)

// Defines values for SendEvmTransactionRuleAction.
const (
	SendEvmTransactionRuleActionAccept SendEvmTransactionRuleAction = "accept"
	SendEvmTransactionRuleActionReject SendEvmTransactionRuleAction = "reject"
)

// Defines values for SendEvmTransactionRuleOperation.
const (
	SendEvmTransaction SendEvmTransactionRuleOperation = "sendEvmTransaction"
)

// Defines values for SendSolTransactionRuleAction.
const (
	SendSolTransactionRuleActionAccept SendSolTransactionRuleAction = "accept"
	SendSolTransactionRuleActionReject SendSolTransactionRuleAction = "reject"
)

// Defines values for SendSolTransactionRuleOperation.
const (
	SendSolTransaction SendSolTransactionRuleOperation = "sendSolTransaction"
)

// Defines values for SendUserOperationRuleAction.
const (
	SendUserOperationRuleActionAccept SendUserOperationRuleAction = "accept"
	SendUserOperationRuleActionReject SendUserOperationRuleAction = "reject"
)

// Defines values for SendUserOperationRuleOperation.
const (
	SendUserOperation SendUserOperationRuleOperation = "sendUserOperation"
)

// Defines values for SignEvmHashRuleAction.
const (
	SignEvmHashRuleActionAccept SignEvmHashRuleAction = "accept"
	SignEvmHashRuleActionReject SignEvmHashRuleAction = "reject"
)

// Defines values for SignEvmHashRuleOperation.
const (
	SignEvmHash SignEvmHashRuleOperation = "signEvmHash"
)

// Defines values for SignEvmMessageRuleAction.
const (
	SignEvmMessageRuleActionAccept SignEvmMessageRuleAction = "accept"
	SignEvmMessageRuleActionReject SignEvmMessageRuleAction = "reject"
)

// Defines values for SignEvmMessageRuleOperation.
const (
	SignEvmMessage SignEvmMessageRuleOperation = "signEvmMessage"
)

// Defines values for SignEvmTransactionRuleAction.
const (
	SignEvmTransactionRuleActionAccept SignEvmTransactionRuleAction = "accept"
	SignEvmTransactionRuleActionReject SignEvmTransactionRuleAction = "reject"
)

// Defines values for SignEvmTransactionRuleOperation.
const (
	SignEvmTransaction SignEvmTransactionRuleOperation = "signEvmTransaction"
)

// Defines values for SignEvmTypedDataFieldCriterionType.
const (
	EvmTypedDataField SignEvmTypedDataFieldCriterionType = "evmTypedDataField"
)

// Defines values for SignEvmTypedDataRuleAction.
const (
	SignEvmTypedDataRuleActionAccept SignEvmTypedDataRuleAction = "accept"
	SignEvmTypedDataRuleActionReject SignEvmTypedDataRuleAction = "reject"
)

// Defines values for SignEvmTypedDataRuleOperation.
const (
	SignEvmTypedData SignEvmTypedDataRuleOperation = "signEvmTypedData"
)

// Defines values for SignEvmTypedDataVerifyingContractCriterionOperator.
const (
	SignEvmTypedDataVerifyingContractCriterionOperatorIn    SignEvmTypedDataVerifyingContractCriterionOperator = "in"
	SignEvmTypedDataVerifyingContractCriterionOperatorNotIn SignEvmTypedDataVerifyingContractCriterionOperator = "not in"
)

// Defines values for SignEvmTypedDataVerifyingContractCriterionType.
const (
	EvmTypedDataVerifyingContract SignEvmTypedDataVerifyingContractCriterionType = "evmTypedDataVerifyingContract"
)

// Defines values for SignSolMessageRuleAction.
const (
	SignSolMessageRuleActionAccept SignSolMessageRuleAction = "accept"
	SignSolMessageRuleActionReject SignSolMessageRuleAction = "reject"
)

// Defines values for SignSolMessageRuleOperation.
const (
	SignSolMessage SignSolMessageRuleOperation = "signSolMessage"
)

// Defines values for SignSolTransactionRuleAction.
const (
	SignSolTransactionRuleActionAccept SignSolTransactionRuleAction = "accept"
	SignSolTransactionRuleActionReject SignSolTransactionRuleAction = "reject"
)

// Defines values for SignSolTransactionRuleOperation.
const (
	SignSolTransaction SignSolTransactionRuleOperation = "signSolTransaction"
)

// Defines values for SmsAuthenticationType.
const (
	Sms SmsAuthenticationType = "sms"
)

// Defines values for SolAddressCriterionOperator.
const (
	SolAddressCriterionOperatorIn    SolAddressCriterionOperator = "in"
	SolAddressCriterionOperatorNotIn SolAddressCriterionOperator = "not in"
)

// Defines values for SolAddressCriterionType.
const (
	SolAddress SolAddressCriterionType = "solAddress"
)

// Defines values for SolDataCriterionType.
const (
	SolData SolDataCriterionType = "solData"
)

// Defines values for SolDataParameterConditionOperator.
const (
	SolDataParameterConditionOperatorEmpty      SolDataParameterConditionOperator = ">"
	SolDataParameterConditionOperatorEqualEqual SolDataParameterConditionOperator = "=="
	SolDataParameterConditionOperatorN1         SolDataParameterConditionOperator = ">="
	SolDataParameterConditionOperatorN2         SolDataParameterConditionOperator = "<"
	SolDataParameterConditionOperatorN3         SolDataParameterConditionOperator = "<="
)

// Defines values for SolDataParameterConditionListOperator.
const (
	SolDataParameterConditionListOperatorIn    SolDataParameterConditionListOperator = "in"
	SolDataParameterConditionListOperatorNotIn SolDataParameterConditionListOperator = "not in"
)

// Defines values for SolMessageCriterionType.
const (
	SolMessage SolMessageCriterionType = "solMessage"
)

// Defines values for SolNetworkCriterionNetworks.
const (
	SolNetworkCriterionNetworksSolana       SolNetworkCriterionNetworks = "solana"
	SolNetworkCriterionNetworksSolanaDevnet SolNetworkCriterionNetworks = "solana-devnet"
)

// Defines values for SolNetworkCriterionOperator.
const (
	SolNetworkCriterionOperatorIn    SolNetworkCriterionOperator = "in"
	SolNetworkCriterionOperatorNotIn SolNetworkCriterionOperator = "not in"
)

// Defines values for SolNetworkCriterionType.
const (
	SolNetwork SolNetworkCriterionType = "solNetwork"
)

// Defines values for SolValueCriterionOperator.
const (
	SolValueCriterionOperatorEmpty      SolValueCriterionOperator = ">"
	SolValueCriterionOperatorEqualEqual SolValueCriterionOperator = "=="
	SolValueCriterionOperatorN1         SolValueCriterionOperator = ">="
	SolValueCriterionOperatorN2         SolValueCriterionOperator = "<"
	SolValueCriterionOperatorN3         SolValueCriterionOperator = "<="
)

// Defines values for SolValueCriterionType.
const (
	SolValue SolValueCriterionType = "solValue"
)

// Defines values for SpendPermissionNetwork.
const (
	SpendPermissionNetworkArbitrum        SpendPermissionNetwork = "arbitrum"
	SpendPermissionNetworkAvalanche       SpendPermissionNetwork = "avalanche"
	SpendPermissionNetworkBase            SpendPermissionNetwork = "base"
	SpendPermissionNetworkBaseSepolia     SpendPermissionNetwork = "base-sepolia"
	SpendPermissionNetworkEthereum        SpendPermissionNetwork = "ethereum"
	SpendPermissionNetworkEthereumSepolia SpendPermissionNetwork = "ethereum-sepolia"
	SpendPermissionNetworkOptimism        SpendPermissionNetwork = "optimism"
	SpendPermissionNetworkPolygon         SpendPermissionNetwork = "polygon"
)

// Defines values for SplAddressCriterionOperator.
const (
	In    SplAddressCriterionOperator = "in"
	NotIn SplAddressCriterionOperator = "not in"
)

// Defines values for SplAddressCriterionType.
const (
	SplAddress SplAddressCriterionType = "splAddress"
)

// Defines values for SplValueCriterionOperator.
const (
	SplValueCriterionOperatorEmpty      SplValueCriterionOperator = ">"
	SplValueCriterionOperatorEqualEqual SplValueCriterionOperator = "=="
	SplValueCriterionOperatorN1         SplValueCriterionOperator = ">="
	SplValueCriterionOperatorN2         SplValueCriterionOperator = "<"
	SplValueCriterionOperatorN3         SplValueCriterionOperator = "<="
)

// Defines values for SplValueCriterionType.
const (
	SplValue SplValueCriterionType = "splValue"
)

// Defines values for SwapUnavailableResponseLiquidityAvailable.
const (
	False SwapUnavailableResponseLiquidityAvailable = false
)

// Defines values for X402Version.
const (
	X402VersionN1 X402Version = 1
	X402VersionN2 X402Version = 2
)

// Defines values for X402SettleErrorReason.
const (
	X402SettleErrorReasonInsufficientFunds                                                           X402SettleErrorReason = "insufficient_funds"
	X402SettleErrorReasonInvalidExactEvmPayloadAuthorizationFromAddressKyt                           X402SettleErrorReason = "invalid_exact_evm_payload_authorization_from_address_kyt"
	X402SettleErrorReasonInvalidExactEvmPayloadAuthorizationToAddressKyt                             X402SettleErrorReason = "invalid_exact_evm_payload_authorization_to_address_kyt"
	X402SettleErrorReasonInvalidExactEvmPayloadAuthorizationTypedDataMessage                         X402SettleErrorReason = "invalid_exact_evm_payload_authorization_typed_data_message"
	X402SettleErrorReasonInvalidExactEvmPayloadAuthorizationValidAfter                               X402SettleErrorReason = "invalid_exact_evm_payload_authorization_valid_after"
	X402SettleErrorReasonInvalidExactEvmPayloadAuthorizationValidBefore                              X402SettleErrorReason = "invalid_exact_evm_payload_authorization_valid_before"
	X402SettleErrorReasonInvalidExactEvmPayloadAuthorizationValue                                    X402SettleErrorReason = "invalid_exact_evm_payload_authorization_value"
	X402SettleErrorReasonInvalidExactEvmPayloadAuthorizationValueTooLow                              X402SettleErrorReason = "invalid_exact_evm_payload_authorization_value_too_low"
	X402SettleErrorReasonInvalidExactEvmPayloadSignature                                             X402SettleErrorReason = "invalid_exact_evm_payload_signature"
	X402SettleErrorReasonInvalidExactEvmPayloadSignatureAddress                                      X402SettleErrorReason = "invalid_exact_evm_payload_signature_address"
	X402SettleErrorReasonInvalidExactSvmPayloadTransaction                                           X402SettleErrorReason = "invalid_exact_svm_payload_transaction"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionAmountMismatch                             X402SettleErrorReason = "invalid_exact_svm_payload_transaction_amount_mismatch"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionCannotDeriveReceiverAta                    X402SettleErrorReason = "invalid_exact_svm_payload_transaction_cannot_derive_receiver_ata"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionCreateAtaInstruction                       X402SettleErrorReason = "invalid_exact_svm_payload_transaction_create_ata_instruction"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionCreateAtaInstructionIncorrectAsset         X402SettleErrorReason = "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionCreateAtaInstructionIncorrectPayee         X402SettleErrorReason = "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionFeePayerIncludedInInstructionAccounts      X402SettleErrorReason = "invalid_exact_svm_payload_transaction_fee_payer_included_in_instruction_accounts"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionFeePayerTransferringFunds                  X402SettleErrorReason = "invalid_exact_svm_payload_transaction_fee_payer_transferring_funds"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionInstructionNotSplTokenTransferChecked      X402SettleErrorReason = "invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionInstructionNotToken2022TransferChecked     X402SettleErrorReason = "invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionInstructions                               X402SettleErrorReason = "invalid_exact_svm_payload_transaction_instructions"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionInstructionsComputeLimitInstruction        X402SettleErrorReason = "invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionInstructionsComputePriceInstruction        X402SettleErrorReason = "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionInstructionsComputePriceInstructionTooHigh X402SettleErrorReason = "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionInstructionsLength                         X402SettleErrorReason = "invalid_exact_svm_payload_transaction_instructions_length"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionNotATransferInstruction                    X402SettleErrorReason = "invalid_exact_svm_payload_transaction_not_a_transfer_instruction"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionReceiverAtaNotFound                        X402SettleErrorReason = "invalid_exact_svm_payload_transaction_receiver_ata_not_found"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionSenderAtaNotFound                          X402SettleErrorReason = "invalid_exact_svm_payload_transaction_sender_ata_not_found"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionSimulationFailed                           X402SettleErrorReason = "invalid_exact_svm_payload_transaction_simulation_failed"
	X402SettleErrorReasonInvalidExactSvmPayloadTransactionTransferToIncorrectAta                     X402SettleErrorReason = "invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata"
	X402SettleErrorReasonInvalidNetwork                                                              X402SettleErrorReason = "invalid_network"
	X402SettleErrorReasonInvalidPayload                                                              X402SettleErrorReason = "invalid_payload"
	X402SettleErrorReasonInvalidPaymentRequirements                                                  X402SettleErrorReason = "invalid_payment_requirements"
	X402SettleErrorReasonInvalidScheme                                                               X402SettleErrorReason = "invalid_scheme"
	X402SettleErrorReasonInvalidX402Version                                                          X402SettleErrorReason = "invalid_x402_version"
	X402SettleErrorReasonSettleExactEvmTransactionConfirmationTimedOut                               X402SettleErrorReason = "settle_exact_evm_transaction_confirmation_timed_out"
	X402SettleErrorReasonSettleExactFailedOnchain                                                    X402SettleErrorReason = "settle_exact_failed_onchain"
	X402SettleErrorReasonSettleExactNodeFailure                                                      X402SettleErrorReason = "settle_exact_node_failure"
	X402SettleErrorReasonSettleExactSvmBlockHeightExceeded                                           X402SettleErrorReason = "settle_exact_svm_block_height_exceeded"
	X402SettleErrorReasonSettleExactSvmTransactionConfirmationTimedOut                               X402SettleErrorReason = "settle_exact_svm_transaction_confirmation_timed_out"
)

// Defines values for X402SupportedPaymentKindNetwork.
const (
	X402SupportedPaymentKindNetworkBase         X402SupportedPaymentKindNetwork = "base"
	X402SupportedPaymentKindNetworkBaseSepolia  X402SupportedPaymentKindNetwork = "base-sepolia"
	X402SupportedPaymentKindNetworkSolana       X402SupportedPaymentKindNetwork = "solana"
	X402SupportedPaymentKindNetworkSolanaDevnet X402SupportedPaymentKindNetwork = "solana-devnet"
)

// Defines values for X402SupportedPaymentKindScheme.
const (
	X402SupportedPaymentKindSchemeExact X402SupportedPaymentKindScheme = "exact"
)

// Defines values for X402V1PaymentPayloadNetwork.
const (
	X402V1PaymentPayloadNetworkBase         X402V1PaymentPayloadNetwork = "base"
	X402V1PaymentPayloadNetworkBaseSepolia  X402V1PaymentPayloadNetwork = "base-sepolia"
	X402V1PaymentPayloadNetworkSolana       X402V1PaymentPayloadNetwork = "solana"
	X402V1PaymentPayloadNetworkSolanaDevnet X402V1PaymentPayloadNetwork = "solana-devnet"
)

// Defines values for X402V1PaymentPayloadScheme.
const (
	X402V1PaymentPayloadSchemeExact X402V1PaymentPayloadScheme = "exact"
)

// Defines values for X402V1PaymentRequirementsNetwork.
const (
	X402V1PaymentRequirementsNetworkBase         X402V1PaymentRequirementsNetwork = "base"
	X402V1PaymentRequirementsNetworkBaseSepolia  X402V1PaymentRequirementsNetwork = "base-sepolia"
	X402V1PaymentRequirementsNetworkSolana       X402V1PaymentRequirementsNetwork = "solana"
	X402V1PaymentRequirementsNetworkSolanaDevnet X402V1PaymentRequirementsNetwork = "solana-devnet"
)

// Defines values for X402V1PaymentRequirementsScheme.
const (
	X402V1PaymentRequirementsSchemeExact X402V1PaymentRequirementsScheme = "exact"
)

// Defines values for X402V2PaymentRequirementsScheme.
const (
	X402V2PaymentRequirementsSchemeExact X402V2PaymentRequirementsScheme = "exact"
)

// Defines values for X402VerifyInvalidReason.
const (
	X402VerifyInvalidReasonInsufficientFunds                                                           X402VerifyInvalidReason = "insufficient_funds"
	X402VerifyInvalidReasonInvalidExactEvmPayloadAuthorizationFromAddressKyt                           X402VerifyInvalidReason = "invalid_exact_evm_payload_authorization_from_address_kyt"
	X402VerifyInvalidReasonInvalidExactEvmPayloadAuthorizationToAddressKyt                             X402VerifyInvalidReason = "invalid_exact_evm_payload_authorization_to_address_kyt"
	X402VerifyInvalidReasonInvalidExactEvmPayloadAuthorizationTypedDataMessage                         X402VerifyInvalidReason = "invalid_exact_evm_payload_authorization_typed_data_message"
	X402VerifyInvalidReasonInvalidExactEvmPayloadAuthorizationValidAfter                               X402VerifyInvalidReason = "invalid_exact_evm_payload_authorization_valid_after"
	X402VerifyInvalidReasonInvalidExactEvmPayloadAuthorizationValidBefore                              X402VerifyInvalidReason = "invalid_exact_evm_payload_authorization_valid_before"
	X402VerifyInvalidReasonInvalidExactEvmPayloadAuthorizationValue                                    X402VerifyInvalidReason = "invalid_exact_evm_payload_authorization_value"
	X402VerifyInvalidReasonInvalidExactEvmPayloadAuthorizationValueTooLow                              X402VerifyInvalidReason = "invalid_exact_evm_payload_authorization_value_too_low"
	X402VerifyInvalidReasonInvalidExactEvmPayloadSignature                                             X402VerifyInvalidReason = "invalid_exact_evm_payload_signature"
	X402VerifyInvalidReasonInvalidExactEvmPayloadSignatureAddress                                      X402VerifyInvalidReason = "invalid_exact_evm_payload_signature_address"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransaction                                           X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionAmountMismatch                             X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_amount_mismatch"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionCannotDeriveReceiverAta                    X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_cannot_derive_receiver_ata"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionCreateAtaInstruction                       X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_create_ata_instruction"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionCreateAtaInstructionIncorrectAsset         X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionCreateAtaInstructionIncorrectPayee         X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionFeePayerIncludedInInstructionAccounts      X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_fee_payer_included_in_instruction_accounts"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionFeePayerTransferringFunds                  X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_fee_payer_transferring_funds"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionInstructionNotSplTokenTransferChecked      X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionInstructionNotToken2022TransferChecked     X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionInstructions                               X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_instructions"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionInstructionsComputeLimitInstruction        X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionInstructionsComputePriceInstruction        X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionInstructionsComputePriceInstructionTooHigh X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionInstructionsLength                         X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_instructions_length"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionNotATransferInstruction                    X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_not_a_transfer_instruction"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionReceiverAtaNotFound                        X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_receiver_ata_not_found"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionSenderAtaNotFound                          X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_sender_ata_not_found"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionSimulationFailed                           X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_simulation_failed"
	X402VerifyInvalidReasonInvalidExactSvmPayloadTransactionTransferToIncorrectAta                     X402VerifyInvalidReason = "invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata"
	X402VerifyInvalidReasonInvalidNetwork                                                              X402VerifyInvalidReason = "invalid_network"
	X402VerifyInvalidReasonInvalidPayload                                                              X402VerifyInvalidReason = "invalid_payload"
	X402VerifyInvalidReasonInvalidPaymentRequirements                                                  X402VerifyInvalidReason = "invalid_payment_requirements"
	X402VerifyInvalidReasonInvalidScheme                                                               X402VerifyInvalidReason = "invalid_scheme"
	X402VerifyInvalidReasonInvalidX402Version                                                          X402VerifyInvalidReason = "invalid_x402_version"
)

// Defines values for ListTokensForAccountParamsNetwork.
const (
	ListTokensForAccountParamsNetworkBase        ListTokensForAccountParamsNetwork = "base"
	ListTokensForAccountParamsNetworkBaseSepolia ListTokensForAccountParamsNetwork = "base-sepolia"
)

// Defines values for ListEndUsersParamsSort.
const (
	CreatedAtAsc  ListEndUsersParamsSort = "createdAt=asc"
	CreatedAtDesc ListEndUsersParamsSort = "createdAt=desc"
)

// Defines values for ImportEndUserJSONBodyKeyType.
const (
	ImportEndUserJSONBodyKeyTypeEvm    ImportEndUserJSONBodyKeyType = "evm"
	ImportEndUserJSONBodyKeyTypeSolana ImportEndUserJSONBodyKeyType = "solana"
)

// Defines values for SendEvmTransactionJSONBodyNetwork.
const (
	SendEvmTransactionJSONBodyNetworkArbitrum        SendEvmTransactionJSONBodyNetwork = "arbitrum"
	SendEvmTransactionJSONBodyNetworkAvalanche       SendEvmTransactionJSONBodyNetwork = "avalanche"
	SendEvmTransactionJSONBodyNetworkBase            SendEvmTransactionJSONBodyNetwork = "base"
	SendEvmTransactionJSONBodyNetworkBaseSepolia     SendEvmTransactionJSONBodyNetwork = "base-sepolia"
	SendEvmTransactionJSONBodyNetworkEthereum        SendEvmTransactionJSONBodyNetwork = "ethereum"
	SendEvmTransactionJSONBodyNetworkEthereumSepolia SendEvmTransactionJSONBodyNetwork = "ethereum-sepolia"
	SendEvmTransactionJSONBodyNetworkOptimism        SendEvmTransactionJSONBodyNetwork = "optimism"
	SendEvmTransactionJSONBodyNetworkPolygon         SendEvmTransactionJSONBodyNetwork = "polygon"
)

// Defines values for RequestEvmFaucetJSONBodyNetwork.
const (
	BaseSepolia     RequestEvmFaucetJSONBodyNetwork = "base-sepolia"
	EthereumHoodi   RequestEvmFaucetJSONBodyNetwork = "ethereum-hoodi"
	EthereumSepolia RequestEvmFaucetJSONBodyNetwork = "ethereum-sepolia"
)

// Defines values for RequestEvmFaucetJSONBodyToken.
const (
	RequestEvmFaucetJSONBodyTokenCbbtc RequestEvmFaucetJSONBodyToken = "cbbtc"
	RequestEvmFaucetJSONBodyTokenEth   RequestEvmFaucetJSONBodyToken = "eth"
	RequestEvmFaucetJSONBodyTokenEurc  RequestEvmFaucetJSONBodyToken = "eurc"
	RequestEvmFaucetJSONBodyTokenUsdc  RequestEvmFaucetJSONBodyToken = "usdc"
)

// Defines values for ListPoliciesParamsScope.
const (
	ListPoliciesParamsScopeAccount ListPoliciesParamsScope = "account"
	ListPoliciesParamsScopeProject ListPoliciesParamsScope = "project"
)

// Defines values for CreatePolicyJSONBodyScope.
const (
	Account CreatePolicyJSONBodyScope = "account"
	Project CreatePolicyJSONBodyScope = "project"
)

// Defines values for SendSolanaTransactionJSONBodyNetwork.
const (
	SendSolanaTransactionJSONBodyNetworkSolana       SendSolanaTransactionJSONBodyNetwork = "solana"
	SendSolanaTransactionJSONBodyNetworkSolanaDevnet SendSolanaTransactionJSONBodyNetwork = "solana-devnet"
)

// Defines values for RequestSolanaFaucetJSONBodyToken.
const (
	RequestSolanaFaucetJSONBodyTokenSol  RequestSolanaFaucetJSONBodyToken = "sol"
	RequestSolanaFaucetJSONBodyTokenUsdc RequestSolanaFaucetJSONBodyToken = "usdc"
)

// Abi Contract ABI Specification following Solidity's external JSON interface format.
type Abi = []Abi_Item

// Abi_Item defines model for Abi.Item.
type Abi_Item struct {
	union json.RawMessage
}

// AbiFunction ABI function type for contract functions.
type AbiFunction struct {
	// Constant Deprecated. Use pure or view from stateMutability instead.
	Constant *bool `json:"constant,omitempty"`

	// Gas Deprecated. Vyper used to provide gas estimates.
	Gas *int `json:"gas,omitempty"`

	// Inputs The list of ABI parameters used for this function.
	Inputs []AbiParameter `json:"inputs"`

	// Name The name of the ABI function.
	Name string `json:"name"`

	// Outputs The values returned by this function.
	Outputs []AbiParameter `json:"outputs"`

	// Payable Deprecated. Use payable or nonpayable from `stateMutability` instead.
	Payable *bool `json:"payable,omitempty"`

	// StateMutability State mutability of a function in Solidity.
	StateMutability AbiStateMutability `json:"stateMutability"`

	// Type The type of the ABI item, must be `function`.
	Type AbiFunctionType `json:"type"`
}

// AbiFunctionType The type of the ABI item, must be `function`.
type AbiFunctionType string

// AbiInput Generic ABI item type encapsulating all other types besides `function`.
type AbiInput struct {
	// AdditionalProperties For additional information on the ABI JSON specification, see [the Solidity documentation](https://docs.soliditylang.org/en/latest/abi-spec.html#json).
	AdditionalProperties *interface{} `json:"additionalProperties,omitempty"`

	// Type The type of the ABI item.
	Type AbiInputType `json:"type"`
}

// AbiInputType The type of the ABI item.
type AbiInputType string

// AbiParameter Parameter definition for ABI functions, errors, and constructors.
type AbiParameter struct {
	// Components Used for tuple types.
	Components *[]AbiParameter `json:"components,omitempty"`

	// InternalType The internal Solidity type used by the compiler.
	InternalType *string `json:"internalType,omitempty"`

	// Name The name of the parameter.
	Name *string `json:"name,omitempty"`

	// Type The canonical type of the parameter.
	Type string `json:"type"`
}

// AbiStateMutability State mutability of a function in Solidity.
type AbiStateMutability string

// AccountTokenAddressesResponse Response containing token addresses that an account has received.
type AccountTokenAddressesResponse struct {
	// AccountAddress The account address that was queried.
	AccountAddress *string `json:"accountAddress,omitempty"`

	// TokenAddresses List of token contract addresses that the account has received.
	TokenAddresses *[]string `json:"tokenAddresses,omitempty"`

	// TotalCount Total number of unique token addresses discovered.
	TotalCount *int `json:"totalCount,omitempty"`
}

// AuthenticationMethod Information about how the end user is authenticated.
type AuthenticationMethod struct {
	union json.RawMessage
}

// AuthenticationMethods The list of valid authentication methods linked to the end user.
type AuthenticationMethods = []AuthenticationMethod

// CommonSwapResponse defines model for CommonSwapResponse.
type CommonSwapResponse struct {
	// BlockNumber The block number at which the liquidity conditions were examined.
	BlockNumber string `json:"blockNumber"`

	// Fees The estimated fees for the swap.
	Fees struct {
		// GasFee The estimated gas fee for the swap.
		GasFee *TokenFee `json:"gasFee"`

		// ProtocolFee The estimated protocol fee for the swap.
		ProtocolFee *TokenFee `json:"protocolFee"`
	} `json:"fees"`

	// FromAmount The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
	FromAmount string `json:"fromAmount"`

	// FromToken The 0x-prefixed contract address of the token that will be sent.
	FromToken string `json:"fromToken"`

	// Issues An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.
	Issues struct {
		// Allowance Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
		Allowance *struct {
			// CurrentAllowance The current allowance of the `fromToken` by the `taker`.
			CurrentAllowance string `json:"currentAllowance"`

			// Spender The 0x-prefixed address of to set the allowance on.
			Spender string `json:"spender"`
		} `json:"allowance"`

		// Balance Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
		Balance *struct {
			// CurrentBalance The current balance of the `fromToken` by the `taker`.
			CurrentBalance string `json:"currentBalance"`

			// RequiredBalance The amount of the token that the `taker` must hold.
			RequiredBalance string `json:"requiredBalance"`

			// Token The 0x-prefixed contract address of the token.
			Token string `json:"token"`
		} `json:"balance"`

		// SimulationIncomplete This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.
		SimulationIncomplete bool `json:"simulationIncomplete"`
	} `json:"issues"`

	// LiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
	LiquidityAvailable CommonSwapResponseLiquidityAvailable `json:"liquidityAvailable"`

	// MinToAmount The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
	MinToAmount string `json:"minToAmount"`

	// ToAmount The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
	ToAmount string `json:"toAmount"`

	// ToToken The 0x-prefixed contract address of the token that will be received.
	ToToken string `json:"toToken"`
}

// CommonSwapResponseLiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
type CommonSwapResponseLiquidityAvailable bool

// CreateSpendPermissionRequest Request parameters for creating a Spend Permission.
type CreateSpendPermissionRequest struct {
	// Allowance Maximum allowed value to spend, in atomic units for the specified token, within each period.
	Allowance string `json:"allowance"`

	// End The expiration time for this spend permission, in Unix seconds.
	End string `json:"end"`

	// ExtraData Arbitrary data to include in the permission.
	ExtraData *string `json:"extraData,omitempty"`

	// Network The network the spend permission is on.
	Network SpendPermissionNetwork `json:"network"`

	// PaymasterUrl The paymaster URL of the spend permission.
	PaymasterUrl *Url `json:"paymasterUrl,omitempty"`

	// Period Time duration for resetting used allowance on a recurring basis (seconds).
	Period string `json:"period"`

	// Salt An arbitrary salt to differentiate unique spend permissions with otherwise identical data.
	Salt *string `json:"salt,omitempty"`

	// Spender Entity that can spend account's tokens. Can be either a Smart Account or an EOA.
	Spender string `json:"spender"`

	// Start The start time for this spend permission, in Unix seconds.
	Start string `json:"start"`

	// Token ERC-7528 native token address (e.g. "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE" for native ETH), or an  ERC-20 contract address.
	Token string `json:"token"`
}

// CreateSwapQuoteResponse defines model for CreateSwapQuoteResponse.
type CreateSwapQuoteResponse struct {
	// BlockNumber The block number at which the liquidity conditions were examined.
	BlockNumber string `json:"blockNumber"`

	// Fees The estimated fees for the swap.
	Fees struct {
		// GasFee The estimated gas fee for the swap.
		GasFee *TokenFee `json:"gasFee"`

		// ProtocolFee The estimated protocol fee for the swap.
		ProtocolFee *TokenFee `json:"protocolFee"`
	} `json:"fees"`

	// FromAmount The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
	FromAmount string `json:"fromAmount"`

	// FromToken The 0x-prefixed contract address of the token that will be sent.
	FromToken string `json:"fromToken"`

	// Issues An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.
	Issues struct {
		// Allowance Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
		Allowance *struct {
			// CurrentAllowance The current allowance of the `fromToken` by the `taker`.
			CurrentAllowance string `json:"currentAllowance"`

			// Spender The 0x-prefixed address of to set the allowance on.
			Spender string `json:"spender"`
		} `json:"allowance"`

		// Balance Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
		Balance *struct {
			// CurrentBalance The current balance of the `fromToken` by the `taker`.
			CurrentBalance string `json:"currentBalance"`

			// RequiredBalance The amount of the token that the `taker` must hold.
			RequiredBalance string `json:"requiredBalance"`

			// Token The 0x-prefixed contract address of the token.
			Token string `json:"token"`
		} `json:"balance"`

		// SimulationIncomplete This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.
		SimulationIncomplete bool `json:"simulationIncomplete"`
	} `json:"issues"`

	// LiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
	LiquidityAvailable CreateSwapQuoteResponseLiquidityAvailable `json:"liquidityAvailable"`

	// MinToAmount The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
	MinToAmount string `json:"minToAmount"`

	// Permit2 The approval object which contains the necessary fields to submit an approval for this transaction. Null if the `fromToken` is the native token or the transaction is a native token wrap / unwrap.
	Permit2 *struct {
		// Eip712 The message to sign using EIP-712.
		Eip712 EIP712Message `json:"eip712"`

		// Hash The hash for the approval according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). Computing the hash of the `eip712` field should match the value of this field.
		Hash string `json:"hash"`
	} `json:"permit2"`

	// ToAmount The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
	ToAmount string `json:"toAmount"`

	// ToToken The 0x-prefixed contract address of the token that will be received.
	ToToken string `json:"toToken"`

	// Transaction The details of the transaction to be signed and submitted to execute the swap.
	Transaction struct {
		// Data The hex-encoded call data to send to the contract.
		Data string `json:"data"`

		// Gas The estimated gas limit that should be used to send the transaction to guarantee settlement.
		Gas string `json:"gas"`

		// GasPrice The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.
		GasPrice string `json:"gasPrice"`

		// To The 0x-prefixed address of the contract to call.
		To string `json:"to"`

		// Value The value of the transaction in Wei.
		Value string `json:"value"`
	} `json:"transaction"`
}

// CreateSwapQuoteResponseLiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
type CreateSwapQuoteResponseLiquidityAvailable bool

// CreateSwapQuoteResponseWrapper A wrapper for the response of a swap quote operation.
type CreateSwapQuoteResponseWrapper struct {
	union json.RawMessage
}

// DeveloperJWTAuthentication Information about an end user who authenticates using a JWT issued by the developer.
type DeveloperJWTAuthentication struct {
	// Kid The key ID of the JWK used to sign the JWT.
	Kid string `json:"kid"`

	// Sub The unique identifier for the end user that is captured in the `sub` claim of the JWT.
	Sub string `json:"sub"`

	// Type The type of authentication information.
	Type DeveloperJWTAuthenticationType `json:"type"`
}

// DeveloperJWTAuthenticationType The type of authentication information.
type DeveloperJWTAuthenticationType string

// EIP712Domain The domain of the EIP-712 typed data.
type EIP712Domain struct {
	// ChainId The chain ID of the EVM network.
	ChainId *int64 `json:"chainId,omitempty"`

	// Name The name of the DApp or protocol.
	Name *string `json:"name,omitempty"`

	// Salt The optional 32-byte 0x-prefixed hex salt for domain separation.
	Salt *string `json:"salt,omitempty"`

	// VerifyingContract The 0x-prefixed EVM address of the verifying smart contract.
	VerifyingContract *string `json:"verifyingContract,omitempty"`

	// Version The version of the DApp or protocol.
	Version *string `json:"version,omitempty"`
}

// EIP712Message The message to sign using EIP-712.
type EIP712Message struct {
	// Domain The domain of the EIP-712 typed data.
	Domain EIP712Domain `json:"domain"`

	// Message The message to sign. The structure of this message must match the `primaryType` struct in the `types` object.
	Message map[string]interface{} `json:"message"`

	// PrimaryType The primary type of the message. This is the name of the struct in the `types` object that is the root of the message.
	PrimaryType string `json:"primaryType"`

	// Types A mapping of struct names to an array of type objects (name + type).
	// Each key corresponds to a type name (e.g., "`EIP712Domain`", "`PermitTransferFrom`").
	Types EIP712Types `json:"types"`
}

// EIP712Types A mapping of struct names to an array of type objects (name + type).
// Each key corresponds to a type name (e.g., "`EIP712Domain`", "`PermitTransferFrom`").
type EIP712Types = map[string]interface{}

// EmailAuthentication Information about an end user who authenticates using a one-time password sent to their email address.
type EmailAuthentication struct {
	// Email The email address of the end user.
	Email openapi_types.Email `json:"email"`

	// Type The type of authentication information.
	Type EmailAuthenticationType `json:"type"`
}

// EmailAuthenticationType The type of authentication information.
type EmailAuthenticationType string

// EndUser Information about the end user.
type EndUser struct {
	// AuthenticationMethods The list of valid authentication methods linked to the end user.
	AuthenticationMethods AuthenticationMethods `json:"authenticationMethods"`

	// CreatedAt The date and time when the end user was created, in ISO 8601 format.
	CreatedAt time.Time `json:"createdAt"`

	// EvmAccountObjects The list of EVM accounts associated with the end user. End users can have up to 10 EVM accounts.
	EvmAccountObjects []EndUserEvmAccount `json:"evmAccountObjects"`

	// EvmAccounts **DEPRECATED**: Use `evmAccountObjects` instead for richer account information. The list of EVM account addresses associated with the end user. End users can have up to 10 EVM accounts.
	// Deprecated:
	EvmAccounts []string `json:"evmAccounts"`

	// EvmSmartAccountObjects The list of EVM smart accounts associated with the end user. Each EVM EOA can own one smart account.
	EvmSmartAccountObjects []EndUserEvmSmartAccount `json:"evmSmartAccountObjects"`

	// EvmSmartAccounts **DEPRECATED**: Use `evmSmartAccountObjects` instead for richer account information including owner relationships. The list of EVM smart account addresses associated with the end user. Each EVM EOA can own one smart account.
	// Deprecated:
	EvmSmartAccounts []string `json:"evmSmartAccounts"`

	// MfaMethods Information about the end user's MFA enrollments.
	MfaMethods *MFAMethods `json:"mfaMethods,omitempty"`

	// SolanaAccountObjects The list of Solana accounts associated with the end user. End users can have up to 10 Solana accounts.
	SolanaAccountObjects []EndUserSolanaAccount `json:"solanaAccountObjects"`

	// SolanaAccounts **DEPRECATED**: Use `solanaAccountObjects` instead for richer account information. The list of Solana account addresses associated with the end user. End users can have up to 10 Solana accounts.
	// Deprecated:
	SolanaAccounts []string `json:"solanaAccounts"`

	// UserId A stable, unique identifier for the end user. The `userId` must be unique across all end users in the developer's CDP Project. It must be between 1 and 100 characters long and can only contain alphanumeric characters and hyphens.
	UserId string `json:"userId"`
}

// EndUserEvmAccount Information about an EVM account associated with an end user.
type EndUserEvmAccount struct {
	// Address The address of the EVM account.
	Address string `json:"address"`

	// CreatedAt The date and time when the account was created, in ISO 8601 format.
	CreatedAt time.Time `json:"createdAt"`
}

// EndUserEvmSmartAccount Information about an EVM smart account associated with an end user.
type EndUserEvmSmartAccount struct {
	// Address The address of the EVM smart account.
	Address string `json:"address"`

	// CreatedAt The date and time when the account was created, in ISO 8601 format.
	CreatedAt time.Time `json:"createdAt"`

	// OwnerAddresses The addresses of the EVM EOA accounts that own this smart account. Smart accounts can have multiple owners, such as when spend permissions are enabled.
	OwnerAddresses []string `json:"ownerAddresses"`
}

// EndUserSolanaAccount Information about a Solana account associated with an end user.
type EndUserSolanaAccount struct {
	// Address The base58 encoded address of the Solana account.
	Address string `json:"address"`

	// CreatedAt The date and time when the account was created, in ISO 8601 format.
	CreatedAt time.Time `json:"createdAt"`
}

// Error An error response including the code for the type of error and a human-readable message describing the error.
type Error struct {
	// CorrelationId A unique identifier for the request that generated the error. This can be used to help debug issues with the API.
	CorrelationId *string `json:"correlationId,omitempty"`

	// ErrorLink A link to the corresponding error documentation.
	ErrorLink *Url `json:"errorLink,omitempty"`

	// ErrorMessage The error message.
	ErrorMessage string `json:"errorMessage"`

	// ErrorType The code that indicates the type of error that occurred. These error codes can be used to determine how to handle the error.
	ErrorType ErrorType `json:"errorType"`
}

// ErrorType The code that indicates the type of error that occurred. These error codes can be used to determine how to handle the error.
type ErrorType string

// EthValueCriterion A schema for specifying a criterion for the `value` field of an EVM transaction.
type EthValueCriterion struct {
	// EthValue The amount of ETH, in wei, that the transaction's `value` field should be compared to.
	EthValue string `json:"ethValue"`

	// Operator The operator to use for the comparison. The transaction's `value` field will be on the left-hand side of the operator, and the `ethValue` field will be on the right-hand side.
	Operator EthValueCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `ethValue`.
	Type EthValueCriterionType `json:"type"`
}

// EthValueCriterionOperator The operator to use for the comparison. The transaction's `value` field will be on the left-hand side of the operator, and the `ethValue` field will be on the right-hand side.
type EthValueCriterionOperator string

// EthValueCriterionType The type of criterion to use. This should be `ethValue`.
type EthValueCriterionType string

// EvmAccount defines model for EvmAccount.
type EvmAccount struct {
	// Address The 0x-prefixed, checksum EVM address.
	Address string `json:"address"`

	// CreatedAt The UTC ISO 8601 timestamp at which the account was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names are guaranteed to be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`

	// Policies The list of policy IDs that apply to the account. This will include both the project-level policy and the account-level policy, if one exists.
	Policies *[]string `json:"policies,omitempty"`

	// UpdatedAt The UTC ISO 8601 timestamp at which the account was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// EvmAddressCriterion A schema for specifying a criterion for the `to` field of an EVM transaction.
type EvmAddressCriterion struct {
	// Addresses A list of 0x-prefixed EVM addresses that the transaction's `to` field should be compared to. There is a limit of 300 addresses per criterion.
	Addresses []string `json:"addresses"`

	// Operator The operator to use for the comparison. The transaction's `to` field will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
	Operator EvmAddressCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `evmAddress`.
	Type EvmAddressCriterionType `json:"type"`
}

// EvmAddressCriterionOperator The operator to use for the comparison. The transaction's `to` field will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
type EvmAddressCriterionOperator string

// EvmAddressCriterionType The type of criterion to use. This should be `evmAddress`.
type EvmAddressCriterionType string

// EvmCall defines model for EvmCall.
type EvmCall struct {
	// Data The call data to send. This is the hex-encoded data of the function call consisting of the method selector and the function arguments.
	Data string `json:"data"`

	// OverrideGasLimit The override gas limit to use for the call instead of the bundler's estimated gas limit.
	OverrideGasLimit *string `json:"overrideGasLimit,omitempty"`

	// To The address the call is directed to.
	To string `json:"to"`

	// Value The amount of ETH to send with the call, in wei.
	Value string `json:"value"`
}

// EvmDataCondition A single condition to apply against the function and encoded arguments in the transaction's `data` field. Each `parameter` configuration must be successfully evaluated against the corresponding function argument in order for a policy to be accepted.
type EvmDataCondition struct {
	// Function The name of a smart contract function being called.
	Function string `json:"function"`

	// Params An optional list of parameter conditions to apply against encoded arguments in the transaction's `data` field.
	Params *[]EvmDataCondition_Params_Item `json:"params,omitempty"`
}

// EvmDataCondition_Params_Item A list of parameter conditions to apply against encoded arguments in the transaction's `data` field.
type EvmDataCondition_Params_Item struct {
	union json.RawMessage
}

// EvmDataCriterion A schema for specifying a criterion for the `data` field of an EVM transaction.
type EvmDataCriterion struct {
	// Abi The ABI of the smart contract being called. This can be a partial structure with only specific functions.
	Abi EvmDataCriterion_Abi `json:"abi"`

	// Conditions A list of conditions to apply against the function and encoded arguments in the transaction's `data` field. Each condition must be met in order for this policy to be accepted or rejected.
	Conditions []EvmDataCondition `json:"conditions"`

	// Type The type of criterion to use. This should be `evmData`.
	Type EvmDataCriterionType `json:"type"`
}

// EvmDataCriterion_Abi The ABI of the smart contract being called. This can be a partial structure with only specific functions.
type EvmDataCriterion_Abi struct {
	union json.RawMessage
}

// EvmDataCriterionType The type of criterion to use. This should be `evmData`.
type EvmDataCriterionType string

// EvmDataParameterCondition defines model for EvmDataParameterCondition.
type EvmDataParameterCondition struct {
	// Name The name of the parameter to check against a transaction's calldata. If name is unknown, or is not named, you may supply an array index, e.g., `0` for first parameter.
	Name string `json:"name"`

	// Operator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
	Operator EvmDataParameterConditionOperator `json:"operator"`

	// Value A single value to compare the value resolved at `name` to. All values are encoded as strings. Refer to the table in the documentation for how values should be encoded, and which operators are supported for each type.
	Value string `json:"value"`
}

// EvmDataParameterConditionOperator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
type EvmDataParameterConditionOperator string

// EvmDataParameterConditionList defines model for EvmDataParameterConditionList.
type EvmDataParameterConditionList struct {
	// Name The name of the parameter to check against a transaction's calldata. If name is unknown, or is not named, you may supply an array index, e.g., `0` for first parameter.
	Name string `json:"name"`

	// Operator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `values` field will be on the right-hand side.
	Operator EvmDataParameterConditionListOperator `json:"operator"`

	// Values Values to compare against the resolved `name` value. All values are encoded as strings. Refer to the table in the documentation for how values should be encoded, and which operators are supported for each type.
	Values []string `json:"values"`
}

// EvmDataParameterConditionListOperator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `values` field will be on the right-hand side.
type EvmDataParameterConditionListOperator string

// EvmMessageCriterion A schema for specifying a criterion for the message being signed.
type EvmMessageCriterion struct {
	// Match A regular expression the message is matched against. Accepts valid regular expression syntax described by [RE2](https://github.com/google/re2/wiki/Syntax).
	Match string `json:"match"`

	// Type The type of criterion to use. This should be `evmMessage`.
	Type EvmMessageCriterionType `json:"type"`
}

// EvmMessageCriterionType The type of criterion to use. This should be `evmMessage`.
type EvmMessageCriterionType string

// EvmNetworkCriterion A schema for specifying a criterion for the intended `network` of an EVM transaction.
type EvmNetworkCriterion struct {
	// Networks A list of EVM network identifiers that the transaction's intended `network` should be compared to.
	Networks []EvmNetworkCriterionNetworks `json:"networks"`

	// Operator The operator to use for the comparison. The transaction's intended `network` will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.
	Operator EvmNetworkCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `evmNetwork`.
	Type EvmNetworkCriterionType `json:"type"`
}

// EvmNetworkCriterionNetworks The network the transaction is for.
type EvmNetworkCriterionNetworks string

// EvmNetworkCriterionOperator The operator to use for the comparison. The transaction's intended `network` will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.
type EvmNetworkCriterionOperator string

// EvmNetworkCriterionType The type of criterion to use. This should be `evmNetwork`.
type EvmNetworkCriterionType string

// EvmSmartAccount defines model for EvmSmartAccount.
type EvmSmartAccount struct {
	// Address The 0x-prefixed, checksum address of the Smart Account.
	Address string `json:"address"`

	// CreatedAt The UTC ISO 8601 timestamp at which the account was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names are guaranteed to be unique across all Smart Accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`

	// Owners Today, only a single owner can be set for a Smart Account, but this is an array to allow having multiple owners in the future. The address is a 0x-prefixed, checksum address.
	Owners []string `json:"owners"`

	// Policies The list of policy IDs that apply to the smart account. This will include both the project-level policy and the account-level policy, if one exists.
	Policies *[]string `json:"policies,omitempty"`

	// UpdatedAt The UTC ISO 8601 timestamp at which the account was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// EvmSwapsNetwork The network on which to perform the swap.
type EvmSwapsNetwork string

// EvmTypedAddressCondition A schema for specifying criterion for an address field of an EVM typed message. The address can be deeply nested within the typed data's message.
type EvmTypedAddressCondition struct {
	// Addresses A list of 0x-prefixed EVM addresses that the value located at the message's path should be compared to. There is a limit of 300 addresses per criterion.
	Addresses []string `json:"addresses"`

	// Operator The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
	Operator EvmTypedAddressConditionOperator `json:"operator"`

	// Path The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected.
	Path string `json:"path"`
}

// EvmTypedAddressConditionOperator The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
type EvmTypedAddressConditionOperator string

// EvmTypedNumericalCondition A schema for specifying criterion for a numerical field of an EVM typed message. The value can be deeply nested within the typed data's message.
type EvmTypedNumericalCondition struct {
	// Operator The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
	Operator EvmTypedNumericalConditionOperator `json:"operator"`

	// Path The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected.
	Path string `json:"path"`

	// Value The amount that the value located at the message's path should be compared to.
	Value string `json:"value"`
}

// EvmTypedNumericalConditionOperator The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
type EvmTypedNumericalConditionOperator string

// EvmTypedStringCondition A schema for specifying criterion for a string field of an EVM typed message. The value can be deeply nested within the typed data's message.
type EvmTypedStringCondition struct {
	// Match A regular expression the field is matched against.
	Match string `json:"match"`

	// Path The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected.
	Path string `json:"path"`
}

// EvmUserOperation defines model for EvmUserOperation.
type EvmUserOperation struct {
	// Calls The list of calls in the user operation.
	Calls []EvmCall `json:"calls"`

	// Network The network the user operation is for.
	Network EvmUserOperationNetwork `json:"network"`

	// Receipts The list of receipts associated with the user operation.
	Receipts *[]UserOperationReceipt `json:"receipts,omitempty"`

	// Status The status of the user operation.
	Status EvmUserOperationStatus `json:"status"`

	// TransactionHash The hash of the transaction that included this particular user operation. This gets set after the user operation is broadcasted and the transaction is included in a block.
	TransactionHash *string `json:"transactionHash,omitempty"`

	// UserOpHash The hash of the user operation. This is not the transaction hash, as a transaction consists of multiple user operations. The user operation hash is the hash of this particular user operation which gets signed by the owner of the Smart Account.
	UserOpHash string `json:"userOpHash"`
}

// EvmUserOperationStatus The status of the user operation.
type EvmUserOperationStatus string

// EvmUserOperationNetwork The network the user operation is for.
type EvmUserOperationNetwork string

// GetSwapPriceResponse defines model for GetSwapPriceResponse.
type GetSwapPriceResponse struct {
	// BlockNumber The block number at which the liquidity conditions were examined.
	BlockNumber string `json:"blockNumber"`

	// Fees The estimated fees for the swap.
	Fees struct {
		// GasFee The estimated gas fee for the swap.
		GasFee *TokenFee `json:"gasFee"`

		// ProtocolFee The estimated protocol fee for the swap.
		ProtocolFee *TokenFee `json:"protocolFee"`
	} `json:"fees"`

	// FromAmount The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
	FromAmount string `json:"fromAmount"`

	// FromToken The 0x-prefixed contract address of the token that will be sent.
	FromToken string `json:"fromToken"`

	// Gas The estimated gas limit that should be used to send the transaction to guarantee settlement.
	Gas *string `json:"gas"`

	// GasPrice The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.
	GasPrice string `json:"gasPrice"`

	// Issues An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.
	Issues struct {
		// Allowance Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
		Allowance *struct {
			// CurrentAllowance The current allowance of the `fromToken` by the `taker`.
			CurrentAllowance string `json:"currentAllowance"`

			// Spender The 0x-prefixed address of to set the allowance on.
			Spender string `json:"spender"`
		} `json:"allowance"`

		// Balance Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
		Balance *struct {
			// CurrentBalance The current balance of the `fromToken` by the `taker`.
			CurrentBalance string `json:"currentBalance"`

			// RequiredBalance The amount of the token that the `taker` must hold.
			RequiredBalance string `json:"requiredBalance"`

			// Token The 0x-prefixed contract address of the token.
			Token string `json:"token"`
		} `json:"balance"`

		// SimulationIncomplete This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.
		SimulationIncomplete bool `json:"simulationIncomplete"`
	} `json:"issues"`

	// LiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
	LiquidityAvailable GetSwapPriceResponseLiquidityAvailable `json:"liquidityAvailable"`

	// MinToAmount The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
	MinToAmount string `json:"minToAmount"`

	// ToAmount The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
	ToAmount string `json:"toAmount"`

	// ToToken The 0x-prefixed contract address of the token that will be received.
	ToToken string `json:"toToken"`
}

// GetSwapPriceResponseLiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
type GetSwapPriceResponseLiquidityAvailable bool

// GetSwapPriceResponseWrapper A wrapper for the response of a swap price operation.
type GetSwapPriceResponseWrapper struct {
	union json.RawMessage
}

// Idl IDL Specification following Anchor's IDL format v0.30+.
type Idl struct {
	// Address The program address.
	Address string `json:"address"`

	// Instructions List of program instructions.
	Instructions []struct {
		// Accounts Optional list of accounts required by the instruction.
		Accounts *[]struct {
			// Name The account name.
			Name string `json:"name"`

			// Signer Whether the account must be a signer.
			Signer *bool `json:"signer,omitempty"`

			// Writable Whether the account is writable.
			Writable *bool `json:"writable,omitempty"`
		} `json:"accounts,omitempty"`

		// Args List of instruction arguments.
		Args []struct {
			// Name The argument name.
			Name string `json:"name"`

			// Type The argument type.
			Type string `json:"type"`
		} `json:"args"`

		// Discriminator Array of 8 numbers representing the instruction discriminator.
		Discriminator []int `json:"discriminator"`

		// Name The instruction name.
		Name string `json:"name"`
	} `json:"instructions"`

	// Metadata Optional metadata about the IDL.
	Metadata *struct {
		// Name The program name.
		Name *string `json:"name,omitempty"`

		// Spec The IDL specification version.
		Spec *string `json:"spec,omitempty"`

		// Version The program version.
		Version *string `json:"version,omitempty"`
	} `json:"metadata,omitempty"`

	// Types Optional type definitions for custom data structures used in the program.
	Types *[]map[string]interface{} `json:"types,omitempty"`
}

// KnownAbiType A reference to an established EIP standard. When referencing a `KnownAbiType` within a policy rule configuring an `EvmDataCriterion`, criteria will only decode function data officially documented in the standard. For more information on supported token standards, see the links below.
//   - [erc20 - Token Standard](https://eips.ethereum.org/EIPS/eip-20).
//   - [erc721 - Non-Fungible Token Standard](https://eips.ethereum.org/EIPS/eip-721).
//   - [erc1155 - Multi Token Standard](https://eips.ethereum.org/EIPS/eip-1155).
type KnownAbiType string

// KnownIdlType A reference to an established Solana program. When referencing a `KnownIdlType` within a policy rule configuring an `SolDataCriterion`, criteria will decode instruction data as documented in the programs. For more information on supported programs, see the links below.
//   - [SystemProgram](https://docs.rs/solana-program/latest/solana_program/system_instruction/enum.SystemInstruction.html).
//   - [TokenProgram](https://docs.rs/spl-token/latest/spl_token/instruction/enum.TokenInstruction.html).
//   - [AssociatedTokenProgram](https://docs.rs/spl-associated-token-account/latest/spl_associated_token_account/instruction/index.html).
type KnownIdlType string

// ListEvmTokenBalancesNetwork The name of the supported EVM networks in human-readable format.
type ListEvmTokenBalancesNetwork string

// ListResponse defines model for ListResponse.
type ListResponse struct {
	// NextPageToken The token for the next page of items, if any.
	NextPageToken *string `json:"nextPageToken,omitempty"`
}

// ListSolanaTokenBalancesNetwork The name of the supported Solana networks in human-readable format.
type ListSolanaTokenBalancesNetwork string

// MFAMethods Information about the end user's MFA enrollments.
type MFAMethods struct {
	// EnrollmentPromptedAt The date and time when the end user was prompted for MFA enrollment, in ISO 8601 format. If the this field exists, and the user has no other enrolled MFA methods, then the user skipped MFA enrollment.
	EnrollmentPromptedAt *time.Time `json:"enrollmentPromptedAt,omitempty"`

	// Sms An object containing information about the end user's SMS MFA enrollment.
	Sms *struct {
		// EnrolledAt The date and time when the method was enrolled, in ISO 8601 format.
		EnrolledAt time.Time `json:"enrolledAt"`
	} `json:"sms,omitempty"`

	// Totp An object containing information about the end user's TOTP enrollment.
	Totp *struct {
		// EnrolledAt The date and time when the method was enrolled, in ISO 8601 format.
		EnrolledAt time.Time `json:"enrolledAt"`
	} `json:"totp,omitempty"`
}

// MintAddressCriterion The criterion for the token mint addresses of a Solana transaction's SPL token transfer instructions.
type MintAddressCriterion struct {
	// Addresses The Solana addresses that are compared to the list of token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.
	Addresses []string `json:"addresses"`

	// Operator The operator to use for the comparison. Each of the token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
	Operator MintAddressCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `mintAddress`.
	Type MintAddressCriterionType `json:"type"`
}

// MintAddressCriterionOperator The operator to use for the comparison. Each of the token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
type MintAddressCriterionOperator string

// MintAddressCriterionType The type of criterion to use. This should be `mintAddress`.
type MintAddressCriterionType string

// NetUSDChangeCriterion A schema for specifying a criterion for the USD denominated asset transfer or exposure for a transaction. This includes native transfers, as well as token transfers.
type NetUSDChangeCriterion struct {
	// ChangeCents The amount of USD, in cents, that the total value of a transaction's asset transfer should be compared to.
	ChangeCents int `json:"changeCents"`

	// Operator The operator to use for the comparison. The total value of a transaction's asset transfer will be on the left-hand side of the operator, and the `changeCents` field will be on the right-hand side.
	Operator NetUSDChangeCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `netUSDChange`.
	Type NetUSDChangeCriterionType `json:"type"`
}

// NetUSDChangeCriterionOperator The operator to use for the comparison. The total value of a transaction's asset transfer will be on the left-hand side of the operator, and the `changeCents` field will be on the right-hand side.
type NetUSDChangeCriterionOperator string

// NetUSDChangeCriterionType The type of criterion to use. This should be `netUSDChange`.
type NetUSDChangeCriterionType string

// OAuth2Authentication Information about an end user who authenticates using a third-party provider.
type OAuth2Authentication struct {
	// Email The email address of the end user contained within the user's ID token, if available from third-party OAuth2 provider's token exchange.
	Email *string `json:"email,omitempty"`

	// Name The full name of the end user if available from third-party OAuth2 provider's token exchange.
	Name *string `json:"name,omitempty"`

	// Sub The unique identifier for the end user that is captured in the `sub` claim of the JWT.
	Sub string `json:"sub"`

	// Type The type of OAuth2 provider.
	Type OAuth2ProviderType `json:"type"`

	// Username The username of the end user if available from third-party OAuth2 provider's token exchange.
	Username *string `json:"username,omitempty"`
}

// OAuth2ProviderType The type of OAuth2 provider.
type OAuth2ProviderType string

// OnchainDataQuery Request to execute a SQL query against indexed blockchain data.
type OnchainDataQuery struct {
	// Cache Enables control over how often queries need to be fully re-executed on the backing store.
	// This can be useful in scenarios where API calls might be made frequently, API latency is critical, and some freshness lag (ex: 750ms, 2s, 5s) is tolerable.
	// By default, each query result is returned from cache so long as the result is from an identical query and less than 500ms old. This freshness tolerance can be modified upwards, to a maximum of 900000ms (i.e. 900s, 15m).
	Cache *struct {
		// MaxAgeMs The maximum tolerable staleness of the query result cache in milliseconds. If a previous execution result of an identical query is older than this age, the query will be re-executed. If the data is less than this age, the result will be returned from cache.
		MaxAgeMs *int `json:"maxAgeMs,omitempty"`
	} `json:"cache,omitempty"`

	// Sql SQL query to execute against the indexed blockchain data.
	Sql string `json:"sql"`
}

// OnchainDataResult Result of executing a SQL query.
type OnchainDataResult struct {
	// Metadata Metadata about query execution.
	Metadata *struct {
		// Cached Whether the result was served from the query result cache.
		Cached *bool `json:"cached,omitempty"`

		// ExecutionTimeMs Query execution time in milliseconds.
		ExecutionTimeMs *int `json:"executionTimeMs,omitempty"`

		// ExecutionTimestamp When the query result was executed against the backing store in RFC 3339 format.
		ExecutionTimestamp *time.Time `json:"executionTimestamp,omitempty"`

		// RowCount Number of rows returned.
		RowCount *int `json:"rowCount,omitempty"`
	} `json:"metadata,omitempty"`

	// Result Query result as an array of objects representing rows.
	Result *[]map[string]interface{} `json:"result,omitempty"`

	// Schema Schema information for the query result. This is a derived schema from the query result, so types may not match the underlying table.
	Schema *struct {
		// Columns Column definitions.
		Columns *[]struct {
			// Name Column name.
			Name *string `json:"name,omitempty"`

			// Type Column data type (ClickHouse types).
			Type *OnchainDataResultSchemaColumnsType `json:"type,omitempty"`
		} `json:"columns,omitempty"`
	} `json:"schema,omitempty"`
}

// OnchainDataResultSchemaColumnsType Column data type (ClickHouse types).
type OnchainDataResultSchemaColumnsType string

// OnrampOrder An Onramp order.
type OnrampOrder struct {
	// CreatedAt The date and time the order was created.
	CreatedAt string `json:"createdAt"`

	// DestinationAddress The destination address to send the crypto to.
	DestinationAddress string `json:"destinationAddress"`

	// DestinationNetwork The network to send the crypto on.
	DestinationNetwork string `json:"destinationNetwork"`

	// ExchangeRate The exchange rate used to convert fiat to crypto i.e. the crypto value of one fiat.
	ExchangeRate string `json:"exchangeRate"`

	// Fees The fees associated with the order.
	Fees []OnrampOrderFee `json:"fees"`

	// OrderId The ID of the onramp order.
	OrderId string `json:"orderId"`

	// PartnerUserRef The partner user reference ID.
	PartnerUserRef *string `json:"partnerUserRef,omitempty"`

	// PaymentCurrency The fiat currency to be converted to crypto.
	PaymentCurrency string `json:"paymentCurrency"`

	// PaymentMethod The type of payment method to be used to complete an onramp order.
	PaymentMethod OnrampOrderPaymentMethodTypeId `json:"paymentMethod"`

	// PaymentSubtotal The amount of fiat to be converted to crypto.
	PaymentSubtotal string `json:"paymentSubtotal"`

	// PaymentTotal The total amount of fiat to be paid, inclusive of any fees.
	PaymentTotal string `json:"paymentTotal"`

	// PurchaseAmount The amount of crypto to be purchased.
	PurchaseAmount string `json:"purchaseAmount"`

	// PurchaseCurrency The crypto currency to be purchased.
	PurchaseCurrency string `json:"purchaseCurrency"`

	// Status The status of an onramp order.
	Status OnrampOrderStatus `json:"status"`

	// TxHash The transaction hash of the order (only available once crypto has been sent).
	TxHash *string `json:"txHash,omitempty"`

	// UpdatedAt The date and time the order was last updated.
	UpdatedAt string `json:"updatedAt"`
}

// OnrampOrderFee A fee associated with an order.
type OnrampOrderFee struct {
	// Amount The amount of the fee.
	Amount string `json:"amount"`

	// Currency The currency of the fee.
	Currency string `json:"currency"`

	// Type The type of fee.
	Type OnrampOrderFeeType `json:"type"`
}

// OnrampOrderFeeType The type of fee.
type OnrampOrderFeeType string

// OnrampOrderPaymentMethodTypeId The type of payment method to be used to complete an onramp order.
type OnrampOrderPaymentMethodTypeId string

// OnrampOrderStatus The status of an onramp order.
type OnrampOrderStatus string

// OnrampPaymentLink A payment link to pay for an order.
//
// Please refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/onramp-overview) for details on how to integrate with the different payment link types.
type OnrampPaymentLink struct {
	// PaymentLinkType The type of payment link.
	PaymentLinkType OnrampPaymentLinkType `json:"paymentLinkType"`

	// Url The URL to the hosted widget the user should be redirected to. For certain payment link types you can append your own redirect_url query parameter to this URL to ensure the user is redirected back to your app after the widget completes.
	Url Url `json:"url"`
}

// OnrampPaymentLinkType The type of payment link.
type OnrampPaymentLinkType string

// OnrampQuote Quote information with pricing details for the crypto purchase.
type OnrampQuote struct {
	// DestinationNetwork The network to send the crypto on.
	DestinationNetwork string `json:"destinationNetwork"`

	// ExchangeRate The exchange rate used to convert fiat to crypto i.e. the crypto value of one fiat.
	ExchangeRate string `json:"exchangeRate"`

	// Fees The fees associated with the quote.
	Fees []OnrampOrderFee `json:"fees"`

	// PaymentCurrency The fiat currency to be converted to crypto.
	PaymentCurrency string `json:"paymentCurrency"`

	// PaymentSubtotal The amount of fiat to be converted to crypto.
	PaymentSubtotal string `json:"paymentSubtotal"`

	// PaymentTotal The total amount of fiat to be paid, inclusive of any fees.
	PaymentTotal string `json:"paymentTotal"`

	// PurchaseAmount The amount of crypto to be purchased.
	PurchaseAmount string `json:"purchaseAmount"`

	// PurchaseCurrency The crypto currency to be purchased.
	PurchaseCurrency string `json:"purchaseCurrency"`
}

// OnrampQuotePaymentMethodTypeId The type of payment method used to generate the onramp quote.
type OnrampQuotePaymentMethodTypeId string

// OnrampSession An onramp session containing a ready-to-use onramp URL.
type OnrampSession struct {
	// OnrampUrl Ready-to-use onramp URL.
	OnrampUrl Url `json:"onrampUrl"`
}

// Policy defines model for Policy.
type Policy struct {
	// CreatedAt The ISO 8601 timestamp at which the Policy was created.
	CreatedAt string `json:"createdAt"`

	// Description An optional human-readable description of the policy.
	// Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.
	Description *string `json:"description,omitempty"`

	// Id The unique identifier for the policy.
	Id string `json:"id"`

	// Rules A list of rules that comprise the policy.
	Rules []Rule `json:"rules"`

	// Scope The scope of the policy. Only one project-level policy can exist at any time.
	Scope PolicyScope `json:"scope"`

	// UpdatedAt The ISO 8601 timestamp at which the Policy was last updated.
	UpdatedAt string `json:"updatedAt"`
}

// PolicyScope The scope of the policy. Only one project-level policy can exist at any time.
type PolicyScope string

// PrepareUserOperationCriteria A schema for specifying criteria for the PrepareUserOperation operation.
type PrepareUserOperationCriteria = []PrepareUserOperationCriteria_Item

// PrepareUserOperationCriteria_Item defines model for PrepareUserOperationCriteria.Item.
type PrepareUserOperationCriteria_Item struct {
	union json.RawMessage
}

// PrepareUserOperationRule defines model for PrepareUserOperationRule.
type PrepareUserOperationRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action PrepareUserOperationRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the PrepareUserOperation operation.
	Criteria PrepareUserOperationCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation PrepareUserOperationRuleOperation `json:"operation"`
}

// PrepareUserOperationRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type PrepareUserOperationRuleAction string

// PrepareUserOperationRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type PrepareUserOperationRuleOperation string

// ProgramIdCriterion The criterion for the program IDs of a Solana transaction's instructions.
type ProgramIdCriterion struct {
	// Operator The operator to use for the comparison. Each of the program IDs in the transaction's instructions will be on the left-hand side of the operator, and the `programIds` field will be on the right-hand side.
	Operator ProgramIdCriterionOperator `json:"operator"`

	// ProgramIds The Solana program IDs that are compared to the list of program IDs in the transaction's instructions.
	ProgramIds []string `json:"programIds"`

	// Type The type of criterion to use. This should be `programId`.
	Type ProgramIdCriterionType `json:"type"`
}

// ProgramIdCriterionOperator The operator to use for the comparison. Each of the program IDs in the transaction's instructions will be on the left-hand side of the operator, and the `programIds` field will be on the right-hand side.
type ProgramIdCriterionOperator string

// ProgramIdCriterionType The type of criterion to use. This should be `programId`.
type ProgramIdCriterionType string

// RevokeSpendPermissionRequest Request parameters for revoking a Spend Permission.
type RevokeSpendPermissionRequest struct {
	// Network The network the spend permission is on.
	Network SpendPermissionNetwork `json:"network"`

	// PaymasterUrl The paymaster URL of the spend permission.
	PaymasterUrl *Url `json:"paymasterUrl,omitempty"`

	// PermissionHash The hash of the spend permission to revoke.
	PermissionHash string `json:"permissionHash"`
}

// Rule A rule that limits the behavior of an account.
type Rule struct {
	union json.RawMessage
}

// SendEvmTransactionCriteria A schema for specifying criteria for the SignEvmTransaction operation.
type SendEvmTransactionCriteria = []SendEvmTransactionCriteria_Item

// SendEvmTransactionCriteria_Item defines model for SendEvmTransactionCriteria.Item.
type SendEvmTransactionCriteria_Item struct {
	union json.RawMessage
}

// SendEvmTransactionRule defines model for SendEvmTransactionRule.
type SendEvmTransactionRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SendEvmTransactionRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SignEvmTransaction operation.
	Criteria SendEvmTransactionCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SendEvmTransactionRuleOperation `json:"operation"`
}

// SendEvmTransactionRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SendEvmTransactionRuleAction string

// SendEvmTransactionRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SendEvmTransactionRuleOperation string

// SendSolTransactionCriteria A schema for specifying criteria for the SendSolTransaction operation.
type SendSolTransactionCriteria = []SendSolTransactionCriteria_Item

// SendSolTransactionCriteria_Item defines model for SendSolTransactionCriteria.Item.
type SendSolTransactionCriteria_Item struct {
	union json.RawMessage
}

// SendSolTransactionRule defines model for SendSolTransactionRule.
type SendSolTransactionRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SendSolTransactionRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SendSolTransaction operation.
	Criteria SendSolTransactionCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SendSolTransactionRuleOperation `json:"operation"`
}

// SendSolTransactionRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SendSolTransactionRuleAction string

// SendSolTransactionRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SendSolTransactionRuleOperation string

// SendUserOperationCriteria A schema for specifying criteria for the SendUserOperation operation.
type SendUserOperationCriteria = []SendUserOperationCriteria_Item

// SendUserOperationCriteria_Item defines model for SendUserOperationCriteria.Item.
type SendUserOperationCriteria_Item struct {
	union json.RawMessage
}

// SendUserOperationRule defines model for SendUserOperationRule.
type SendUserOperationRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SendUserOperationRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SendUserOperation operation.
	Criteria SendUserOperationCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SendUserOperationRuleOperation `json:"operation"`
}

// SendUserOperationRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SendUserOperationRuleAction string

// SendUserOperationRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SendUserOperationRuleOperation string

// SignEvmHashRule defines model for SignEvmHashRule.
type SignEvmHashRule struct {
	// Action Whether any attempts to sign a hash will be accepted or rejected. This rule does not accept any criteria.
	Action SignEvmHashRuleAction `json:"action"`

	// Operation The operation to which the rule applies.
	Operation SignEvmHashRuleOperation `json:"operation"`
}

// SignEvmHashRuleAction Whether any attempts to sign a hash will be accepted or rejected. This rule does not accept any criteria.
type SignEvmHashRuleAction string

// SignEvmHashRuleOperation The operation to which the rule applies.
type SignEvmHashRuleOperation string

// SignEvmMessageCriteria A schema for specifying the rejection criteria for the SignEvmMessage operation.
type SignEvmMessageCriteria = []SignEvmMessageCriteria_Item

// SignEvmMessageCriteria_Item defines model for SignEvmMessageCriteria.Item.
type SignEvmMessageCriteria_Item struct {
	union json.RawMessage
}

// SignEvmMessageRule defines model for SignEvmMessageRule.
type SignEvmMessageRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SignEvmMessageRuleAction `json:"action"`

	// Criteria A schema for specifying the rejection criteria for the SignEvmMessage operation.
	Criteria SignEvmMessageCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SignEvmMessageRuleOperation `json:"operation"`
}

// SignEvmMessageRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SignEvmMessageRuleAction string

// SignEvmMessageRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SignEvmMessageRuleOperation string

// SignEvmTransactionCriteria A schema for specifying criteria for the SignEvmTransaction operation.
type SignEvmTransactionCriteria = []SignEvmTransactionCriteria_Item

// SignEvmTransactionCriteria_Item defines model for SignEvmTransactionCriteria.Item.
type SignEvmTransactionCriteria_Item struct {
	union json.RawMessage
}

// SignEvmTransactionRule defines model for SignEvmTransactionRule.
type SignEvmTransactionRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SignEvmTransactionRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SignEvmTransaction operation.
	Criteria SignEvmTransactionCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SignEvmTransactionRuleOperation `json:"operation"`
}

// SignEvmTransactionRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SignEvmTransactionRuleAction string

// SignEvmTransactionRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SignEvmTransactionRuleOperation string

// SignEvmTypedDataCriteria A schema for specifying criteria for the SignEvmTypedData operation.
type SignEvmTypedDataCriteria = []SignEvmTypedDataCriteria_Item

// SignEvmTypedDataCriteria_Item defines model for SignEvmTypedDataCriteria.Item.
type SignEvmTypedDataCriteria_Item struct {
	union json.RawMessage
}

// SignEvmTypedDataFieldCriterion defines model for SignEvmTypedDataFieldCriterion.
type SignEvmTypedDataFieldCriterion struct {
	// Conditions A list of conditions to check against the data being signed. Each condition must be met for the rule to take effect.
	Conditions []SignEvmTypedDataFieldCriterion_Conditions_Item `json:"conditions"`

	// Type The type of criterion to use. This should be `evmTypedDataField`.
	Type SignEvmTypedDataFieldCriterionType `json:"type"`

	// Types An object containing EIP-712 type definitions, as well as a primary type for the root message object.
	Types struct {
		// PrimaryType The name of the root EIP-712 type. This value must be included in the `types` object.
		PrimaryType string `json:"primaryType"`

		// Types EIP-712 compliant map of model names to model definitions.
		Types map[string][]struct {
			// Name The name of a key within an EIP-712 data structure.
			Name *string `json:"name,omitempty"`

			// Type The Solidity type of a value within an EIP-712 data structure.
			Type *string `json:"type,omitempty"`
		} `json:"types"`
	} `json:"types"`
}

// SignEvmTypedDataFieldCriterion_Conditions_Item defines model for SignEvmTypedDataFieldCriterion.conditions.Item.
type SignEvmTypedDataFieldCriterion_Conditions_Item struct {
	union json.RawMessage
}

// SignEvmTypedDataFieldCriterionType The type of criterion to use. This should be `evmTypedDataField`.
type SignEvmTypedDataFieldCriterionType string

// SignEvmTypedDataRule defines model for SignEvmTypedDataRule.
type SignEvmTypedDataRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SignEvmTypedDataRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SignEvmTypedData operation.
	Criteria SignEvmTypedDataCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SignEvmTypedDataRuleOperation `json:"operation"`
}

// SignEvmTypedDataRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SignEvmTypedDataRuleAction string

// SignEvmTypedDataRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SignEvmTypedDataRuleOperation string

// SignEvmTypedDataVerifyingContractCriterion A schema for specifying criterion for a domain's verifying contract.
type SignEvmTypedDataVerifyingContractCriterion struct {
	// Addresses A list of 0x-prefixed EVM addresses that the domain's verifying contract should be compared to. There is a limit of 300 addresses per criterion.
	Addresses []string `json:"addresses"`

	// Operator The operator to use for the comparison. The domain's verifying contract will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
	Operator SignEvmTypedDataVerifyingContractCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `evmTypedDataVerifyingContract`.
	Type SignEvmTypedDataVerifyingContractCriterionType `json:"type"`
}

// SignEvmTypedDataVerifyingContractCriterionOperator The operator to use for the comparison. The domain's verifying contract will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
type SignEvmTypedDataVerifyingContractCriterionOperator string

// SignEvmTypedDataVerifyingContractCriterionType The type of criterion to use. This should be `evmTypedDataVerifyingContract`.
type SignEvmTypedDataVerifyingContractCriterionType string

// SignSolMessageCriteria A schema for specifying criteria for the SignSolMessage operation.
type SignSolMessageCriteria = []SignSolMessageCriteria_Item

// SignSolMessageCriteria_Item defines model for SignSolMessageCriteria.Item.
type SignSolMessageCriteria_Item struct {
	union json.RawMessage
}

// SignSolMessageRule defines model for SignSolMessageRule.
type SignSolMessageRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SignSolMessageRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SignSolMessage operation.
	Criteria SignSolMessageCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SignSolMessageRuleOperation `json:"operation"`
}

// SignSolMessageRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SignSolMessageRuleAction string

// SignSolMessageRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SignSolMessageRuleOperation string

// SignSolTransactionCriteria A schema for specifying criteria for the SignSolTransaction operation.
type SignSolTransactionCriteria = []SignSolTransactionCriteria_Item

// SignSolTransactionCriteria_Item defines model for SignSolTransactionCriteria.Item.
type SignSolTransactionCriteria_Item struct {
	union json.RawMessage
}

// SignSolTransactionRule defines model for SignSolTransactionRule.
type SignSolTransactionRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SignSolTransactionRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SignSolTransaction operation.
	Criteria SignSolTransactionCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SignSolTransactionRuleOperation `json:"operation"`
}

// SignSolTransactionRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SignSolTransactionRuleAction string

// SignSolTransactionRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SignSolTransactionRuleOperation string

// SmsAuthentication Information about an end user who authenticates using a one-time password sent to their phone number via SMS.
type SmsAuthentication struct {
	// PhoneNumber The phone number of the end user in E.164 format.
	PhoneNumber string `json:"phoneNumber"`

	// Type The type of authentication information.
	Type SmsAuthenticationType `json:"type"`
}

// SmsAuthenticationType The type of authentication information.
type SmsAuthenticationType string

// SolAddressCriterion The criterion for the recipient addresses of a Solana transaction's native transfer instruction.
type SolAddressCriterion struct {
	// Addresses The Solana addresses that are compared to the list of native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.
	Addresses []string `json:"addresses"`

	// Operator The operator to use for the comparison. Each of the native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
	Operator SolAddressCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `solAddress`.
	Type SolAddressCriterionType `json:"type"`
}

// SolAddressCriterionOperator The operator to use for the comparison. Each of the native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
type SolAddressCriterionOperator string

// SolAddressCriterionType The type of criterion to use. This should be `solAddress`.
type SolAddressCriterionType string

// SolDataCondition A single condition to apply against a specific instruction type and its parameters.
type SolDataCondition struct {
	// Instruction The instruction name.
	Instruction string `json:"instruction"`

	// Params Parameter conditions for the instruction.
	Params *[]SolDataCondition_Params_Item `json:"params,omitempty"`
}

// SolDataCondition_Params_Item A list of parameter conditions to apply against a specific instruction's data.
type SolDataCondition_Params_Item struct {
	union json.RawMessage
}

// SolDataCriterion A schema for specifying criterion for instruction data in a Solana transaction.
type SolDataCriterion struct {
	// Conditions A list of conditions to apply against the transaction instruction. Only one condition must evaluate to true for this criterion to be met.
	Conditions []SolDataCondition `json:"conditions"`

	// Idls List of IDL specifications. Can contain known program names (strings) or custom IDL objects.
	Idls []SolDataCriterion_Idls_Item `json:"idls"`

	// Type The type of criterion to use. This should be `solData`.
	Type SolDataCriterionType `json:"type"`
}

// SolDataCriterion_Idls_Item defines model for SolDataCriterion.idls.Item.
type SolDataCriterion_Idls_Item struct {
	union json.RawMessage
}

// SolDataCriterionType The type of criterion to use. This should be `solData`.
type SolDataCriterionType string

// SolDataParameterCondition A single parameter condition to apply against a specific instruction's parameters.
type SolDataParameterCondition struct {
	// Name The parameter name.
	Name string `json:"name"`

	// Operator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
	Operator SolDataParameterConditionOperator `json:"operator"`

	// Value The value to compare against.
	Value string `json:"value"`
}

// SolDataParameterConditionOperator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
type SolDataParameterConditionOperator string

// SolDataParameterConditionList A single parameter condition to apply against a specific instruction's parameters.
type SolDataParameterConditionList struct {
	// Name The parameter name.
	Name string `json:"name"`

	// Operator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
	Operator SolDataParameterConditionListOperator `json:"operator"`

	// Values The values to compare against.
	Values []string `json:"values"`
}

// SolDataParameterConditionListOperator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
type SolDataParameterConditionListOperator string

// SolMessageCriterion The criterion for the message of a Solana transaction.
type SolMessageCriterion struct {
	// Match A regular expression the field is matched against.
	Match string `json:"match"`

	// Type The type of criterion to use. This should be `solMessage`.
	Type SolMessageCriterionType `json:"type"`
}

// SolMessageCriterionType The type of criterion to use. This should be `solMessage`.
type SolMessageCriterionType string

// SolNetworkCriterion The criterion for the Solana network of a transaction.
type SolNetworkCriterion struct {
	// Networks The Solana networks that the transaction's intended network should be compared to.
	Networks []SolNetworkCriterionNetworks `json:"networks"`

	// Operator The operator to use for the comparison. The transaction's intended network will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.
	Operator SolNetworkCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `solNetwork`.
	Type SolNetworkCriterionType `json:"type"`
}

// SolNetworkCriterionNetworks The Solana network the transaction is for.
type SolNetworkCriterionNetworks string

// SolNetworkCriterionOperator The operator to use for the comparison. The transaction's intended network will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.
type SolNetworkCriterionOperator string

// SolNetworkCriterionType The type of criterion to use. This should be `solNetwork`.
type SolNetworkCriterionType string

// SolValueCriterion The criterion for the SOL value in lamports of a native transfer instruction in a Solana transaction.
type SolValueCriterion struct {
	// Operator The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `solValue` field will be on the right-hand side.
	Operator SolValueCriterionOperator `json:"operator"`

	// SolValue The amount of SOL in lamports that the transaction instruction's `value` field should be compared to.
	SolValue string `json:"solValue"`

	// Type The type of criterion to use. This should be `solValue`.
	Type SolValueCriterionType `json:"type"`
}

// SolValueCriterionOperator The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `solValue` field will be on the right-hand side.
type SolValueCriterionOperator string

// SolValueCriterionType The type of criterion to use. This should be `solValue`.
type SolValueCriterionType string

// SolanaAccount defines model for SolanaAccount.
type SolanaAccount struct {
	// Address The base58 encoded Solana address.
	Address string `json:"address"`

	// CreatedAt The ISO 8601 UTC timestamp at which the account was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names are guaranteed to be unique across all Solana accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`

	// Policies The list of policy IDs that apply to the account. This will include both the project-level policy and the account-level policy, if one exists.
	Policies *[]string `json:"policies,omitempty"`

	// UpdatedAt The ISO 8601 UTC timestamp at which the account was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// SolanaToken General information about a Solana token. Includes the mint address, and other identifying information.
type SolanaToken struct {
	// MintAddress The mint address of the token.
	// For native SOL, the mint address is `So11111111111111111111111111111111111111111`. For SPL tokens, this is the mint address where the token is defined.
	MintAddress string `json:"mintAddress"`

	// Name The name of this token (ex: "Solana", "USD Coin", "Raydium").
	// The token name is not unique. It is possible for two different tokens to have the same name.
	// For the native SOL token, this name is "Solana". For SPL tokens, this name is defined in the token's metadata.
	// Not all tokens have a name. This field will only be populated when the token has metadata available.
	Name *string `json:"name,omitempty"`

	// Symbol The symbol of this token (ex: SOL, USDC, RAY).
	// The token symbol is not unique. It is possible for two different tokens to have the same symbol.
	// For the native SOL token, this symbol is "SOL". For SPL tokens, this symbol is defined in the token's metadata.
	// Not all tokens have a symbol. This field will only be populated when the token has metadata available.
	Symbol *string `json:"symbol,omitempty"`
}

// SolanaTokenAmount Amount of a given Solana token.
type SolanaTokenAmount struct {
	// Amount The amount is denominated in the smallest indivisible unit of the token. For SOL, the smallest indivisible unit is lamports (10^-9 SOL). For SPL tokens, the smallest unit is defined by the token's decimals configuration.
	Amount string `json:"amount"`

	// Decimals 'decimals' is the exponential value N that satisfies the equation `amount * 10^-N = standard_denomination`. The standard denomination is the most commonly used denomination for the token.
	// - For native SOL, `decimals` is 9 (1 SOL = 10^9 lamports). - For SPL tokens, `decimals` is defined in the token's mint configuration.
	Decimals int64 `json:"decimals"`
}

// SolanaTokenBalance defines model for SolanaTokenBalance.
type SolanaTokenBalance struct {
	// Amount Amount of a given Solana token.
	Amount SolanaTokenAmount `json:"amount"`

	// Token General information about a Solana token. Includes the mint address, and other identifying information.
	Token SolanaToken `json:"token"`
}

// SpendPermission The core spend permission.
type SpendPermission struct {
	// Account Smart account this spend permission is valid for.
	Account string `json:"account"`

	// Allowance Maximum allowed value to spend, in atomic units for the specified token, within each period.
	Allowance string `json:"allowance"`

	// End The expiration time for this spend permission, in Unix seconds.
	End string `json:"end"`

	// ExtraData Arbitrary data to include in the permission.
	ExtraData string `json:"extraData"`

	// Period Time duration for resetting used allowance on a recurring basis (seconds).
	Period string `json:"period"`

	// Salt An arbitrary salt to differentiate unique spend permissions with otherwise identical data.
	Salt string `json:"salt"`

	// Spender Entity that can spend account's tokens.
	Spender string `json:"spender"`

	// Start The start time for this spend permission, in Unix seconds.
	Start string `json:"start"`

	// Token Token address (ERC-7528 native token address or ERC-20 contract).
	Token string `json:"token"`
}

// SpendPermissionNetwork The network the spend permission is on.
type SpendPermissionNetwork string

// SpendPermissionResponseObject defines model for SpendPermissionResponseObject.
type SpendPermissionResponseObject struct {
	// CreatedAt The UTC ISO 8601 timestamp when the permission was created.
	CreatedAt time.Time `json:"createdAt"`

	// Network The network the spend permission is on.
	Network SpendPermissionNetwork `json:"network"`

	// Permission The core spend permission.
	Permission SpendPermission `json:"permission"`

	// PermissionHash Unique hash identifier for this permission.
	PermissionHash string `json:"permissionHash"`

	// Revoked Whether this permission has been revoked.
	Revoked bool `json:"revoked"`

	// RevokedAt The UTC ISO 8601 timestamp when the permission was revoked (if applicable).
	RevokedAt *time.Time `json:"revokedAt,omitempty"`
}

// SplAddressCriterion The criterion for the recipient addresses of a Solana transaction's SPL token transfer instructions.
type SplAddressCriterion struct {
	// Addresses The Solana addresses that are compared to the list of SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.
	Addresses []string `json:"addresses"`

	// Operator The operator to use for the comparison. Each of the SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
	Operator SplAddressCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `splAddress`.
	Type SplAddressCriterionType `json:"type"`
}

// SplAddressCriterionOperator The operator to use for the comparison. Each of the SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
type SplAddressCriterionOperator string

// SplAddressCriterionType The type of criterion to use. This should be `splAddress`.
type SplAddressCriterionType string

// SplValueCriterion The criterion for the SPL token value of a SPL token transfer instruction in a Solana transaction.
type SplValueCriterion struct {
	// Operator The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `splValue` field will be on the right-hand side.
	Operator SplValueCriterionOperator `json:"operator"`

	// SplValue The amount of the SPL token that the transaction instruction's `value` field should be compared to.
	SplValue string `json:"splValue"`

	// Type The type of criterion to use. This should be `splValue`.
	Type SplValueCriterionType `json:"type"`
}

// SplValueCriterionOperator The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `splValue` field will be on the right-hand side.
type SplValueCriterionOperator string

// SplValueCriterionType The type of criterion to use. This should be `splValue`.
type SplValueCriterionType string

// SwapUnavailableResponse defines model for SwapUnavailableResponse.
type SwapUnavailableResponse struct {
	// LiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
	LiquidityAvailable SwapUnavailableResponseLiquidityAvailable `json:"liquidityAvailable"`
}

// SwapUnavailableResponseLiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
type SwapUnavailableResponseLiquidityAvailable bool

// Token General information about a token. Includes the type, the network, and other identifying information.
type Token struct {
	// ContractAddress The contract address of the token.
	// For Ether, the contract address is `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` per [EIP-7528](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7528.md). For ERC-20 tokens, this is the contract address where the token is deployed.
	ContractAddress string `json:"contractAddress"`

	// Name The name of this token (ex: "Solana", "Ether", "USD Coin").
	// The token name is not unique. It is possible for two different tokens to have the same name.
	// For native gas tokens, this name is defined via convention. As an example, for ETH on Ethereum mainnet, the name is "Ether". For ERC-20 tokens, this name is defined via configuration. `name` will be the string returned by `function name() public view returns (string)` on the underlying token contract.
	// Not all tokens have a name, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#name). This field will only be populated when the token's underlying ERC-20 contract has a `name()` function.
	// Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.
	Name *string `json:"name,omitempty"`

	// Network The name of the supported EVM networks in human-readable format.
	Network ListEvmTokenBalancesNetwork `json:"network"`

	// Symbol The symbol of this token (ex: SOL, ETH, USDC).
	// The token symbol is not unique. It is possible for two different tokens to have the same symbol.
	// For native gas tokens, this symbol is defined via convention. As an example, for ETH on Ethereum mainnet, the symbol is "ETH". For ERC-20 tokens, this symbol is defined via configuration. `symbol` will be the string returned by `function symbol() public view returns (string)` on the underlying token contract.
	// Not all tokens have a symbol, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#symbol). This field will only be populated when the token's underlying ERC-20 contract has a `symbol()` function.
	// Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.
	Symbol *string `json:"symbol,omitempty"`
}

// TokenAmount Amount of a given token.
type TokenAmount struct {
	// Amount The amount is denominated in the smallest indivisible unit of the token. For ETH, the smallest indivisible unit is Wei (10^-18 ETH). For ERC-20s, the smallest unit is the unit returned from `function totalSupply() public view returns (uint256)`.
	Amount string `json:"amount"`

	// Decimals 'decimals' is the exponential value N that satisfies the equation `amount * 10^-N = standard_denomination`. The standard denomination is the most commonly used denomination for the token.
	// - In the case of the native gas token, `decimals` is defined via convention. As an example, for ETH of Ethereum mainnet, the standard denomination is 10^-18 the smallest denomination (Wei). As such, for ETH on Ethereum mainnet, `decimals` is 18. - In the case of ERC-20 tokens, `decimals` is defined via configuration. `decimals` will be the number returned by `function decimals() public view returns (uint8)` on the underlying token contract.
	// Not all tokens have a `decimals` field, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#decimals). This field will be left empty if the underlying token contract doesn't implement `decimals`.
	// Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.
	Decimals int64 `json:"decimals"`
}

// TokenBalance defines model for TokenBalance.
type TokenBalance struct {
	// Amount Amount of a given token.
	Amount TokenAmount `json:"amount"`

	// Token General information about a token. Includes the type, the network, and other identifying information.
	Token Token `json:"token"`
}

// TokenFee defines model for TokenFee.
type TokenFee struct {
	// Amount The estimated amount of the fee in atomic units of the `token`. For example, `1000000000000000` if the fee is in ETH equates to 0.001 ETH, `10000` if the fee is in USDC equates to 0.01 USDC, etc.
	Amount string `json:"amount"`

	// Token The contract address of the token that the fee is paid in. The address `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` is used for the native token of the network (e.g. ETH).
	Token string `json:"token"`
}

// Uri A valid URI.
type Uri = string

// Url A valid HTTP or HTTPS URL.
type Url = string

// UserOperationReceipt The receipt that contains information about the execution of user operation.
type UserOperationReceipt struct {
	// BlockHash The block hash of the block including the transaction as 0x-prefixed string.
	BlockHash *string `json:"blockHash,omitempty"`

	// BlockNumber The block height (number) of the block including the transaction.
	BlockNumber *int `json:"blockNumber,omitempty"`

	// GasUsed The gas used for landing this user operation.
	GasUsed *string `json:"gasUsed,omitempty"`

	// Revert The revert data if the user operation has reverted.
	Revert *UserOperationReceiptRevert `json:"revert,omitempty"`

	// TransactionHash The hash of this transaction as 0x-prefixed string.
	TransactionHash *string `json:"transactionHash,omitempty"`
}

// UserOperationReceiptRevert The revert data if the user operation has reverted.
type UserOperationReceiptRevert struct {
	// Data The 0x-prefixed raw hex string.
	Data string `json:"data"`

	// Message Human-readable revert reason if able to decode.
	Message string `json:"message"`
}

// WebhookSubscriptionListResponse defines model for WebhookSubscriptionListResponse.
type WebhookSubscriptionListResponse struct {
	// NextPageToken The token for the next page of items, if any.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// Subscriptions The list of webhook subscriptions.
	Subscriptions []WebhookSubscriptionResponse `json:"subscriptions"`
}

// WebhookSubscriptionRequest Request to create a new webhook subscription with support for both traditional single-label
// and multi-label filtering formats.
type WebhookSubscriptionRequest struct {
	// Description Description of the webhook subscription.
	Description *string `json:"description,omitempty"`

	// EventTypes Types of events to subscribe to. Event types follow a three-part dot-separated format:
	// service.resource.verb (e.g., "onchain.activity.detected", "wallet.activity.detected", "onramp.transaction.created").
	// The subscription will only receive events matching these types AND the label filter(s).
	EventTypes *[]string `json:"eventTypes,omitempty"`

	// IsEnabled Whether the subscription is enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// LabelKey (Deprecated) Use `labels` instead for better filtering capabilities, including filtering on multiple labels simultaneously.
	//
	// Label key for filtering events. Each subscription filters on exactly one (labelKey, labelValue) pair
	// in addition to the event types. Only events matching both the event types AND this label filter will be delivered.
	// NOTE: Use either (labelKey + labelValue) OR labels, not both.
	//
	// Maintained for backward compatibility only.
	// Deprecated:
	LabelKey *string `json:"labelKey,omitempty"`

	// LabelValue (Deprecated) Use `labels` instead for better filtering capabilities, including filtering on multiple labels simultaneously.
	//
	// Label value for filtering events. Must correspond to the labelKey (e.g., contract address for contract_address key).
	// Only events with this exact label value will be delivered.
	// NOTE: Use either (labelKey + labelValue) OR labels, not both.
	//
	// Maintained for backward compatibility only.
	// Deprecated:
	LabelValue *string `json:"labelValue,omitempty"`

	// Labels Multi-label filters using total overlap logic. Total overlap means the subscription will only trigger when
	// an event contains ALL the key-value pairs specified here. Additional labels on
	// the event are allowed and will not prevent matching.
	//
	// **Note:** Currently, labels are supported for onchain webhooks only.
	//
	// See [allowed labels for onchain webhooks](https://docs.cdp.coinbase.com/api-reference/v2/rest-api/webhooks/create-webhook-subscription#onchain-label-filtering).
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Additional metadata for the subscription.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Target Target configuration for webhook delivery.
	// Specifies the destination URL and any custom headers to include in webhook requests.
	Target *WebhookTarget `json:"target,omitempty"`
	union  json.RawMessage
}

// WebhookSubscriptionRequest0 defines model for .
type WebhookSubscriptionRequest0 = interface{}

// WebhookSubscriptionRequest1 defines model for .
type WebhookSubscriptionRequest1 = interface{}

// WebhookSubscriptionResponse Response containing webhook subscription details.
type WebhookSubscriptionResponse struct {
	// CreatedAt When the subscription was created.
	CreatedAt time.Time `json:"createdAt"`

	// Description Description of the webhook subscription.
	Description *string `json:"description,omitempty"`

	// EventTypes Types of events to subscribe to. Event types follow a three-part dot-separated format:
	// service.resource.verb (e.g., "onchain.activity.detected", "wallet.activity.detected", "onramp.transaction.created").
	EventTypes []string `json:"eventTypes"`

	// IsEnabled Whether the subscription is enabled.
	IsEnabled bool `json:"isEnabled"`

	// LabelKey (Deprecated) Use `labels` field instead.
	//
	// Label key for filtering events. Present when subscription uses traditional single-label format.
	// Maintained for backward compatibility only.
	// Deprecated:
	LabelKey *string `json:"labelKey,omitempty"`

	// LabelValue (Deprecated) Use `labels` field instead.
	//
	// Label value for filtering events. Present when subscription uses traditional single-label format.
	// Maintained for backward compatibility only.
	// Deprecated:
	LabelValue *string `json:"labelValue,omitempty"`

	// Labels Multi-label filters using total overlap logic. Total overlap means the subscription only triggers when events contain ALL these key-value pairs.
	// Present when subscription uses multi-label format.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Additional metadata for the subscription.
	Metadata *struct {
		// Secret Use the root-level `secret` field instead. Maintained for backward compatibility only.
		// Deprecated:
		Secret *openapi_types.UUID `json:"secret,omitempty"`
	} `json:"metadata,omitempty"`

	// Secret Secret for webhook signature validation.
	Secret openapi_types.UUID `json:"secret"`

	// SubscriptionId Unique identifier for the subscription.
	SubscriptionId openapi_types.UUID `json:"subscriptionId"`

	// Target Target configuration for webhook delivery.
	// Specifies the destination URL and any custom headers to include in webhook requests.
	Target WebhookTarget `json:"target"`
}

// WebhookSubscriptionUpdateRequest Request to update an existing webhook subscription. The update format must match
// the original subscription format (traditional or multi-label).
type WebhookSubscriptionUpdateRequest struct {
	// Description Description of the webhook subscription.
	Description *string `json:"description,omitempty"`

	// EventTypes Types of events to subscribe to. Event types follow a three-part dot-separated format:
	// service.resource.verb (e.g., "onchain.activity.detected", "wallet.activity.detected", "onramp.transaction.created").
	EventTypes *[]string `json:"eventTypes,omitempty"`

	// IsEnabled Whether the subscription is enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// LabelKey (Deprecated) Use `labels` instead for better filtering capabilities, including filtering on multiple labels simultaneously.
	//
	// Label key for filtering events. Use either (labelKey + labelValue) OR labels, not both.
	// Maintained for backward compatibility only.
	// Deprecated:
	LabelKey *string `json:"labelKey,omitempty"`

	// LabelValue (Deprecated) Use `labels` instead for better filtering capabilities, including filtering on multiple labels simultaneously.
	//
	// Label value for filtering events. Use either (labelKey + labelValue) OR labels, not both.
	// Maintained for backward compatibility only.
	// Deprecated:
	LabelValue *string `json:"labelValue,omitempty"`

	// Labels Multi-label filters that trigger only when an event contains ALL of these key-value pairs.
	//
	// **Note:** Currently, labels are supported for onchain webhooks only.
	//
	// See [allowed labels for onchain webhooks](https://docs.cdp.coinbase.com/api-reference/v2/rest-api/webhooks/create-webhook-subscription#onchain-label-filtering).
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Additional metadata for the subscription.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Target Target configuration for webhook delivery.
	// Specifies the destination URL and any custom headers to include in webhook requests.
	Target *WebhookTarget `json:"target,omitempty"`
	union  json.RawMessage
}

// WebhookSubscriptionUpdateRequest0 defines model for .
type WebhookSubscriptionUpdateRequest0 = interface{}

// WebhookSubscriptionUpdateRequest1 defines model for .
type WebhookSubscriptionUpdateRequest1 = interface{}

// WebhookTarget Target configuration for webhook delivery.
// Specifies the destination URL and any custom headers to include in webhook requests.
type WebhookTarget struct {
	// Headers Additional headers to include in webhook requests.
	Headers *map[string]string `json:"headers,omitempty"`

	// Url The webhook URL to deliver events to.
	Url Url `json:"url"`
}

// X402Version The version of the x402 protocol.
type X402Version int

// FromAmount The amount of the `fromToken` to send in atomic units of the token. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
type FromAmount = string

// FromToken The 0x-prefixed contract address of the token to send.
type FromToken = string

// GasPrice The target gas price for the swap transaction, in Wei. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. If not provided, the API will use an estimate based on the current network conditions.
type GasPrice = string

// SignerAddress The 0x-prefixed Externally Owned Account (EOA) address that will sign the `Permit2` EIP-712 permit message. This is only needed if `taker` is a smart contract.
type SignerAddress = string

// SlippageBps The maximum acceptable slippage of the `toToken` in basis points. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100 bps (i.e., 1%).
type SlippageBps = int

// Taker The 0x-prefixed address that holds the `fromToken` balance and has the `Permit2` allowance set for the swap.
type Taker = string

// ToToken The 0x-prefixed contract address of the token to receive.
type ToToken = string

// X402ExactEvmPayload The x402 protocol exact scheme payload for EVM networks. The scheme is implemented using ERC-3009. For more details, please see [EVM Exact Scheme Details](https://github.com/coinbase/x402/blob/main/specs/schemes/exact/scheme_exact_evm.md).
type X402ExactEvmPayload struct {
	// Authorization The authorization data for the ERC-3009 authorization message.
	Authorization struct {
		// From The 0x-prefixed, checksum EVM address of the sender of the payment.
		From string `json:"from"`

		// Nonce The hex-encoded nonce of the payment.
		Nonce string `json:"nonce"`

		// To The 0x-prefixed, checksum EVM address of the recipient of the payment.
		To string `json:"to"`

		// ValidAfter The unix timestamp after which the payment is valid.
		ValidAfter string `json:"validAfter"`

		// ValidBefore The unix timestamp before which the payment is valid.
		ValidBefore string `json:"validBefore"`

		// Value The value of the payment, in atomic units of the payment asset.
		Value string `json:"value"`
	} `json:"authorization"`

	// Signature The EIP-712 hex-encoded signature of the ERC-3009 authorization message.
	Signature string `json:"signature"`
}

// X402ExactSolanaPayload The x402 protocol exact scheme payload for Solana networks. For more details, please see [Solana Exact Scheme Details](https://github.com/coinbase/x402/blob/main/specs/schemes/exact/scheme_exact_svm.md).
type X402ExactSolanaPayload struct {
	// Transaction The base64-encoded Solana transaction.
	Transaction string `json:"transaction"`
}

// X402PaymentPayload The x402 protocol payment payload that the client attaches to x402-paid API requests to the resource server in the X-PAYMENT header.
type X402PaymentPayload struct {
	union json.RawMessage
}

// X402PaymentRequirements The x402 protocol payment requirements that the resource server expects the client's payment payload to meet.
type X402PaymentRequirements struct {
	union json.RawMessage
}

// X402ResourceInfo Describes the resource being accessed in x402 protocol.
type X402ResourceInfo struct {
	// Description The description of the resource.
	Description *string `json:"description,omitempty"`

	// MimeType The MIME type of the resource response.
	MimeType *string `json:"mimeType,omitempty"`

	// Url The URL of the resource.
	Url *string `json:"url,omitempty"`
}

// X402SettleErrorReason The reason the payment settlement errored on the x402 protocol.
type X402SettleErrorReason string

// X402SettlePaymentRejection The result when x402 payment settlement fails.
type X402SettlePaymentRejection struct {
	// ErrorReason The reason the payment settlement errored on the x402 protocol.
	ErrorReason X402SettleErrorReason `json:"errorReason"`

	// Network The network where the settlement occurred.
	Network *string `json:"network,omitempty"`

	// Payer The onchain address of the client that is paying for the resource.
	//
	// For EVM networks, the payer will be a 0x-prefixed, checksum EVM address.
	//
	// For Solana-based networks, the payer will be a base58-encoded Solana address.
	Payer *string `json:"payer,omitempty"`

	// Success Indicates whether the payment settlement is successful.
	Success bool `json:"success"`

	// Transaction The transaction of the settlement.
	// For EVM networks, the transaction will be a 0x-prefixed, EVM transaction hash.
	// For Solana-based networks, the transaction will be a base58-encoded Solana signature.
	Transaction *string `json:"transaction,omitempty"`
}

// X402SupportedPaymentKind The supported payment kind for the x402 protocol. A kind is comprised of a scheme and a network, which together uniquely identify a way to move money on the x402 protocol. For more details, please see [x402 Schemes](https://github.com/coinbase/x402?tab=readme-ov-file#schemes).
type X402SupportedPaymentKind struct {
	// Extra The optional additional scheme-specific payment info.
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// Network The network of the blockchain.
	Network X402SupportedPaymentKindNetwork `json:"network"`

	// Scheme The scheme of the payment protocol.
	Scheme X402SupportedPaymentKindScheme `json:"scheme"`

	// X402Version The version of the x402 protocol.
	X402Version X402Version `json:"x402Version"`
}

// X402SupportedPaymentKindNetwork The network of the blockchain.
type X402SupportedPaymentKindNetwork string

// X402SupportedPaymentKindScheme The scheme of the payment protocol.
type X402SupportedPaymentKindScheme string

// X402V1PaymentPayload The x402 protocol payment payload that the client attaches to x402-paid API requests to the resource server in the X-PAYMENT header.
type X402V1PaymentPayload struct {
	// Network The network of the blockchain to send payment on.
	Network X402V1PaymentPayloadNetwork `json:"network"`

	// Payload The payload of the payment depending on the x402Version, scheme, and network.
	Payload X402V1PaymentPayload_Payload `json:"payload"`

	// Scheme The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.
	Scheme X402V1PaymentPayloadScheme `json:"scheme"`

	// X402Version The version of the x402 protocol.
	X402Version X402Version `json:"x402Version"`
}

// X402V1PaymentPayloadNetwork The network of the blockchain to send payment on.
type X402V1PaymentPayloadNetwork string

// X402V1PaymentPayload_Payload The payload of the payment depending on the x402Version, scheme, and network.
type X402V1PaymentPayload_Payload struct {
	union json.RawMessage
}

// X402V1PaymentPayloadScheme The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.
type X402V1PaymentPayloadScheme string

// X402V1PaymentRequirements The x402 protocol payment requirements that the resource server expects the client's payment payload to meet.
type X402V1PaymentRequirements struct {
	// Asset The asset to pay with.
	//
	// For EVM networks, the asset will be a 0x-prefixed, checksum EVM address.
	//
	// For Solana-based networks, the asset will be a base58-encoded Solana address.
	Asset string `json:"asset"`

	// Description The description of the resource.
	Description string `json:"description"`

	// Extra The optional additional scheme-specific payment info.
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// MaxAmountRequired The maximum amount required to pay for the resource in atomic units of the payment asset.
	MaxAmountRequired string `json:"maxAmountRequired"`

	// MaxTimeoutSeconds The maximum time in seconds for the resource server to respond.
	MaxTimeoutSeconds int `json:"maxTimeoutSeconds"`

	// MimeType The MIME type of the resource response.
	MimeType string `json:"mimeType"`

	// Network The network of the blockchain to send payment on.
	Network X402V1PaymentRequirementsNetwork `json:"network"`

	// OutputSchema The optional JSON schema describing the resource output.
	OutputSchema *map[string]interface{} `json:"outputSchema,omitempty"`

	// PayTo The destination to pay value to.
	//
	// For EVM networks, payTo will be a 0x-prefixed, checksum EVM address.
	//
	// For Solana-based networks, payTo will be a base58-encoded Solana address.
	PayTo string `json:"payTo"`

	// Resource The URL of the resource to pay for.
	Resource string `json:"resource"`

	// Scheme The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.
	Scheme X402V1PaymentRequirementsScheme `json:"scheme"`
}

// X402V1PaymentRequirementsNetwork The network of the blockchain to send payment on.
type X402V1PaymentRequirementsNetwork string

// X402V1PaymentRequirementsScheme The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.
type X402V1PaymentRequirementsScheme string

// X402V2PaymentPayload The x402 protocol payment payload that the client attaches to x402-paid API requests to the resource server in the X-PAYMENT header.
type X402V2PaymentPayload struct {
	// Accepted The x402 protocol payment requirements that the resource server expects the client's payment payload to meet.
	Accepted X402V2PaymentRequirements `json:"accepted"`

	// Extensions Optional protocol extensions.
	Extensions *map[string]interface{} `json:"extensions,omitempty"`

	// Payload The payload of the payment depending on the x402Version, scheme, and network.
	Payload X402V2PaymentPayload_Payload `json:"payload"`

	// Resource Describes the resource being accessed in x402 protocol.
	Resource *X402ResourceInfo `json:"resource,omitempty"`

	// X402Version The version of the x402 protocol.
	X402Version X402Version `json:"x402Version"`
}

// X402V2PaymentPayload_Payload The payload of the payment depending on the x402Version, scheme, and network.
type X402V2PaymentPayload_Payload struct {
	union json.RawMessage
}

// X402V2PaymentRequirements The x402 protocol payment requirements that the resource server expects the client's payment payload to meet.
type X402V2PaymentRequirements struct {
	// Amount The amount to pay for the resource in atomic units of the payment asset.
	Amount string `json:"amount"`

	// Asset The asset to pay with.
	//
	// For EVM networks, the asset will be a 0x-prefixed, checksum EVM address.
	//
	// For Solana-based networks, the asset will be a base58-encoded Solana address.
	Asset string `json:"asset"`

	// Extra The optional additional scheme-specific payment info.
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// MaxTimeoutSeconds The maximum time in seconds for the resource server to respond.
	MaxTimeoutSeconds int `json:"maxTimeoutSeconds"`

	// Network The network of the blockchain to send payment on in caip2 format.
	Network string `json:"network"`

	// PayTo The destination to pay value to.
	//
	// For EVM networks, payTo will be a 0x-prefixed, checksum EVM address.
	//
	// For Solana-based networks, payTo will be a base58-encoded Solana address.
	PayTo string `json:"payTo"`

	// Scheme The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.
	Scheme X402V2PaymentRequirementsScheme `json:"scheme"`
}

// X402V2PaymentRequirementsScheme The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.
type X402V2PaymentRequirementsScheme string

// X402VerifyInvalidReason The reason the payment is invalid on the x402 protocol.
type X402VerifyInvalidReason string

// X402VerifyPaymentRejection The result when x402 payment verification fails.
type X402VerifyPaymentRejection struct {
	// InvalidReason The reason the payment is invalid on the x402 protocol.
	InvalidReason X402VerifyInvalidReason `json:"invalidReason"`

	// IsValid Indicates whether the payment is valid.
	IsValid bool `json:"isValid"`

	// Payer The onchain address of the client that is paying for the resource.
	//
	// For EVM networks, the payer will be a 0x-prefixed, checksum EVM address.
	//
	// For Solana-based networks, the payer will be a base58-encoded Solana address.
	Payer *string `json:"payer,omitempty"`
}

// IdempotencyKey defines model for IdempotencyKey.
type IdempotencyKey = string

// PageSize defines model for PageSize.
type PageSize = int

// PageToken defines model for PageToken.
type PageToken = string

// XWalletAuth defines model for XWalletAuth.
type XWalletAuth = string

// AlreadyExistsError An error response including the code for the type of error and a human-readable message describing the error.
type AlreadyExistsError = Error

// BadGatewayError An error response including the code for the type of error and a human-readable message describing the error.
type BadGatewayError = Error

// IdempotencyError An error response including the code for the type of error and a human-readable message describing the error.
type IdempotencyError = Error

// InternalServerError An error response including the code for the type of error and a human-readable message describing the error.
type InternalServerError = Error

// InvalidSQLQueryError An error response including the code for the type of error and a human-readable message describing the error.
type InvalidSQLQueryError = Error

// PaymentMethodRequiredError An error response including the code for the type of error and a human-readable message describing the error.
type PaymentMethodRequiredError = Error

// RateLimitExceeded An error response including the code for the type of error and a human-readable message describing the error.
type RateLimitExceeded = Error

// ServiceUnavailableError An error response including the code for the type of error and a human-readable message describing the error.
type ServiceUnavailableError = Error

// TimedOutError An error response including the code for the type of error and a human-readable message describing the error.
type TimedOutError = Error

// UnauthorizedError An error response including the code for the type of error and a human-readable message describing the error.
type UnauthorizedError = Error

// X402SettleError The result when x402 payment settlement fails.
type X402SettleError = X402SettlePaymentRejection

// X402SettleResponse defines model for x402SettleResponse.
type X402SettleResponse struct {
	// ErrorReason The reason the payment settlement errored on the x402 protocol.
	ErrorReason *X402SettleErrorReason `json:"errorReason,omitempty"`

	// Network The network where the settlement occurred.
	Network string `json:"network"`

	// Payer The onchain address of the client that is paying for the resource.
	//
	// For EVM networks, the payer will be a 0x-prefixed, checksum EVM address.
	//
	// For Solana-based networks, the payer will be a base58-encoded Solana address.
	Payer string `json:"payer"`

	// Success Indicates whether the payment settlement is successful.
	Success bool `json:"success"`

	// Transaction The transaction of the settlement.
	// For EVM networks, the transaction will be a 0x-prefixed, EVM transaction hash.
	// For Solana-based networks, the transaction will be a base58-encoded Solana signature.
	Transaction string `json:"transaction"`
}

// X402SupportedPaymentKindsResponse defines model for x402SupportedPaymentKindsResponse.
type X402SupportedPaymentKindsResponse struct {
	// Extensions The list of supported x402 extensions.
	Extensions []string `json:"extensions"`

	// Kinds The list of supported payment kinds.
	Kinds []X402SupportedPaymentKind `json:"kinds"`

	// Signers A map of CAIP-2 network or protocol family patterns to their supported signer addresses.
	Signers map[string][]string `json:"signers"`
}

// X402VerifyInvalidError The result when x402 payment verification fails.
type X402VerifyInvalidError = X402VerifyPaymentRejection

// X402VerifyResponse defines model for x402VerifyResponse.
type X402VerifyResponse struct {
	// InvalidReason The reason the payment is invalid on the x402 protocol.
	InvalidReason *X402VerifyInvalidReason `json:"invalidReason,omitempty"`

	// IsValid Indicates whether the payment is valid.
	IsValid bool `json:"isValid"`

	// Payer The onchain address of the client that is paying for the resource.
	//
	// For EVM networks, the payer will be a 0x-prefixed, checksum EVM address.
	//
	// For Solana-based networks, the payer will be a base58-encoded Solana address.
	Payer string `json:"payer"`
}

// ListDataTokenBalancesParams defines parameters for ListDataTokenBalances.
type ListDataTokenBalancesParams struct {
	// PageSize The number of resources to return per page.
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of resources, if any.
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListTokensForAccountParamsNetwork defines parameters for ListTokensForAccount.
type ListTokensForAccountParamsNetwork string

// ListWebhookSubscriptionsParams defines parameters for ListWebhookSubscriptions.
type ListWebhookSubscriptionsParams struct {
	// PageSize The number of subscriptions to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of subscriptions, if any.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListEndUsersParams defines parameters for ListEndUsers.
type ListEndUsersParams struct {
	// PageSize The number of end users to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the desired page of end users. Will be empty if there are no more end users to fetch.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Sort Sort end users. Defaults to ascending order (oldest first).
	Sort *[]ListEndUsersParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListEndUsersParamsSort defines parameters for ListEndUsers.
type ListEndUsersParamsSort string

// CreateEndUserJSONBody defines parameters for CreateEndUser.
type CreateEndUserJSONBody struct {
	// AuthenticationMethods The list of valid authentication methods linked to the end user.
	AuthenticationMethods AuthenticationMethods `json:"authenticationMethods"`

	// EvmAccount Configuration for creating an EVM account for the end user.
	EvmAccount *struct {
		// CreateSmartAccount If true, creates an EVM smart account and a default EVM EOA account as the owner. If false, only a EVM EOA account is created.
		CreateSmartAccount *bool `json:"createSmartAccount,omitempty"`

		// EnableSpendPermissions If true, enables spend permissions for the EVM smart account.
		EnableSpendPermissions *bool `json:"enableSpendPermissions,omitempty"`
	} `json:"evmAccount,omitempty"`

	// SolanaAccount Configuration for creating a Solana account for the end user.
	SolanaAccount *struct {
		// CreateSmartAccount Only false is a valid option since currently smart accounts on Solana are not supported.
		CreateSmartAccount *bool `json:"createSmartAccount,omitempty"`
	} `json:"solanaAccount,omitempty"`

	// UserId A stable, unique identifier for the end user. The `userId` must be unique across all end users in the developer's CDP Project. It must be between 1 and 100 characters long and can only contain alphanumeric characters and hyphens.
	//
	// If `userId` is not provided in the request, the server will generate a random UUID.
	UserId *string `json:"userId,omitempty"`
}

// CreateEndUserParams defines parameters for CreateEndUser.
type CreateEndUserParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ValidateEndUserAccessTokenJSONBody defines parameters for ValidateEndUserAccessToken.
type ValidateEndUserAccessTokenJSONBody struct {
	// AccessToken The access token in JWT format to verify.
	AccessToken string `json:"accessToken"`
}

// ImportEndUserJSONBody defines parameters for ImportEndUser.
type ImportEndUserJSONBody struct {
	// AuthenticationMethods The list of valid authentication methods linked to the end user.
	AuthenticationMethods AuthenticationMethods `json:"authenticationMethods"`

	// EncryptedPrivateKey The base64-encoded, encrypted private key to import. The private key must be encrypted using the CDP SDK's encryption scheme. This is a 32-byte raw private key.
	EncryptedPrivateKey string `json:"encryptedPrivateKey"`

	// KeyType The type of key being imported. Determines what type of account will be associated for the end user.
	KeyType ImportEndUserJSONBodyKeyType `json:"keyType"`

	// UserId A stable, unique identifier for the end user. The `userId` must be unique across all end users in the developer's CDP Project. It must be between 1 and 100 characters long and can only contain alphanumeric characters and hyphens.
	UserId string `json:"userId"`
}

// ImportEndUserParams defines parameters for ImportEndUser.
type ImportEndUserParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ImportEndUserJSONBodyKeyType defines parameters for ImportEndUser.
type ImportEndUserJSONBodyKeyType string

// ListEvmAccountsParams defines parameters for ListEvmAccounts.
type ListEvmAccountsParams struct {
	// PageSize The number of resources to return per page.
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of resources, if any.
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateEvmAccountJSONBody defines parameters for CreateEvmAccount.
type CreateEvmAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// CreateEvmAccountParams defines parameters for CreateEvmAccount.
type CreateEvmAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ExportEvmAccountByNameJSONBody defines parameters for ExportEvmAccountByName.
type ExportEvmAccountByNameJSONBody struct {
	// ExportEncryptionKey The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
	ExportEncryptionKey string `json:"exportEncryptionKey"`
}

// ExportEvmAccountByNameParams defines parameters for ExportEvmAccountByName.
type ExportEvmAccountByNameParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ImportEvmAccountJSONBody defines parameters for ImportEvmAccount.
type ImportEvmAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account. The private key must be encrypted using the CDP SDK's encryption scheme.
	EncryptedPrivateKey string `json:"encryptedPrivateKey"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// ImportEvmAccountParams defines parameters for ImportEvmAccount.
type ImportEvmAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// UpdateEvmAccountJSONBody defines parameters for UpdateEvmAccount.
type UpdateEvmAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// UpdateEvmAccountParams defines parameters for UpdateEvmAccount.
type UpdateEvmAccountParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ExportEvmAccountJSONBody defines parameters for ExportEvmAccount.
type ExportEvmAccountJSONBody struct {
	// ExportEncryptionKey The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
	ExportEncryptionKey string `json:"exportEncryptionKey"`
}

// ExportEvmAccountParams defines parameters for ExportEvmAccount.
type ExportEvmAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SendEvmTransactionJSONBody defines parameters for SendEvmTransaction.
type SendEvmTransactionJSONBody struct {
	// Network The network to send the transaction to.
	Network SendEvmTransactionJSONBodyNetwork `json:"network"`

	// Transaction The RLP-encoded transaction to sign and send, as a 0x-prefixed hex string.
	Transaction string `json:"transaction"`
}

// SendEvmTransactionParams defines parameters for SendEvmTransaction.
type SendEvmTransactionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SendEvmTransactionJSONBodyNetwork defines parameters for SendEvmTransaction.
type SendEvmTransactionJSONBodyNetwork string

// SignEvmHashJSONBody defines parameters for SignEvmHash.
type SignEvmHashJSONBody struct {
	// Hash The arbitrary 32 byte hash to sign.
	Hash string `json:"hash"`
}

// SignEvmHashParams defines parameters for SignEvmHash.
type SignEvmHashParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignEvmMessageJSONBody defines parameters for SignEvmMessage.
type SignEvmMessageJSONBody struct {
	// Message The message to sign.
	Message string `json:"message"`
}

// SignEvmMessageParams defines parameters for SignEvmMessage.
type SignEvmMessageParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignEvmTransactionJSONBody defines parameters for SignEvmTransaction.
type SignEvmTransactionJSONBody struct {
	// Transaction The RLP-encoded transaction to sign, as a 0x-prefixed hex string.
	Transaction string `json:"transaction"`
}

// SignEvmTransactionParams defines parameters for SignEvmTransaction.
type SignEvmTransactionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignEvmTypedDataParams defines parameters for SignEvmTypedData.
type SignEvmTypedDataParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// RequestEvmFaucetJSONBody defines parameters for RequestEvmFaucet.
type RequestEvmFaucetJSONBody struct {
	// Address The address to request funds to, which is a 0x-prefixed hexadecimal string.
	Address string `json:"address"`

	// Network The network to request funds from.
	Network RequestEvmFaucetJSONBodyNetwork `json:"network"`

	// Token The token to request funds for.
	Token RequestEvmFaucetJSONBodyToken `json:"token"`
}

// RequestEvmFaucetJSONBodyNetwork defines parameters for RequestEvmFaucet.
type RequestEvmFaucetJSONBodyNetwork string

// RequestEvmFaucetJSONBodyToken defines parameters for RequestEvmFaucet.
type RequestEvmFaucetJSONBodyToken string

// ListEvmSmartAccountsParams defines parameters for ListEvmSmartAccounts.
type ListEvmSmartAccountsParams struct {
	// PageSize The number of resources to return per page.
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of resources, if any.
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateEvmSmartAccountJSONBody defines parameters for CreateEvmSmartAccount.
type CreateEvmSmartAccountJSONBody struct {
	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`

	// Owners Today, only a single owner can be set for a Smart Account, but this is an array to allow setting multiple owners in the future.
	Owners []string `json:"owners"`
}

// CreateEvmSmartAccountParams defines parameters for CreateEvmSmartAccount.
type CreateEvmSmartAccountParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// UpdateEvmSmartAccountJSONBody defines parameters for UpdateEvmSmartAccount.
type UpdateEvmSmartAccountJSONBody struct {
	// Name An optional name for the smart account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM smart accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// CreateSpendPermissionParams defines parameters for CreateSpendPermission.
type CreateSpendPermissionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ListSpendPermissionsParams defines parameters for ListSpendPermissions.
type ListSpendPermissionsParams struct {
	// PageSize The number of spend permissions to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of spend permissions. Will be empty if there are no more spend permissions to fetch.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// RevokeSpendPermissionParams defines parameters for RevokeSpendPermission.
type RevokeSpendPermissionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// PrepareUserOperationJSONBody defines parameters for PrepareUserOperation.
type PrepareUserOperationJSONBody struct {
	// Calls The list of calls to make from the Smart Account.
	Calls []EvmCall `json:"calls"`

	// DataSuffix The EIP-8021 data suffix (hex-encoded) that enables transaction attribution for the user operation.
	DataSuffix *string `json:"dataSuffix,omitempty"`

	// Network The network the user operation is for.
	Network EvmUserOperationNetwork `json:"network"`

	// PaymasterUrl The URL of the paymaster to use for the user operation.
	PaymasterUrl *Url `json:"paymasterUrl,omitempty"`
}

// PrepareAndSendUserOperationJSONBody defines parameters for PrepareAndSendUserOperation.
type PrepareAndSendUserOperationJSONBody struct {
	// Calls The list of calls to make from the Smart Account.
	Calls []EvmCall `json:"calls"`

	// Network The network the user operation is for.
	Network EvmUserOperationNetwork `json:"network"`

	// PaymasterUrl The URL of the paymaster to use for the user operation.
	PaymasterUrl *Url `json:"paymasterUrl,omitempty"`
}

// PrepareAndSendUserOperationParams defines parameters for PrepareAndSendUserOperation.
type PrepareAndSendUserOperationParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`

	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`
}

// SendUserOperationJSONBody defines parameters for SendUserOperation.
type SendUserOperationJSONBody struct {
	// Signature The hex-encoded signature of the user operation. This should be a 65-byte signature consisting of the `r`, `s`, and `v` values of the ECDSA signature. Note that the `v` value should conform to the `personal_sign` standard, which means it should be 27 or 28.
	Signature string `json:"signature"`
}

// CreateEvmSwapQuoteJSONBody defines parameters for CreateEvmSwapQuote.
type CreateEvmSwapQuoteJSONBody struct {
	// FromAmount The amount of the `fromToken` to send in atomic units of the token. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
	FromAmount string `json:"fromAmount"`

	// FromToken The 0x-prefixed contract address of the token to send.
	FromToken string `json:"fromToken"`

	// GasPrice The target gas price for the swap transaction, in Wei. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. If not provided, the API will use an estimate based on the current network conditions.
	GasPrice *string `json:"gasPrice,omitempty"`

	// Network The network on which to perform the swap.
	Network EvmSwapsNetwork `json:"network"`

	// SignerAddress The 0x-prefixed Externally Owned Account (EOA) address that will sign the `Permit2` EIP-712 permit message. This is only needed if `taker` is a smart contract.
	SignerAddress *string `json:"signerAddress,omitempty"`

	// SlippageBps The maximum acceptable slippage of the `toToken` in basis points. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100 bps (i.e., 1%).
	SlippageBps *int `json:"slippageBps,omitempty"`

	// Taker The 0x-prefixed address that holds the `fromToken` balance and has the `Permit2` allowance set for the swap.
	Taker string `json:"taker"`

	// ToToken The 0x-prefixed contract address of the token to receive.
	ToToken string `json:"toToken"`
}

// CreateEvmSwapQuoteParams defines parameters for CreateEvmSwapQuote.
type CreateEvmSwapQuoteParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// GetEvmSwapPriceParams defines parameters for GetEvmSwapPrice.
type GetEvmSwapPriceParams struct {
	Network       EvmSwapsNetwork `form:"network" json:"network"`
	ToToken       ToToken         `form:"toToken" json:"toToken"`
	FromToken     FromToken       `form:"fromToken" json:"fromToken"`
	FromAmount    FromAmount      `form:"fromAmount" json:"fromAmount"`
	Taker         Taker           `form:"taker" json:"taker"`
	SignerAddress *SignerAddress  `form:"signerAddress,omitempty" json:"signerAddress,omitempty"`
	GasPrice      *GasPrice       `form:"gasPrice,omitempty" json:"gasPrice,omitempty"`
	SlippageBps   *SlippageBps    `form:"slippageBps,omitempty" json:"slippageBps,omitempty"`
}

// ListEvmTokenBalancesParams defines parameters for ListEvmTokenBalances.
type ListEvmTokenBalancesParams struct {
	// PageSize The number of resources to return per page.
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of resources, if any.
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateOnrampOrderJSONBody defines parameters for CreateOnrampOrder.
type CreateOnrampOrderJSONBody struct {
	// AgreementAcceptedAt The timestamp of when the user acknowledged that by using Coinbase Onramp they are accepting the Coinbase Terms  (https://www.coinbase.com/legal/guest-checkout/us), User Agreement (https://www.coinbase.com/legal/user_agreement),  and Privacy Policy (https://www.coinbase.com/legal/privacy).
	AgreementAcceptedAt time.Time `json:"agreementAcceptedAt"`

	// ClientIp The IP address of the end user requesting the onramp transaction.
	ClientIp *string `json:"clientIp,omitempty"`

	// DestinationAddress The address the purchased crypto will be sent to.
	DestinationAddress string `json:"destinationAddress"`

	// DestinationNetwork The name of the crypto network the purchased currency will be sent on.
	//
	// Use the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported networks for your user's location.
	DestinationNetwork string `json:"destinationNetwork"`

	// Domain The domain that the Apple Pay button will be rendered on. Required when using the `GUEST_CHECKOUT_APPLE_PAY`  payment method and embedding the payment link in an iframe.
	Domain *string `json:"domain,omitempty"`

	// Email The verified email address of the user requesting the onramp transaction. This email must be verified by your app (via OTP) before being used with the Onramp API.
	Email string `json:"email"`

	// IsQuote If true, this API will return a quote without creating any transaction.
	IsQuote *bool `json:"isQuote,omitempty"`

	// PartnerOrderRef Optional partner order reference ID.
	PartnerOrderRef *string `json:"partnerOrderRef,omitempty"`

	// PartnerUserRef A unique string that represents the user in your app. This can be used to link individual transactions  together so you can retrieve the transaction history for your users. Prefix this string with sandbox-  (e.g. "sandbox-user-1234") to perform a sandbox transaction which will allow you to test your integration  without any real transfer of funds.
	//
	// This value can be used with with [Onramp User Transactions API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-onramp-transactions-by-id) to retrieve all transactions created by the user.
	PartnerUserRef string `json:"partnerUserRef"`

	// PaymentAmount A string representing the amount of fiat the user wishes to pay in exchange for crypto. When using  this parameter, the returned quote will be inclusive of fees i.e. the user will pay this exact amount  of the payment currency.
	PaymentAmount *string `json:"paymentAmount,omitempty"`

	// PaymentCurrency The fiat currency to be converted to crypto.
	PaymentCurrency string `json:"paymentCurrency"`

	// PaymentMethod The type of payment method to be used to complete an onramp order.
	PaymentMethod OnrampOrderPaymentMethodTypeId `json:"paymentMethod"`

	// PhoneNumber The phone number of the user requesting the onramp transaction in E.164 format. This phone number must  be verified by your app (via OTP) before being used with the Onramp API.
	//
	// Please refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/apple-pay-onramp-api) for more details on phone number verification requirements and best practices.
	PhoneNumber string `json:"phoneNumber"`

	// PhoneNumberVerifiedAt Timestamp of when the user's phone number was verified via OTP. User phone number must be verified  every 60 days. If this timestamp is older than 60 days, an error will be returned.
	PhoneNumberVerifiedAt time.Time `json:"phoneNumberVerifiedAt"`

	// PurchaseAmount A string representing the amount of crypto the user wishes to purchase. When using this parameter the  returned quote will be exclusive of fees i.e. the user will receive this exact amount of the purchase  currency.
	PurchaseAmount *string `json:"purchaseAmount,omitempty"`

	// PurchaseCurrency The ticker (e.g. `BTC`, `USDC`, `SOL`) or the Coinbase UUID (e.g. `d85dce9b-5b73-5c3c-8978-522ce1d1c1b4`)  of the crypto asset to be purchased.
	//
	// Use the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported purchase currencies for your user's location.
	PurchaseCurrency string `json:"purchaseCurrency"`
}

// CreateOnrampSessionJSONBody defines parameters for CreateOnrampSession.
type CreateOnrampSessionJSONBody struct {
	// ClientIp The IP address of the end user requesting the onramp transaction.
	ClientIp *string `json:"clientIp,omitempty"`

	// Country The ISO 3166-1 two letter country code (e.g. US).
	Country *string `json:"country,omitempty"`

	// DestinationAddress The address the purchased crypto will be sent to.
	DestinationAddress string `json:"destinationAddress"`

	// DestinationNetwork The name of the crypto network the purchased currency will be sent on.
	//
	// Use the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported networks for your user's location.
	DestinationNetwork string `json:"destinationNetwork"`

	// PartnerUserRef A unique string that represents the user in your app. This can be used to link individual transactions together so you can retrieve the transaction history for your users. Prefix this string with sandbox-  (e.g. "sandbox-user-1234") to perform a sandbox transaction which will allow you to test your integration  without any real transfer of funds.
	//
	// This value can be used with with [Onramp User Transactions API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-onramp-transactions-by-id) to retrieve all transactions created by the user.
	PartnerUserRef *string `json:"partnerUserRef,omitempty"`

	// PaymentAmount A string representing the amount of fiat the user wishes to pay in exchange for crypto. When using this parameter, the returned quote will be inclusive of fees i.e. the user  will pay this exact amount of the payment currency.
	PaymentAmount *string `json:"paymentAmount,omitempty"`

	// PaymentCurrency The fiat currency to be converted to crypto.
	PaymentCurrency *string `json:"paymentCurrency,omitempty"`

	// PaymentMethod The type of payment method used to generate the onramp quote.
	PaymentMethod *OnrampQuotePaymentMethodTypeId `json:"paymentMethod,omitempty"`

	// PurchaseAmount A string representing the amount of crypto the user wishes to purchase. When using  this parameter, the returned quote will be exclusive of fees i.e. the user will  receive this exact amount of the purchase currency.
	PurchaseAmount *string `json:"purchaseAmount,omitempty"`

	// PurchaseCurrency The ticker (e.g. `BTC`, `USDC`, `SOL`) or the Coinbase UUID (e.g. `d85dce9b-5b73-5c3c-8978-522ce1d1c1b4`)  of the crypto asset to be purchased.
	//
	// Use the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported purchase currencies for your user's location.
	PurchaseCurrency string `json:"purchaseCurrency"`

	// RedirectUrl URI to redirect the user to when they successfully complete a transaction. This URI will be embedded in the returned onramp URI as a query parameter.
	RedirectUrl *Uri `json:"redirectUrl,omitempty"`

	// Subdivision The ISO 3166-2 two letter state code (e.g. NY). Only required for US.
	Subdivision *string `json:"subdivision,omitempty"`
}

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {
	// PageSize The number of resources to return per page.
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of resources, if any.
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Scope The scope of the policies to return. If `project`, the response will include exactly one policy, which is the project-level policy. If `account`, the response will include all account-level policies for the developer's CDP Project.
	Scope *ListPoliciesParamsScope `form:"scope,omitempty" json:"scope,omitempty"`
}

// ListPoliciesParamsScope defines parameters for ListPolicies.
type ListPoliciesParamsScope string

// CreatePolicyJSONBody defines parameters for CreatePolicy.
type CreatePolicyJSONBody struct {
	// Description An optional human-readable description for the policy.
	// Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.
	Description *string `json:"description,omitempty"`

	// Rules A list of rules that comprise the policy. There is a limit of 10 rules per policy.
	Rules []Rule `json:"rules"`

	// Scope The scope of the policy.
	Scope CreatePolicyJSONBodyScope `json:"scope"`
}

// CreatePolicyParams defines parameters for CreatePolicy.
type CreatePolicyParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// CreatePolicyJSONBodyScope defines parameters for CreatePolicy.
type CreatePolicyJSONBodyScope string

// DeletePolicyParams defines parameters for DeletePolicy.
type DeletePolicyParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// UpdatePolicyJSONBody defines parameters for UpdatePolicy.
type UpdatePolicyJSONBody struct {
	// Description An optional human-readable description for the policy.
	// Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.
	Description *string `json:"description,omitempty"`

	// Rules A list of rules that comprise the policy. There is a limit of 10 rules per policy.
	Rules []Rule `json:"rules"`
}

// UpdatePolicyParams defines parameters for UpdatePolicy.
type UpdatePolicyParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ListSolanaAccountsParams defines parameters for ListSolanaAccounts.
type ListSolanaAccountsParams struct {
	// PageSize The number of resources to return per page.
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of resources, if any.
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateSolanaAccountJSONBody defines parameters for CreateSolanaAccount.
type CreateSolanaAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all Solana accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// CreateSolanaAccountParams defines parameters for CreateSolanaAccount.
type CreateSolanaAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ExportSolanaAccountByNameJSONBody defines parameters for ExportSolanaAccountByName.
type ExportSolanaAccountByNameJSONBody struct {
	// ExportEncryptionKey The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
	ExportEncryptionKey string `json:"exportEncryptionKey"`
}

// ExportSolanaAccountByNameParams defines parameters for ExportSolanaAccountByName.
type ExportSolanaAccountByNameParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ImportSolanaAccountJSONBody defines parameters for ImportSolanaAccount.
type ImportSolanaAccountJSONBody struct {
	// EncryptedPrivateKey The base64-encoded, encrypted 32-byte private key of the Solana account. The private key must be encrypted using the CDP SDK's encryption scheme.
	EncryptedPrivateKey string `json:"encryptedPrivateKey"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// ImportSolanaAccountParams defines parameters for ImportSolanaAccount.
type ImportSolanaAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SendSolanaTransactionJSONBody defines parameters for SendSolanaTransaction.
type SendSolanaTransactionJSONBody struct {
	// Network The Solana network to send the transaction to.
	Network SendSolanaTransactionJSONBodyNetwork `json:"network"`

	// Transaction The base64 encoded transaction to sign and send. This transaction can contain multiple instructions for native Solana batching.
	Transaction string `json:"transaction"`
}

// SendSolanaTransactionParams defines parameters for SendSolanaTransaction.
type SendSolanaTransactionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SendSolanaTransactionJSONBodyNetwork defines parameters for SendSolanaTransaction.
type SendSolanaTransactionJSONBodyNetwork string

// UpdateSolanaAccountJSONBody defines parameters for UpdateSolanaAccount.
type UpdateSolanaAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// Name An optional name for the account. Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all Solana accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// UpdateSolanaAccountParams defines parameters for UpdateSolanaAccount.
type UpdateSolanaAccountParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ExportSolanaAccountJSONBody defines parameters for ExportSolanaAccount.
type ExportSolanaAccountJSONBody struct {
	// ExportEncryptionKey The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
	ExportEncryptionKey string `json:"exportEncryptionKey"`
}

// ExportSolanaAccountParams defines parameters for ExportSolanaAccount.
type ExportSolanaAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignSolanaMessageJSONBody defines parameters for SignSolanaMessage.
type SignSolanaMessageJSONBody struct {
	// Message The arbitrary message to sign.
	Message string `json:"message"`
}

// SignSolanaMessageParams defines parameters for SignSolanaMessage.
type SignSolanaMessageParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignSolanaTransactionJSONBody defines parameters for SignSolanaTransaction.
type SignSolanaTransactionJSONBody struct {
	// Transaction The base64 encoded transaction to sign.
	Transaction string `json:"transaction"`
}

// SignSolanaTransactionParams defines parameters for SignSolanaTransaction.
type SignSolanaTransactionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// RequestSolanaFaucetJSONBody defines parameters for RequestSolanaFaucet.
type RequestSolanaFaucetJSONBody struct {
	// Address The address to request funds to, which is a base58-encoded string.
	Address string `json:"address"`

	// Token The token to request funds for.
	Token RequestSolanaFaucetJSONBodyToken `json:"token"`
}

// RequestSolanaFaucetJSONBodyToken defines parameters for RequestSolanaFaucet.
type RequestSolanaFaucetJSONBodyToken string

// ListSolanaTokenBalancesParams defines parameters for ListSolanaTokenBalances.
type ListSolanaTokenBalancesParams struct {
	// PageSize The number of balances to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of balances. Will be empty if there are no more balances to fetch.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// SettleX402PaymentJSONBody defines parameters for SettleX402Payment.
type SettleX402PaymentJSONBody struct {
	// PaymentPayload The x402 protocol payment payload that the client attaches to x402-paid API requests to the resource server in the X-PAYMENT header.
	PaymentPayload X402PaymentPayload `json:"paymentPayload"`

	// PaymentRequirements The x402 protocol payment requirements that the resource server expects the client's payment payload to meet.
	PaymentRequirements X402PaymentRequirements `json:"paymentRequirements"`

	// X402Version The version of the x402 protocol.
	X402Version X402Version `json:"x402Version"`
}

// VerifyX402PaymentJSONBody defines parameters for VerifyX402Payment.
type VerifyX402PaymentJSONBody struct {
	// PaymentPayload The x402 protocol payment payload that the client attaches to x402-paid API requests to the resource server in the X-PAYMENT header.
	PaymentPayload X402PaymentPayload `json:"paymentPayload"`

	// PaymentRequirements The x402 protocol payment requirements that the resource server expects the client's payment payload to meet.
	PaymentRequirements X402PaymentRequirements `json:"paymentRequirements"`

	// X402Version The version of the x402 protocol.
	X402Version X402Version `json:"x402Version"`
}

// RunSQLQueryJSONRequestBody defines body for RunSQLQuery for application/json ContentType.
type RunSQLQueryJSONRequestBody = OnchainDataQuery

// CreateWebhookSubscriptionJSONRequestBody defines body for CreateWebhookSubscription for application/json ContentType.
type CreateWebhookSubscriptionJSONRequestBody = WebhookSubscriptionRequest

// UpdateWebhookSubscriptionJSONRequestBody defines body for UpdateWebhookSubscription for application/json ContentType.
type UpdateWebhookSubscriptionJSONRequestBody = WebhookSubscriptionUpdateRequest

// CreateEndUserJSONRequestBody defines body for CreateEndUser for application/json ContentType.
type CreateEndUserJSONRequestBody CreateEndUserJSONBody

// ValidateEndUserAccessTokenJSONRequestBody defines body for ValidateEndUserAccessToken for application/json ContentType.
type ValidateEndUserAccessTokenJSONRequestBody ValidateEndUserAccessTokenJSONBody

// ImportEndUserJSONRequestBody defines body for ImportEndUser for application/json ContentType.
type ImportEndUserJSONRequestBody ImportEndUserJSONBody

// CreateEvmAccountJSONRequestBody defines body for CreateEvmAccount for application/json ContentType.
type CreateEvmAccountJSONRequestBody CreateEvmAccountJSONBody

// ExportEvmAccountByNameJSONRequestBody defines body for ExportEvmAccountByName for application/json ContentType.
type ExportEvmAccountByNameJSONRequestBody ExportEvmAccountByNameJSONBody

// ImportEvmAccountJSONRequestBody defines body for ImportEvmAccount for application/json ContentType.
type ImportEvmAccountJSONRequestBody ImportEvmAccountJSONBody

// UpdateEvmAccountJSONRequestBody defines body for UpdateEvmAccount for application/json ContentType.
type UpdateEvmAccountJSONRequestBody UpdateEvmAccountJSONBody

// ExportEvmAccountJSONRequestBody defines body for ExportEvmAccount for application/json ContentType.
type ExportEvmAccountJSONRequestBody ExportEvmAccountJSONBody

// SendEvmTransactionJSONRequestBody defines body for SendEvmTransaction for application/json ContentType.
type SendEvmTransactionJSONRequestBody SendEvmTransactionJSONBody

// SignEvmHashJSONRequestBody defines body for SignEvmHash for application/json ContentType.
type SignEvmHashJSONRequestBody SignEvmHashJSONBody

// SignEvmMessageJSONRequestBody defines body for SignEvmMessage for application/json ContentType.
type SignEvmMessageJSONRequestBody SignEvmMessageJSONBody

// SignEvmTransactionJSONRequestBody defines body for SignEvmTransaction for application/json ContentType.
type SignEvmTransactionJSONRequestBody SignEvmTransactionJSONBody

// SignEvmTypedDataJSONRequestBody defines body for SignEvmTypedData for application/json ContentType.
type SignEvmTypedDataJSONRequestBody = EIP712Message

// RequestEvmFaucetJSONRequestBody defines body for RequestEvmFaucet for application/json ContentType.
type RequestEvmFaucetJSONRequestBody RequestEvmFaucetJSONBody

// CreateEvmSmartAccountJSONRequestBody defines body for CreateEvmSmartAccount for application/json ContentType.
type CreateEvmSmartAccountJSONRequestBody CreateEvmSmartAccountJSONBody

// UpdateEvmSmartAccountJSONRequestBody defines body for UpdateEvmSmartAccount for application/json ContentType.
type UpdateEvmSmartAccountJSONRequestBody UpdateEvmSmartAccountJSONBody

// CreateSpendPermissionJSONRequestBody defines body for CreateSpendPermission for application/json ContentType.
type CreateSpendPermissionJSONRequestBody = CreateSpendPermissionRequest

// RevokeSpendPermissionJSONRequestBody defines body for RevokeSpendPermission for application/json ContentType.
type RevokeSpendPermissionJSONRequestBody = RevokeSpendPermissionRequest

// PrepareUserOperationJSONRequestBody defines body for PrepareUserOperation for application/json ContentType.
type PrepareUserOperationJSONRequestBody PrepareUserOperationJSONBody

// PrepareAndSendUserOperationJSONRequestBody defines body for PrepareAndSendUserOperation for application/json ContentType.
type PrepareAndSendUserOperationJSONRequestBody PrepareAndSendUserOperationJSONBody

// SendUserOperationJSONRequestBody defines body for SendUserOperation for application/json ContentType.
type SendUserOperationJSONRequestBody SendUserOperationJSONBody

// CreateEvmSwapQuoteJSONRequestBody defines body for CreateEvmSwapQuote for application/json ContentType.
type CreateEvmSwapQuoteJSONRequestBody CreateEvmSwapQuoteJSONBody

// CreateOnrampOrderJSONRequestBody defines body for CreateOnrampOrder for application/json ContentType.
type CreateOnrampOrderJSONRequestBody CreateOnrampOrderJSONBody

// CreateOnrampSessionJSONRequestBody defines body for CreateOnrampSession for application/json ContentType.
type CreateOnrampSessionJSONRequestBody CreateOnrampSessionJSONBody

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody CreatePolicyJSONBody

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody UpdatePolicyJSONBody

// CreateSolanaAccountJSONRequestBody defines body for CreateSolanaAccount for application/json ContentType.
type CreateSolanaAccountJSONRequestBody CreateSolanaAccountJSONBody

// ExportSolanaAccountByNameJSONRequestBody defines body for ExportSolanaAccountByName for application/json ContentType.
type ExportSolanaAccountByNameJSONRequestBody ExportSolanaAccountByNameJSONBody

// ImportSolanaAccountJSONRequestBody defines body for ImportSolanaAccount for application/json ContentType.
type ImportSolanaAccountJSONRequestBody ImportSolanaAccountJSONBody

// SendSolanaTransactionJSONRequestBody defines body for SendSolanaTransaction for application/json ContentType.
type SendSolanaTransactionJSONRequestBody SendSolanaTransactionJSONBody

// UpdateSolanaAccountJSONRequestBody defines body for UpdateSolanaAccount for application/json ContentType.
type UpdateSolanaAccountJSONRequestBody UpdateSolanaAccountJSONBody

// ExportSolanaAccountJSONRequestBody defines body for ExportSolanaAccount for application/json ContentType.
type ExportSolanaAccountJSONRequestBody ExportSolanaAccountJSONBody

// SignSolanaMessageJSONRequestBody defines body for SignSolanaMessage for application/json ContentType.
type SignSolanaMessageJSONRequestBody SignSolanaMessageJSONBody

// SignSolanaTransactionJSONRequestBody defines body for SignSolanaTransaction for application/json ContentType.
type SignSolanaTransactionJSONRequestBody SignSolanaTransactionJSONBody

// RequestSolanaFaucetJSONRequestBody defines body for RequestSolanaFaucet for application/json ContentType.
type RequestSolanaFaucetJSONRequestBody RequestSolanaFaucetJSONBody

// SettleX402PaymentJSONRequestBody defines body for SettleX402Payment for application/json ContentType.
type SettleX402PaymentJSONRequestBody SettleX402PaymentJSONBody

// VerifyX402PaymentJSONRequestBody defines body for VerifyX402Payment for application/json ContentType.
type VerifyX402PaymentJSONRequestBody VerifyX402PaymentJSONBody

// AsAbiFunction returns the union data inside the Abi_Item as a AbiFunction
func (t Abi_Item) AsAbiFunction() (AbiFunction, error) {
	var body AbiFunction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAbiFunction overwrites any union data inside the Abi_Item as the provided AbiFunction
func (t *Abi_Item) FromAbiFunction(v AbiFunction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAbiFunction performs a merge with any union data inside the Abi_Item, using the provided AbiFunction
func (t *Abi_Item) MergeAbiFunction(v AbiFunction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAbiInput returns the union data inside the Abi_Item as a AbiInput
func (t Abi_Item) AsAbiInput() (AbiInput, error) {
	var body AbiInput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAbiInput overwrites any union data inside the Abi_Item as the provided AbiInput
func (t *Abi_Item) FromAbiInput(v AbiInput) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAbiInput performs a merge with any union data inside the Abi_Item, using the provided AbiInput
func (t *Abi_Item) MergeAbiInput(v AbiInput) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Abi_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Abi_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEmailAuthentication returns the union data inside the AuthenticationMethod as a EmailAuthentication
func (t AuthenticationMethod) AsEmailAuthentication() (EmailAuthentication, error) {
	var body EmailAuthentication
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailAuthentication overwrites any union data inside the AuthenticationMethod as the provided EmailAuthentication
func (t *AuthenticationMethod) FromEmailAuthentication(v EmailAuthentication) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailAuthentication performs a merge with any union data inside the AuthenticationMethod, using the provided EmailAuthentication
func (t *AuthenticationMethod) MergeEmailAuthentication(v EmailAuthentication) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSmsAuthentication returns the union data inside the AuthenticationMethod as a SmsAuthentication
func (t AuthenticationMethod) AsSmsAuthentication() (SmsAuthentication, error) {
	var body SmsAuthentication
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsAuthentication overwrites any union data inside the AuthenticationMethod as the provided SmsAuthentication
func (t *AuthenticationMethod) FromSmsAuthentication(v SmsAuthentication) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsAuthentication performs a merge with any union data inside the AuthenticationMethod, using the provided SmsAuthentication
func (t *AuthenticationMethod) MergeSmsAuthentication(v SmsAuthentication) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeveloperJWTAuthentication returns the union data inside the AuthenticationMethod as a DeveloperJWTAuthentication
func (t AuthenticationMethod) AsDeveloperJWTAuthentication() (DeveloperJWTAuthentication, error) {
	var body DeveloperJWTAuthentication
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeveloperJWTAuthentication overwrites any union data inside the AuthenticationMethod as the provided DeveloperJWTAuthentication
func (t *AuthenticationMethod) FromDeveloperJWTAuthentication(v DeveloperJWTAuthentication) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeveloperJWTAuthentication performs a merge with any union data inside the AuthenticationMethod, using the provided DeveloperJWTAuthentication
func (t *AuthenticationMethod) MergeDeveloperJWTAuthentication(v DeveloperJWTAuthentication) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOAuth2Authentication returns the union data inside the AuthenticationMethod as a OAuth2Authentication
func (t AuthenticationMethod) AsOAuth2Authentication() (OAuth2Authentication, error) {
	var body OAuth2Authentication
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOAuth2Authentication overwrites any union data inside the AuthenticationMethod as the provided OAuth2Authentication
func (t *AuthenticationMethod) FromOAuth2Authentication(v OAuth2Authentication) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOAuth2Authentication performs a merge with any union data inside the AuthenticationMethod, using the provided OAuth2Authentication
func (t *AuthenticationMethod) MergeOAuth2Authentication(v OAuth2Authentication) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AuthenticationMethod) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AuthenticationMethod) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateSwapQuoteResponse returns the union data inside the CreateSwapQuoteResponseWrapper as a CreateSwapQuoteResponse
func (t CreateSwapQuoteResponseWrapper) AsCreateSwapQuoteResponse() (CreateSwapQuoteResponse, error) {
	var body CreateSwapQuoteResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSwapQuoteResponse overwrites any union data inside the CreateSwapQuoteResponseWrapper as the provided CreateSwapQuoteResponse
func (t *CreateSwapQuoteResponseWrapper) FromCreateSwapQuoteResponse(v CreateSwapQuoteResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSwapQuoteResponse performs a merge with any union data inside the CreateSwapQuoteResponseWrapper, using the provided CreateSwapQuoteResponse
func (t *CreateSwapQuoteResponseWrapper) MergeCreateSwapQuoteResponse(v CreateSwapQuoteResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwapUnavailableResponse returns the union data inside the CreateSwapQuoteResponseWrapper as a SwapUnavailableResponse
func (t CreateSwapQuoteResponseWrapper) AsSwapUnavailableResponse() (SwapUnavailableResponse, error) {
	var body SwapUnavailableResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwapUnavailableResponse overwrites any union data inside the CreateSwapQuoteResponseWrapper as the provided SwapUnavailableResponse
func (t *CreateSwapQuoteResponseWrapper) FromSwapUnavailableResponse(v SwapUnavailableResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwapUnavailableResponse performs a merge with any union data inside the CreateSwapQuoteResponseWrapper, using the provided SwapUnavailableResponse
func (t *CreateSwapQuoteResponseWrapper) MergeSwapUnavailableResponse(v SwapUnavailableResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateSwapQuoteResponseWrapper) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateSwapQuoteResponseWrapper) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvmDataParameterCondition returns the union data inside the EvmDataCondition_Params_Item as a EvmDataParameterCondition
func (t EvmDataCondition_Params_Item) AsEvmDataParameterCondition() (EvmDataParameterCondition, error) {
	var body EvmDataParameterCondition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataParameterCondition overwrites any union data inside the EvmDataCondition_Params_Item as the provided EvmDataParameterCondition
func (t *EvmDataCondition_Params_Item) FromEvmDataParameterCondition(v EvmDataParameterCondition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataParameterCondition performs a merge with any union data inside the EvmDataCondition_Params_Item, using the provided EvmDataParameterCondition
func (t *EvmDataCondition_Params_Item) MergeEvmDataParameterCondition(v EvmDataParameterCondition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmDataParameterConditionList returns the union data inside the EvmDataCondition_Params_Item as a EvmDataParameterConditionList
func (t EvmDataCondition_Params_Item) AsEvmDataParameterConditionList() (EvmDataParameterConditionList, error) {
	var body EvmDataParameterConditionList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataParameterConditionList overwrites any union data inside the EvmDataCondition_Params_Item as the provided EvmDataParameterConditionList
func (t *EvmDataCondition_Params_Item) FromEvmDataParameterConditionList(v EvmDataParameterConditionList) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataParameterConditionList performs a merge with any union data inside the EvmDataCondition_Params_Item, using the provided EvmDataParameterConditionList
func (t *EvmDataCondition_Params_Item) MergeEvmDataParameterConditionList(v EvmDataParameterConditionList) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t EvmDataCondition_Params_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EvmDataCondition_Params_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKnownAbiType returns the union data inside the EvmDataCriterion_Abi as a KnownAbiType
func (t EvmDataCriterion_Abi) AsKnownAbiType() (KnownAbiType, error) {
	var body KnownAbiType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKnownAbiType overwrites any union data inside the EvmDataCriterion_Abi as the provided KnownAbiType
func (t *EvmDataCriterion_Abi) FromKnownAbiType(v KnownAbiType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKnownAbiType performs a merge with any union data inside the EvmDataCriterion_Abi, using the provided KnownAbiType
func (t *EvmDataCriterion_Abi) MergeKnownAbiType(v KnownAbiType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAbi returns the union data inside the EvmDataCriterion_Abi as a Abi
func (t EvmDataCriterion_Abi) AsAbi() (Abi, error) {
	var body Abi
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAbi overwrites any union data inside the EvmDataCriterion_Abi as the provided Abi
func (t *EvmDataCriterion_Abi) FromAbi(v Abi) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAbi performs a merge with any union data inside the EvmDataCriterion_Abi, using the provided Abi
func (t *EvmDataCriterion_Abi) MergeAbi(v Abi) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t EvmDataCriterion_Abi) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EvmDataCriterion_Abi) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetSwapPriceResponse returns the union data inside the GetSwapPriceResponseWrapper as a GetSwapPriceResponse
func (t GetSwapPriceResponseWrapper) AsGetSwapPriceResponse() (GetSwapPriceResponse, error) {
	var body GetSwapPriceResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetSwapPriceResponse overwrites any union data inside the GetSwapPriceResponseWrapper as the provided GetSwapPriceResponse
func (t *GetSwapPriceResponseWrapper) FromGetSwapPriceResponse(v GetSwapPriceResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetSwapPriceResponse performs a merge with any union data inside the GetSwapPriceResponseWrapper, using the provided GetSwapPriceResponse
func (t *GetSwapPriceResponseWrapper) MergeGetSwapPriceResponse(v GetSwapPriceResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwapUnavailableResponse returns the union data inside the GetSwapPriceResponseWrapper as a SwapUnavailableResponse
func (t GetSwapPriceResponseWrapper) AsSwapUnavailableResponse() (SwapUnavailableResponse, error) {
	var body SwapUnavailableResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwapUnavailableResponse overwrites any union data inside the GetSwapPriceResponseWrapper as the provided SwapUnavailableResponse
func (t *GetSwapPriceResponseWrapper) FromSwapUnavailableResponse(v SwapUnavailableResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwapUnavailableResponse performs a merge with any union data inside the GetSwapPriceResponseWrapper, using the provided SwapUnavailableResponse
func (t *GetSwapPriceResponseWrapper) MergeSwapUnavailableResponse(v SwapUnavailableResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetSwapPriceResponseWrapper) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetSwapPriceResponseWrapper) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEthValueCriterion returns the union data inside the PrepareUserOperationCriteria_Item as a EthValueCriterion
func (t PrepareUserOperationCriteria_Item) AsEthValueCriterion() (EthValueCriterion, error) {
	var body EthValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEthValueCriterion overwrites any union data inside the PrepareUserOperationCriteria_Item as the provided EthValueCriterion
func (t *PrepareUserOperationCriteria_Item) FromEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEthValueCriterion performs a merge with any union data inside the PrepareUserOperationCriteria_Item, using the provided EthValueCriterion
func (t *PrepareUserOperationCriteria_Item) MergeEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmAddressCriterion returns the union data inside the PrepareUserOperationCriteria_Item as a EvmAddressCriterion
func (t PrepareUserOperationCriteria_Item) AsEvmAddressCriterion() (EvmAddressCriterion, error) {
	var body EvmAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmAddressCriterion overwrites any union data inside the PrepareUserOperationCriteria_Item as the provided EvmAddressCriterion
func (t *PrepareUserOperationCriteria_Item) FromEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmAddressCriterion performs a merge with any union data inside the PrepareUserOperationCriteria_Item, using the provided EvmAddressCriterion
func (t *PrepareUserOperationCriteria_Item) MergeEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmNetworkCriterion returns the union data inside the PrepareUserOperationCriteria_Item as a EvmNetworkCriterion
func (t PrepareUserOperationCriteria_Item) AsEvmNetworkCriterion() (EvmNetworkCriterion, error) {
	var body EvmNetworkCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmNetworkCriterion overwrites any union data inside the PrepareUserOperationCriteria_Item as the provided EvmNetworkCriterion
func (t *PrepareUserOperationCriteria_Item) FromEvmNetworkCriterion(v EvmNetworkCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmNetworkCriterion performs a merge with any union data inside the PrepareUserOperationCriteria_Item, using the provided EvmNetworkCriterion
func (t *PrepareUserOperationCriteria_Item) MergeEvmNetworkCriterion(v EvmNetworkCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmDataCriterion returns the union data inside the PrepareUserOperationCriteria_Item as a EvmDataCriterion
func (t PrepareUserOperationCriteria_Item) AsEvmDataCriterion() (EvmDataCriterion, error) {
	var body EvmDataCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataCriterion overwrites any union data inside the PrepareUserOperationCriteria_Item as the provided EvmDataCriterion
func (t *PrepareUserOperationCriteria_Item) FromEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataCriterion performs a merge with any union data inside the PrepareUserOperationCriteria_Item, using the provided EvmDataCriterion
func (t *PrepareUserOperationCriteria_Item) MergeEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetUSDChangeCriterion returns the union data inside the PrepareUserOperationCriteria_Item as a NetUSDChangeCriterion
func (t PrepareUserOperationCriteria_Item) AsNetUSDChangeCriterion() (NetUSDChangeCriterion, error) {
	var body NetUSDChangeCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetUSDChangeCriterion overwrites any union data inside the PrepareUserOperationCriteria_Item as the provided NetUSDChangeCriterion
func (t *PrepareUserOperationCriteria_Item) FromNetUSDChangeCriterion(v NetUSDChangeCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetUSDChangeCriterion performs a merge with any union data inside the PrepareUserOperationCriteria_Item, using the provided NetUSDChangeCriterion
func (t *PrepareUserOperationCriteria_Item) MergeNetUSDChangeCriterion(v NetUSDChangeCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t PrepareUserOperationCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PrepareUserOperationCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSignEvmTransactionRule returns the union data inside the Rule as a SignEvmTransactionRule
func (t Rule) AsSignEvmTransactionRule() (SignEvmTransactionRule, error) {
	var body SignEvmTransactionRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmTransactionRule overwrites any union data inside the Rule as the provided SignEvmTransactionRule
func (t *Rule) FromSignEvmTransactionRule(v SignEvmTransactionRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmTransactionRule performs a merge with any union data inside the Rule, using the provided SignEvmTransactionRule
func (t *Rule) MergeSignEvmTransactionRule(v SignEvmTransactionRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSendEvmTransactionRule returns the union data inside the Rule as a SendEvmTransactionRule
func (t Rule) AsSendEvmTransactionRule() (SendEvmTransactionRule, error) {
	var body SendEvmTransactionRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSendEvmTransactionRule overwrites any union data inside the Rule as the provided SendEvmTransactionRule
func (t *Rule) FromSendEvmTransactionRule(v SendEvmTransactionRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSendEvmTransactionRule performs a merge with any union data inside the Rule, using the provided SendEvmTransactionRule
func (t *Rule) MergeSendEvmTransactionRule(v SendEvmTransactionRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignEvmMessageRule returns the union data inside the Rule as a SignEvmMessageRule
func (t Rule) AsSignEvmMessageRule() (SignEvmMessageRule, error) {
	var body SignEvmMessageRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmMessageRule overwrites any union data inside the Rule as the provided SignEvmMessageRule
func (t *Rule) FromSignEvmMessageRule(v SignEvmMessageRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmMessageRule performs a merge with any union data inside the Rule, using the provided SignEvmMessageRule
func (t *Rule) MergeSignEvmMessageRule(v SignEvmMessageRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignEvmTypedDataRule returns the union data inside the Rule as a SignEvmTypedDataRule
func (t Rule) AsSignEvmTypedDataRule() (SignEvmTypedDataRule, error) {
	var body SignEvmTypedDataRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmTypedDataRule overwrites any union data inside the Rule as the provided SignEvmTypedDataRule
func (t *Rule) FromSignEvmTypedDataRule(v SignEvmTypedDataRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmTypedDataRule performs a merge with any union data inside the Rule, using the provided SignEvmTypedDataRule
func (t *Rule) MergeSignEvmTypedDataRule(v SignEvmTypedDataRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignSolTransactionRule returns the union data inside the Rule as a SignSolTransactionRule
func (t Rule) AsSignSolTransactionRule() (SignSolTransactionRule, error) {
	var body SignSolTransactionRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignSolTransactionRule overwrites any union data inside the Rule as the provided SignSolTransactionRule
func (t *Rule) FromSignSolTransactionRule(v SignSolTransactionRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignSolTransactionRule performs a merge with any union data inside the Rule, using the provided SignSolTransactionRule
func (t *Rule) MergeSignSolTransactionRule(v SignSolTransactionRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSendSolTransactionRule returns the union data inside the Rule as a SendSolTransactionRule
func (t Rule) AsSendSolTransactionRule() (SendSolTransactionRule, error) {
	var body SendSolTransactionRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSendSolTransactionRule overwrites any union data inside the Rule as the provided SendSolTransactionRule
func (t *Rule) FromSendSolTransactionRule(v SendSolTransactionRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSendSolTransactionRule performs a merge with any union data inside the Rule, using the provided SendSolTransactionRule
func (t *Rule) MergeSendSolTransactionRule(v SendSolTransactionRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignSolMessageRule returns the union data inside the Rule as a SignSolMessageRule
func (t Rule) AsSignSolMessageRule() (SignSolMessageRule, error) {
	var body SignSolMessageRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignSolMessageRule overwrites any union data inside the Rule as the provided SignSolMessageRule
func (t *Rule) FromSignSolMessageRule(v SignSolMessageRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignSolMessageRule performs a merge with any union data inside the Rule, using the provided SignSolMessageRule
func (t *Rule) MergeSignSolMessageRule(v SignSolMessageRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignEvmHashRule returns the union data inside the Rule as a SignEvmHashRule
func (t Rule) AsSignEvmHashRule() (SignEvmHashRule, error) {
	var body SignEvmHashRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmHashRule overwrites any union data inside the Rule as the provided SignEvmHashRule
func (t *Rule) FromSignEvmHashRule(v SignEvmHashRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmHashRule performs a merge with any union data inside the Rule, using the provided SignEvmHashRule
func (t *Rule) MergeSignEvmHashRule(v SignEvmHashRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsPrepareUserOperationRule returns the union data inside the Rule as a PrepareUserOperationRule
func (t Rule) AsPrepareUserOperationRule() (PrepareUserOperationRule, error) {
	var body PrepareUserOperationRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrepareUserOperationRule overwrites any union data inside the Rule as the provided PrepareUserOperationRule
func (t *Rule) FromPrepareUserOperationRule(v PrepareUserOperationRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrepareUserOperationRule performs a merge with any union data inside the Rule, using the provided PrepareUserOperationRule
func (t *Rule) MergePrepareUserOperationRule(v PrepareUserOperationRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSendUserOperationRule returns the union data inside the Rule as a SendUserOperationRule
func (t Rule) AsSendUserOperationRule() (SendUserOperationRule, error) {
	var body SendUserOperationRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSendUserOperationRule overwrites any union data inside the Rule as the provided SendUserOperationRule
func (t *Rule) FromSendUserOperationRule(v SendUserOperationRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSendUserOperationRule performs a merge with any union data inside the Rule, using the provided SendUserOperationRule
func (t *Rule) MergeSendUserOperationRule(v SendUserOperationRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Rule) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Rule) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEthValueCriterion returns the union data inside the SendEvmTransactionCriteria_Item as a EthValueCriterion
func (t SendEvmTransactionCriteria_Item) AsEthValueCriterion() (EthValueCriterion, error) {
	var body EthValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEthValueCriterion overwrites any union data inside the SendEvmTransactionCriteria_Item as the provided EthValueCriterion
func (t *SendEvmTransactionCriteria_Item) FromEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEthValueCriterion performs a merge with any union data inside the SendEvmTransactionCriteria_Item, using the provided EthValueCriterion
func (t *SendEvmTransactionCriteria_Item) MergeEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmAddressCriterion returns the union data inside the SendEvmTransactionCriteria_Item as a EvmAddressCriterion
func (t SendEvmTransactionCriteria_Item) AsEvmAddressCriterion() (EvmAddressCriterion, error) {
	var body EvmAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmAddressCriterion overwrites any union data inside the SendEvmTransactionCriteria_Item as the provided EvmAddressCriterion
func (t *SendEvmTransactionCriteria_Item) FromEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmAddressCriterion performs a merge with any union data inside the SendEvmTransactionCriteria_Item, using the provided EvmAddressCriterion
func (t *SendEvmTransactionCriteria_Item) MergeEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmNetworkCriterion returns the union data inside the SendEvmTransactionCriteria_Item as a EvmNetworkCriterion
func (t SendEvmTransactionCriteria_Item) AsEvmNetworkCriterion() (EvmNetworkCriterion, error) {
	var body EvmNetworkCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmNetworkCriterion overwrites any union data inside the SendEvmTransactionCriteria_Item as the provided EvmNetworkCriterion
func (t *SendEvmTransactionCriteria_Item) FromEvmNetworkCriterion(v EvmNetworkCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmNetworkCriterion performs a merge with any union data inside the SendEvmTransactionCriteria_Item, using the provided EvmNetworkCriterion
func (t *SendEvmTransactionCriteria_Item) MergeEvmNetworkCriterion(v EvmNetworkCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmDataCriterion returns the union data inside the SendEvmTransactionCriteria_Item as a EvmDataCriterion
func (t SendEvmTransactionCriteria_Item) AsEvmDataCriterion() (EvmDataCriterion, error) {
	var body EvmDataCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataCriterion overwrites any union data inside the SendEvmTransactionCriteria_Item as the provided EvmDataCriterion
func (t *SendEvmTransactionCriteria_Item) FromEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataCriterion performs a merge with any union data inside the SendEvmTransactionCriteria_Item, using the provided EvmDataCriterion
func (t *SendEvmTransactionCriteria_Item) MergeEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetUSDChangeCriterion returns the union data inside the SendEvmTransactionCriteria_Item as a NetUSDChangeCriterion
func (t SendEvmTransactionCriteria_Item) AsNetUSDChangeCriterion() (NetUSDChangeCriterion, error) {
	var body NetUSDChangeCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetUSDChangeCriterion overwrites any union data inside the SendEvmTransactionCriteria_Item as the provided NetUSDChangeCriterion
func (t *SendEvmTransactionCriteria_Item) FromNetUSDChangeCriterion(v NetUSDChangeCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetUSDChangeCriterion performs a merge with any union data inside the SendEvmTransactionCriteria_Item, using the provided NetUSDChangeCriterion
func (t *SendEvmTransactionCriteria_Item) MergeNetUSDChangeCriterion(v NetUSDChangeCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SendEvmTransactionCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SendEvmTransactionCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSolAddressCriterion returns the union data inside the SendSolTransactionCriteria_Item as a SolAddressCriterion
func (t SendSolTransactionCriteria_Item) AsSolAddressCriterion() (SolAddressCriterion, error) {
	var body SolAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolAddressCriterion overwrites any union data inside the SendSolTransactionCriteria_Item as the provided SolAddressCriterion
func (t *SendSolTransactionCriteria_Item) FromSolAddressCriterion(v SolAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolAddressCriterion performs a merge with any union data inside the SendSolTransactionCriteria_Item, using the provided SolAddressCriterion
func (t *SendSolTransactionCriteria_Item) MergeSolAddressCriterion(v SolAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSolValueCriterion returns the union data inside the SendSolTransactionCriteria_Item as a SolValueCriterion
func (t SendSolTransactionCriteria_Item) AsSolValueCriterion() (SolValueCriterion, error) {
	var body SolValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolValueCriterion overwrites any union data inside the SendSolTransactionCriteria_Item as the provided SolValueCriterion
func (t *SendSolTransactionCriteria_Item) FromSolValueCriterion(v SolValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolValueCriterion performs a merge with any union data inside the SendSolTransactionCriteria_Item, using the provided SolValueCriterion
func (t *SendSolTransactionCriteria_Item) MergeSolValueCriterion(v SolValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSplAddressCriterion returns the union data inside the SendSolTransactionCriteria_Item as a SplAddressCriterion
func (t SendSolTransactionCriteria_Item) AsSplAddressCriterion() (SplAddressCriterion, error) {
	var body SplAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSplAddressCriterion overwrites any union data inside the SendSolTransactionCriteria_Item as the provided SplAddressCriterion
func (t *SendSolTransactionCriteria_Item) FromSplAddressCriterion(v SplAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSplAddressCriterion performs a merge with any union data inside the SendSolTransactionCriteria_Item, using the provided SplAddressCriterion
func (t *SendSolTransactionCriteria_Item) MergeSplAddressCriterion(v SplAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSplValueCriterion returns the union data inside the SendSolTransactionCriteria_Item as a SplValueCriterion
func (t SendSolTransactionCriteria_Item) AsSplValueCriterion() (SplValueCriterion, error) {
	var body SplValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSplValueCriterion overwrites any union data inside the SendSolTransactionCriteria_Item as the provided SplValueCriterion
func (t *SendSolTransactionCriteria_Item) FromSplValueCriterion(v SplValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSplValueCriterion performs a merge with any union data inside the SendSolTransactionCriteria_Item, using the provided SplValueCriterion
func (t *SendSolTransactionCriteria_Item) MergeSplValueCriterion(v SplValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMintAddressCriterion returns the union data inside the SendSolTransactionCriteria_Item as a MintAddressCriterion
func (t SendSolTransactionCriteria_Item) AsMintAddressCriterion() (MintAddressCriterion, error) {
	var body MintAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMintAddressCriterion overwrites any union data inside the SendSolTransactionCriteria_Item as the provided MintAddressCriterion
func (t *SendSolTransactionCriteria_Item) FromMintAddressCriterion(v MintAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMintAddressCriterion performs a merge with any union data inside the SendSolTransactionCriteria_Item, using the provided MintAddressCriterion
func (t *SendSolTransactionCriteria_Item) MergeMintAddressCriterion(v MintAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSolDataCriterion returns the union data inside the SendSolTransactionCriteria_Item as a SolDataCriterion
func (t SendSolTransactionCriteria_Item) AsSolDataCriterion() (SolDataCriterion, error) {
	var body SolDataCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolDataCriterion overwrites any union data inside the SendSolTransactionCriteria_Item as the provided SolDataCriterion
func (t *SendSolTransactionCriteria_Item) FromSolDataCriterion(v SolDataCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolDataCriterion performs a merge with any union data inside the SendSolTransactionCriteria_Item, using the provided SolDataCriterion
func (t *SendSolTransactionCriteria_Item) MergeSolDataCriterion(v SolDataCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsProgramIdCriterion returns the union data inside the SendSolTransactionCriteria_Item as a ProgramIdCriterion
func (t SendSolTransactionCriteria_Item) AsProgramIdCriterion() (ProgramIdCriterion, error) {
	var body ProgramIdCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProgramIdCriterion overwrites any union data inside the SendSolTransactionCriteria_Item as the provided ProgramIdCriterion
func (t *SendSolTransactionCriteria_Item) FromProgramIdCriterion(v ProgramIdCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProgramIdCriterion performs a merge with any union data inside the SendSolTransactionCriteria_Item, using the provided ProgramIdCriterion
func (t *SendSolTransactionCriteria_Item) MergeProgramIdCriterion(v ProgramIdCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSolNetworkCriterion returns the union data inside the SendSolTransactionCriteria_Item as a SolNetworkCriterion
func (t SendSolTransactionCriteria_Item) AsSolNetworkCriterion() (SolNetworkCriterion, error) {
	var body SolNetworkCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolNetworkCriterion overwrites any union data inside the SendSolTransactionCriteria_Item as the provided SolNetworkCriterion
func (t *SendSolTransactionCriteria_Item) FromSolNetworkCriterion(v SolNetworkCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolNetworkCriterion performs a merge with any union data inside the SendSolTransactionCriteria_Item, using the provided SolNetworkCriterion
func (t *SendSolTransactionCriteria_Item) MergeSolNetworkCriterion(v SolNetworkCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SendSolTransactionCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SendSolTransactionCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEthValueCriterion returns the union data inside the SendUserOperationCriteria_Item as a EthValueCriterion
func (t SendUserOperationCriteria_Item) AsEthValueCriterion() (EthValueCriterion, error) {
	var body EthValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEthValueCriterion overwrites any union data inside the SendUserOperationCriteria_Item as the provided EthValueCriterion
func (t *SendUserOperationCriteria_Item) FromEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEthValueCriterion performs a merge with any union data inside the SendUserOperationCriteria_Item, using the provided EthValueCriterion
func (t *SendUserOperationCriteria_Item) MergeEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmAddressCriterion returns the union data inside the SendUserOperationCriteria_Item as a EvmAddressCriterion
func (t SendUserOperationCriteria_Item) AsEvmAddressCriterion() (EvmAddressCriterion, error) {
	var body EvmAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmAddressCriterion overwrites any union data inside the SendUserOperationCriteria_Item as the provided EvmAddressCriterion
func (t *SendUserOperationCriteria_Item) FromEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmAddressCriterion performs a merge with any union data inside the SendUserOperationCriteria_Item, using the provided EvmAddressCriterion
func (t *SendUserOperationCriteria_Item) MergeEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmDataCriterion returns the union data inside the SendUserOperationCriteria_Item as a EvmDataCriterion
func (t SendUserOperationCriteria_Item) AsEvmDataCriterion() (EvmDataCriterion, error) {
	var body EvmDataCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataCriterion overwrites any union data inside the SendUserOperationCriteria_Item as the provided EvmDataCriterion
func (t *SendUserOperationCriteria_Item) FromEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataCriterion performs a merge with any union data inside the SendUserOperationCriteria_Item, using the provided EvmDataCriterion
func (t *SendUserOperationCriteria_Item) MergeEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetUSDChangeCriterion returns the union data inside the SendUserOperationCriteria_Item as a NetUSDChangeCriterion
func (t SendUserOperationCriteria_Item) AsNetUSDChangeCriterion() (NetUSDChangeCriterion, error) {
	var body NetUSDChangeCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetUSDChangeCriterion overwrites any union data inside the SendUserOperationCriteria_Item as the provided NetUSDChangeCriterion
func (t *SendUserOperationCriteria_Item) FromNetUSDChangeCriterion(v NetUSDChangeCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetUSDChangeCriterion performs a merge with any union data inside the SendUserOperationCriteria_Item, using the provided NetUSDChangeCriterion
func (t *SendUserOperationCriteria_Item) MergeNetUSDChangeCriterion(v NetUSDChangeCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SendUserOperationCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SendUserOperationCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvmMessageCriterion returns the union data inside the SignEvmMessageCriteria_Item as a EvmMessageCriterion
func (t SignEvmMessageCriteria_Item) AsEvmMessageCriterion() (EvmMessageCriterion, error) {
	var body EvmMessageCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmMessageCriterion overwrites any union data inside the SignEvmMessageCriteria_Item as the provided EvmMessageCriterion
func (t *SignEvmMessageCriteria_Item) FromEvmMessageCriterion(v EvmMessageCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmMessageCriterion performs a merge with any union data inside the SignEvmMessageCriteria_Item, using the provided EvmMessageCriterion
func (t *SignEvmMessageCriteria_Item) MergeEvmMessageCriterion(v EvmMessageCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignEvmMessageCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignEvmMessageCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEthValueCriterion returns the union data inside the SignEvmTransactionCriteria_Item as a EthValueCriterion
func (t SignEvmTransactionCriteria_Item) AsEthValueCriterion() (EthValueCriterion, error) {
	var body EthValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEthValueCriterion overwrites any union data inside the SignEvmTransactionCriteria_Item as the provided EthValueCriterion
func (t *SignEvmTransactionCriteria_Item) FromEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEthValueCriterion performs a merge with any union data inside the SignEvmTransactionCriteria_Item, using the provided EthValueCriterion
func (t *SignEvmTransactionCriteria_Item) MergeEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmAddressCriterion returns the union data inside the SignEvmTransactionCriteria_Item as a EvmAddressCriterion
func (t SignEvmTransactionCriteria_Item) AsEvmAddressCriterion() (EvmAddressCriterion, error) {
	var body EvmAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmAddressCriterion overwrites any union data inside the SignEvmTransactionCriteria_Item as the provided EvmAddressCriterion
func (t *SignEvmTransactionCriteria_Item) FromEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmAddressCriterion performs a merge with any union data inside the SignEvmTransactionCriteria_Item, using the provided EvmAddressCriterion
func (t *SignEvmTransactionCriteria_Item) MergeEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmDataCriterion returns the union data inside the SignEvmTransactionCriteria_Item as a EvmDataCriterion
func (t SignEvmTransactionCriteria_Item) AsEvmDataCriterion() (EvmDataCriterion, error) {
	var body EvmDataCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataCriterion overwrites any union data inside the SignEvmTransactionCriteria_Item as the provided EvmDataCriterion
func (t *SignEvmTransactionCriteria_Item) FromEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataCriterion performs a merge with any union data inside the SignEvmTransactionCriteria_Item, using the provided EvmDataCriterion
func (t *SignEvmTransactionCriteria_Item) MergeEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetUSDChangeCriterion returns the union data inside the SignEvmTransactionCriteria_Item as a NetUSDChangeCriterion
func (t SignEvmTransactionCriteria_Item) AsNetUSDChangeCriterion() (NetUSDChangeCriterion, error) {
	var body NetUSDChangeCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetUSDChangeCriterion overwrites any union data inside the SignEvmTransactionCriteria_Item as the provided NetUSDChangeCriterion
func (t *SignEvmTransactionCriteria_Item) FromNetUSDChangeCriterion(v NetUSDChangeCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetUSDChangeCriterion performs a merge with any union data inside the SignEvmTransactionCriteria_Item, using the provided NetUSDChangeCriterion
func (t *SignEvmTransactionCriteria_Item) MergeNetUSDChangeCriterion(v NetUSDChangeCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignEvmTransactionCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignEvmTransactionCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSignEvmTypedDataFieldCriterion returns the union data inside the SignEvmTypedDataCriteria_Item as a SignEvmTypedDataFieldCriterion
func (t SignEvmTypedDataCriteria_Item) AsSignEvmTypedDataFieldCriterion() (SignEvmTypedDataFieldCriterion, error) {
	var body SignEvmTypedDataFieldCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmTypedDataFieldCriterion overwrites any union data inside the SignEvmTypedDataCriteria_Item as the provided SignEvmTypedDataFieldCriterion
func (t *SignEvmTypedDataCriteria_Item) FromSignEvmTypedDataFieldCriterion(v SignEvmTypedDataFieldCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmTypedDataFieldCriterion performs a merge with any union data inside the SignEvmTypedDataCriteria_Item, using the provided SignEvmTypedDataFieldCriterion
func (t *SignEvmTypedDataCriteria_Item) MergeSignEvmTypedDataFieldCriterion(v SignEvmTypedDataFieldCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignEvmTypedDataVerifyingContractCriterion returns the union data inside the SignEvmTypedDataCriteria_Item as a SignEvmTypedDataVerifyingContractCriterion
func (t SignEvmTypedDataCriteria_Item) AsSignEvmTypedDataVerifyingContractCriterion() (SignEvmTypedDataVerifyingContractCriterion, error) {
	var body SignEvmTypedDataVerifyingContractCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmTypedDataVerifyingContractCriterion overwrites any union data inside the SignEvmTypedDataCriteria_Item as the provided SignEvmTypedDataVerifyingContractCriterion
func (t *SignEvmTypedDataCriteria_Item) FromSignEvmTypedDataVerifyingContractCriterion(v SignEvmTypedDataVerifyingContractCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmTypedDataVerifyingContractCriterion performs a merge with any union data inside the SignEvmTypedDataCriteria_Item, using the provided SignEvmTypedDataVerifyingContractCriterion
func (t *SignEvmTypedDataCriteria_Item) MergeSignEvmTypedDataVerifyingContractCriterion(v SignEvmTypedDataVerifyingContractCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignEvmTypedDataCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignEvmTypedDataCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvmTypedAddressCondition returns the union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item as a EvmTypedAddressCondition
func (t SignEvmTypedDataFieldCriterion_Conditions_Item) AsEvmTypedAddressCondition() (EvmTypedAddressCondition, error) {
	var body EvmTypedAddressCondition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmTypedAddressCondition overwrites any union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item as the provided EvmTypedAddressCondition
func (t *SignEvmTypedDataFieldCriterion_Conditions_Item) FromEvmTypedAddressCondition(v EvmTypedAddressCondition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmTypedAddressCondition performs a merge with any union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item, using the provided EvmTypedAddressCondition
func (t *SignEvmTypedDataFieldCriterion_Conditions_Item) MergeEvmTypedAddressCondition(v EvmTypedAddressCondition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmTypedNumericalCondition returns the union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item as a EvmTypedNumericalCondition
func (t SignEvmTypedDataFieldCriterion_Conditions_Item) AsEvmTypedNumericalCondition() (EvmTypedNumericalCondition, error) {
	var body EvmTypedNumericalCondition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmTypedNumericalCondition overwrites any union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item as the provided EvmTypedNumericalCondition
func (t *SignEvmTypedDataFieldCriterion_Conditions_Item) FromEvmTypedNumericalCondition(v EvmTypedNumericalCondition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmTypedNumericalCondition performs a merge with any union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item, using the provided EvmTypedNumericalCondition
func (t *SignEvmTypedDataFieldCriterion_Conditions_Item) MergeEvmTypedNumericalCondition(v EvmTypedNumericalCondition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmTypedStringCondition returns the union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item as a EvmTypedStringCondition
func (t SignEvmTypedDataFieldCriterion_Conditions_Item) AsEvmTypedStringCondition() (EvmTypedStringCondition, error) {
	var body EvmTypedStringCondition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmTypedStringCondition overwrites any union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item as the provided EvmTypedStringCondition
func (t *SignEvmTypedDataFieldCriterion_Conditions_Item) FromEvmTypedStringCondition(v EvmTypedStringCondition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmTypedStringCondition performs a merge with any union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item, using the provided EvmTypedStringCondition
func (t *SignEvmTypedDataFieldCriterion_Conditions_Item) MergeEvmTypedStringCondition(v EvmTypedStringCondition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignEvmTypedDataFieldCriterion_Conditions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignEvmTypedDataFieldCriterion_Conditions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSolMessageCriterion returns the union data inside the SignSolMessageCriteria_Item as a SolMessageCriterion
func (t SignSolMessageCriteria_Item) AsSolMessageCriterion() (SolMessageCriterion, error) {
	var body SolMessageCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolMessageCriterion overwrites any union data inside the SignSolMessageCriteria_Item as the provided SolMessageCriterion
func (t *SignSolMessageCriteria_Item) FromSolMessageCriterion(v SolMessageCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolMessageCriterion performs a merge with any union data inside the SignSolMessageCriteria_Item, using the provided SolMessageCriterion
func (t *SignSolMessageCriteria_Item) MergeSolMessageCriterion(v SolMessageCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignSolMessageCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignSolMessageCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSolAddressCriterion returns the union data inside the SignSolTransactionCriteria_Item as a SolAddressCriterion
func (t SignSolTransactionCriteria_Item) AsSolAddressCriterion() (SolAddressCriterion, error) {
	var body SolAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolAddressCriterion overwrites any union data inside the SignSolTransactionCriteria_Item as the provided SolAddressCriterion
func (t *SignSolTransactionCriteria_Item) FromSolAddressCriterion(v SolAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolAddressCriterion performs a merge with any union data inside the SignSolTransactionCriteria_Item, using the provided SolAddressCriterion
func (t *SignSolTransactionCriteria_Item) MergeSolAddressCriterion(v SolAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSolValueCriterion returns the union data inside the SignSolTransactionCriteria_Item as a SolValueCriterion
func (t SignSolTransactionCriteria_Item) AsSolValueCriterion() (SolValueCriterion, error) {
	var body SolValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolValueCriterion overwrites any union data inside the SignSolTransactionCriteria_Item as the provided SolValueCriterion
func (t *SignSolTransactionCriteria_Item) FromSolValueCriterion(v SolValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolValueCriterion performs a merge with any union data inside the SignSolTransactionCriteria_Item, using the provided SolValueCriterion
func (t *SignSolTransactionCriteria_Item) MergeSolValueCriterion(v SolValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSplAddressCriterion returns the union data inside the SignSolTransactionCriteria_Item as a SplAddressCriterion
func (t SignSolTransactionCriteria_Item) AsSplAddressCriterion() (SplAddressCriterion, error) {
	var body SplAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSplAddressCriterion overwrites any union data inside the SignSolTransactionCriteria_Item as the provided SplAddressCriterion
func (t *SignSolTransactionCriteria_Item) FromSplAddressCriterion(v SplAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSplAddressCriterion performs a merge with any union data inside the SignSolTransactionCriteria_Item, using the provided SplAddressCriterion
func (t *SignSolTransactionCriteria_Item) MergeSplAddressCriterion(v SplAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSplValueCriterion returns the union data inside the SignSolTransactionCriteria_Item as a SplValueCriterion
func (t SignSolTransactionCriteria_Item) AsSplValueCriterion() (SplValueCriterion, error) {
	var body SplValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSplValueCriterion overwrites any union data inside the SignSolTransactionCriteria_Item as the provided SplValueCriterion
func (t *SignSolTransactionCriteria_Item) FromSplValueCriterion(v SplValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSplValueCriterion performs a merge with any union data inside the SignSolTransactionCriteria_Item, using the provided SplValueCriterion
func (t *SignSolTransactionCriteria_Item) MergeSplValueCriterion(v SplValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMintAddressCriterion returns the union data inside the SignSolTransactionCriteria_Item as a MintAddressCriterion
func (t SignSolTransactionCriteria_Item) AsMintAddressCriterion() (MintAddressCriterion, error) {
	var body MintAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMintAddressCriterion overwrites any union data inside the SignSolTransactionCriteria_Item as the provided MintAddressCriterion
func (t *SignSolTransactionCriteria_Item) FromMintAddressCriterion(v MintAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMintAddressCriterion performs a merge with any union data inside the SignSolTransactionCriteria_Item, using the provided MintAddressCriterion
func (t *SignSolTransactionCriteria_Item) MergeMintAddressCriterion(v MintAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSolDataCriterion returns the union data inside the SignSolTransactionCriteria_Item as a SolDataCriterion
func (t SignSolTransactionCriteria_Item) AsSolDataCriterion() (SolDataCriterion, error) {
	var body SolDataCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolDataCriterion overwrites any union data inside the SignSolTransactionCriteria_Item as the provided SolDataCriterion
func (t *SignSolTransactionCriteria_Item) FromSolDataCriterion(v SolDataCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolDataCriterion performs a merge with any union data inside the SignSolTransactionCriteria_Item, using the provided SolDataCriterion
func (t *SignSolTransactionCriteria_Item) MergeSolDataCriterion(v SolDataCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsProgramIdCriterion returns the union data inside the SignSolTransactionCriteria_Item as a ProgramIdCriterion
func (t SignSolTransactionCriteria_Item) AsProgramIdCriterion() (ProgramIdCriterion, error) {
	var body ProgramIdCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProgramIdCriterion overwrites any union data inside the SignSolTransactionCriteria_Item as the provided ProgramIdCriterion
func (t *SignSolTransactionCriteria_Item) FromProgramIdCriterion(v ProgramIdCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProgramIdCriterion performs a merge with any union data inside the SignSolTransactionCriteria_Item, using the provided ProgramIdCriterion
func (t *SignSolTransactionCriteria_Item) MergeProgramIdCriterion(v ProgramIdCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignSolTransactionCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignSolTransactionCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSolDataParameterCondition returns the union data inside the SolDataCondition_Params_Item as a SolDataParameterCondition
func (t SolDataCondition_Params_Item) AsSolDataParameterCondition() (SolDataParameterCondition, error) {
	var body SolDataParameterCondition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolDataParameterCondition overwrites any union data inside the SolDataCondition_Params_Item as the provided SolDataParameterCondition
func (t *SolDataCondition_Params_Item) FromSolDataParameterCondition(v SolDataParameterCondition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolDataParameterCondition performs a merge with any union data inside the SolDataCondition_Params_Item, using the provided SolDataParameterCondition
func (t *SolDataCondition_Params_Item) MergeSolDataParameterCondition(v SolDataParameterCondition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSolDataParameterConditionList returns the union data inside the SolDataCondition_Params_Item as a SolDataParameterConditionList
func (t SolDataCondition_Params_Item) AsSolDataParameterConditionList() (SolDataParameterConditionList, error) {
	var body SolDataParameterConditionList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolDataParameterConditionList overwrites any union data inside the SolDataCondition_Params_Item as the provided SolDataParameterConditionList
func (t *SolDataCondition_Params_Item) FromSolDataParameterConditionList(v SolDataParameterConditionList) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolDataParameterConditionList performs a merge with any union data inside the SolDataCondition_Params_Item, using the provided SolDataParameterConditionList
func (t *SolDataCondition_Params_Item) MergeSolDataParameterConditionList(v SolDataParameterConditionList) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SolDataCondition_Params_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SolDataCondition_Params_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKnownIdlType returns the union data inside the SolDataCriterion_Idls_Item as a KnownIdlType
func (t SolDataCriterion_Idls_Item) AsKnownIdlType() (KnownIdlType, error) {
	var body KnownIdlType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKnownIdlType overwrites any union data inside the SolDataCriterion_Idls_Item as the provided KnownIdlType
func (t *SolDataCriterion_Idls_Item) FromKnownIdlType(v KnownIdlType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKnownIdlType performs a merge with any union data inside the SolDataCriterion_Idls_Item, using the provided KnownIdlType
func (t *SolDataCriterion_Idls_Item) MergeKnownIdlType(v KnownIdlType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdl returns the union data inside the SolDataCriterion_Idls_Item as a Idl
func (t SolDataCriterion_Idls_Item) AsIdl() (Idl, error) {
	var body Idl
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdl overwrites any union data inside the SolDataCriterion_Idls_Item as the provided Idl
func (t *SolDataCriterion_Idls_Item) FromIdl(v Idl) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdl performs a merge with any union data inside the SolDataCriterion_Idls_Item, using the provided Idl
func (t *SolDataCriterion_Idls_Item) MergeIdl(v Idl) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SolDataCriterion_Idls_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SolDataCriterion_Idls_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWebhookSubscriptionRequest0 returns the union data inside the WebhookSubscriptionRequest as a WebhookSubscriptionRequest0
func (t WebhookSubscriptionRequest) AsWebhookSubscriptionRequest0() (WebhookSubscriptionRequest0, error) {
	var body WebhookSubscriptionRequest0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookSubscriptionRequest0 overwrites any union data inside the WebhookSubscriptionRequest as the provided WebhookSubscriptionRequest0
func (t *WebhookSubscriptionRequest) FromWebhookSubscriptionRequest0(v WebhookSubscriptionRequest0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookSubscriptionRequest0 performs a merge with any union data inside the WebhookSubscriptionRequest, using the provided WebhookSubscriptionRequest0
func (t *WebhookSubscriptionRequest) MergeWebhookSubscriptionRequest0(v WebhookSubscriptionRequest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookSubscriptionRequest1 returns the union data inside the WebhookSubscriptionRequest as a WebhookSubscriptionRequest1
func (t WebhookSubscriptionRequest) AsWebhookSubscriptionRequest1() (WebhookSubscriptionRequest1, error) {
	var body WebhookSubscriptionRequest1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookSubscriptionRequest1 overwrites any union data inside the WebhookSubscriptionRequest as the provided WebhookSubscriptionRequest1
func (t *WebhookSubscriptionRequest) FromWebhookSubscriptionRequest1(v WebhookSubscriptionRequest1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookSubscriptionRequest1 performs a merge with any union data inside the WebhookSubscriptionRequest, using the provided WebhookSubscriptionRequest1
func (t *WebhookSubscriptionRequest) MergeWebhookSubscriptionRequest1(v WebhookSubscriptionRequest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t WebhookSubscriptionRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Description != nil {
		object["description"], err = json.Marshal(t.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if t.EventTypes != nil {
		object["eventTypes"], err = json.Marshal(t.EventTypes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'eventTypes': %w", err)
		}
	}

	if t.IsEnabled != nil {
		object["isEnabled"], err = json.Marshal(t.IsEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isEnabled': %w", err)
		}
	}

	if t.LabelKey != nil {
		object["labelKey"], err = json.Marshal(t.LabelKey)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'labelKey': %w", err)
		}
	}

	if t.LabelValue != nil {
		object["labelValue"], err = json.Marshal(t.LabelValue)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'labelValue': %w", err)
		}
	}

	if t.Labels != nil {
		object["labels"], err = json.Marshal(t.Labels)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'labels': %w", err)
		}
	}

	if t.Metadata != nil {
		object["metadata"], err = json.Marshal(t.Metadata)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'metadata': %w", err)
		}
	}

	if t.Target != nil {
		object["target"], err = json.Marshal(t.Target)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *WebhookSubscriptionRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &t.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
	}

	if raw, found := object["eventTypes"]; found {
		err = json.Unmarshal(raw, &t.EventTypes)
		if err != nil {
			return fmt.Errorf("error reading 'eventTypes': %w", err)
		}
	}

	if raw, found := object["isEnabled"]; found {
		err = json.Unmarshal(raw, &t.IsEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'isEnabled': %w", err)
		}
	}

	if raw, found := object["labelKey"]; found {
		err = json.Unmarshal(raw, &t.LabelKey)
		if err != nil {
			return fmt.Errorf("error reading 'labelKey': %w", err)
		}
	}

	if raw, found := object["labelValue"]; found {
		err = json.Unmarshal(raw, &t.LabelValue)
		if err != nil {
			return fmt.Errorf("error reading 'labelValue': %w", err)
		}
	}

	if raw, found := object["labels"]; found {
		err = json.Unmarshal(raw, &t.Labels)
		if err != nil {
			return fmt.Errorf("error reading 'labels': %w", err)
		}
	}

	if raw, found := object["metadata"]; found {
		err = json.Unmarshal(raw, &t.Metadata)
		if err != nil {
			return fmt.Errorf("error reading 'metadata': %w", err)
		}
	}

	if raw, found := object["target"]; found {
		err = json.Unmarshal(raw, &t.Target)
		if err != nil {
			return fmt.Errorf("error reading 'target': %w", err)
		}
	}

	return err
}

// AsWebhookSubscriptionUpdateRequest0 returns the union data inside the WebhookSubscriptionUpdateRequest as a WebhookSubscriptionUpdateRequest0
func (t WebhookSubscriptionUpdateRequest) AsWebhookSubscriptionUpdateRequest0() (WebhookSubscriptionUpdateRequest0, error) {
	var body WebhookSubscriptionUpdateRequest0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookSubscriptionUpdateRequest0 overwrites any union data inside the WebhookSubscriptionUpdateRequest as the provided WebhookSubscriptionUpdateRequest0
func (t *WebhookSubscriptionUpdateRequest) FromWebhookSubscriptionUpdateRequest0(v WebhookSubscriptionUpdateRequest0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookSubscriptionUpdateRequest0 performs a merge with any union data inside the WebhookSubscriptionUpdateRequest, using the provided WebhookSubscriptionUpdateRequest0
func (t *WebhookSubscriptionUpdateRequest) MergeWebhookSubscriptionUpdateRequest0(v WebhookSubscriptionUpdateRequest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookSubscriptionUpdateRequest1 returns the union data inside the WebhookSubscriptionUpdateRequest as a WebhookSubscriptionUpdateRequest1
func (t WebhookSubscriptionUpdateRequest) AsWebhookSubscriptionUpdateRequest1() (WebhookSubscriptionUpdateRequest1, error) {
	var body WebhookSubscriptionUpdateRequest1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookSubscriptionUpdateRequest1 overwrites any union data inside the WebhookSubscriptionUpdateRequest as the provided WebhookSubscriptionUpdateRequest1
func (t *WebhookSubscriptionUpdateRequest) FromWebhookSubscriptionUpdateRequest1(v WebhookSubscriptionUpdateRequest1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookSubscriptionUpdateRequest1 performs a merge with any union data inside the WebhookSubscriptionUpdateRequest, using the provided WebhookSubscriptionUpdateRequest1
func (t *WebhookSubscriptionUpdateRequest) MergeWebhookSubscriptionUpdateRequest1(v WebhookSubscriptionUpdateRequest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t WebhookSubscriptionUpdateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Description != nil {
		object["description"], err = json.Marshal(t.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if t.EventTypes != nil {
		object["eventTypes"], err = json.Marshal(t.EventTypes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'eventTypes': %w", err)
		}
	}

	if t.IsEnabled != nil {
		object["isEnabled"], err = json.Marshal(t.IsEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isEnabled': %w", err)
		}
	}

	if t.LabelKey != nil {
		object["labelKey"], err = json.Marshal(t.LabelKey)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'labelKey': %w", err)
		}
	}

	if t.LabelValue != nil {
		object["labelValue"], err = json.Marshal(t.LabelValue)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'labelValue': %w", err)
		}
	}

	if t.Labels != nil {
		object["labels"], err = json.Marshal(t.Labels)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'labels': %w", err)
		}
	}

	if t.Metadata != nil {
		object["metadata"], err = json.Marshal(t.Metadata)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'metadata': %w", err)
		}
	}

	if t.Target != nil {
		object["target"], err = json.Marshal(t.Target)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'target': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *WebhookSubscriptionUpdateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &t.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
	}

	if raw, found := object["eventTypes"]; found {
		err = json.Unmarshal(raw, &t.EventTypes)
		if err != nil {
			return fmt.Errorf("error reading 'eventTypes': %w", err)
		}
	}

	if raw, found := object["isEnabled"]; found {
		err = json.Unmarshal(raw, &t.IsEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'isEnabled': %w", err)
		}
	}

	if raw, found := object["labelKey"]; found {
		err = json.Unmarshal(raw, &t.LabelKey)
		if err != nil {
			return fmt.Errorf("error reading 'labelKey': %w", err)
		}
	}

	if raw, found := object["labelValue"]; found {
		err = json.Unmarshal(raw, &t.LabelValue)
		if err != nil {
			return fmt.Errorf("error reading 'labelValue': %w", err)
		}
	}

	if raw, found := object["labels"]; found {
		err = json.Unmarshal(raw, &t.Labels)
		if err != nil {
			return fmt.Errorf("error reading 'labels': %w", err)
		}
	}

	if raw, found := object["metadata"]; found {
		err = json.Unmarshal(raw, &t.Metadata)
		if err != nil {
			return fmt.Errorf("error reading 'metadata': %w", err)
		}
	}

	if raw, found := object["target"]; found {
		err = json.Unmarshal(raw, &t.Target)
		if err != nil {
			return fmt.Errorf("error reading 'target': %w", err)
		}
	}

	return err
}

// AsX402V1PaymentPayload returns the union data inside the X402PaymentPayload as a X402V1PaymentPayload
func (t X402PaymentPayload) AsX402V1PaymentPayload() (X402V1PaymentPayload, error) {
	var body X402V1PaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX402V1PaymentPayload overwrites any union data inside the X402PaymentPayload as the provided X402V1PaymentPayload
func (t *X402PaymentPayload) FromX402V1PaymentPayload(v X402V1PaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX402V1PaymentPayload performs a merge with any union data inside the X402PaymentPayload, using the provided X402V1PaymentPayload
func (t *X402PaymentPayload) MergeX402V1PaymentPayload(v X402V1PaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsX402V2PaymentPayload returns the union data inside the X402PaymentPayload as a X402V2PaymentPayload
func (t X402PaymentPayload) AsX402V2PaymentPayload() (X402V2PaymentPayload, error) {
	var body X402V2PaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX402V2PaymentPayload overwrites any union data inside the X402PaymentPayload as the provided X402V2PaymentPayload
func (t *X402PaymentPayload) FromX402V2PaymentPayload(v X402V2PaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX402V2PaymentPayload performs a merge with any union data inside the X402PaymentPayload, using the provided X402V2PaymentPayload
func (t *X402PaymentPayload) MergeX402V2PaymentPayload(v X402V2PaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t X402PaymentPayload) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *X402PaymentPayload) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsX402V1PaymentRequirements returns the union data inside the X402PaymentRequirements as a X402V1PaymentRequirements
func (t X402PaymentRequirements) AsX402V1PaymentRequirements() (X402V1PaymentRequirements, error) {
	var body X402V1PaymentRequirements
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX402V1PaymentRequirements overwrites any union data inside the X402PaymentRequirements as the provided X402V1PaymentRequirements
func (t *X402PaymentRequirements) FromX402V1PaymentRequirements(v X402V1PaymentRequirements) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX402V1PaymentRequirements performs a merge with any union data inside the X402PaymentRequirements, using the provided X402V1PaymentRequirements
func (t *X402PaymentRequirements) MergeX402V1PaymentRequirements(v X402V1PaymentRequirements) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsX402V2PaymentRequirements returns the union data inside the X402PaymentRequirements as a X402V2PaymentRequirements
func (t X402PaymentRequirements) AsX402V2PaymentRequirements() (X402V2PaymentRequirements, error) {
	var body X402V2PaymentRequirements
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX402V2PaymentRequirements overwrites any union data inside the X402PaymentRequirements as the provided X402V2PaymentRequirements
func (t *X402PaymentRequirements) FromX402V2PaymentRequirements(v X402V2PaymentRequirements) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX402V2PaymentRequirements performs a merge with any union data inside the X402PaymentRequirements, using the provided X402V2PaymentRequirements
func (t *X402PaymentRequirements) MergeX402V2PaymentRequirements(v X402V2PaymentRequirements) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t X402PaymentRequirements) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *X402PaymentRequirements) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsX402ExactEvmPayload returns the union data inside the X402V1PaymentPayload_Payload as a X402ExactEvmPayload
func (t X402V1PaymentPayload_Payload) AsX402ExactEvmPayload() (X402ExactEvmPayload, error) {
	var body X402ExactEvmPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX402ExactEvmPayload overwrites any union data inside the X402V1PaymentPayload_Payload as the provided X402ExactEvmPayload
func (t *X402V1PaymentPayload_Payload) FromX402ExactEvmPayload(v X402ExactEvmPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX402ExactEvmPayload performs a merge with any union data inside the X402V1PaymentPayload_Payload, using the provided X402ExactEvmPayload
func (t *X402V1PaymentPayload_Payload) MergeX402ExactEvmPayload(v X402ExactEvmPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsX402ExactSolanaPayload returns the union data inside the X402V1PaymentPayload_Payload as a X402ExactSolanaPayload
func (t X402V1PaymentPayload_Payload) AsX402ExactSolanaPayload() (X402ExactSolanaPayload, error) {
	var body X402ExactSolanaPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX402ExactSolanaPayload overwrites any union data inside the X402V1PaymentPayload_Payload as the provided X402ExactSolanaPayload
func (t *X402V1PaymentPayload_Payload) FromX402ExactSolanaPayload(v X402ExactSolanaPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX402ExactSolanaPayload performs a merge with any union data inside the X402V1PaymentPayload_Payload, using the provided X402ExactSolanaPayload
func (t *X402V1PaymentPayload_Payload) MergeX402ExactSolanaPayload(v X402ExactSolanaPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t X402V1PaymentPayload_Payload) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *X402V1PaymentPayload_Payload) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsX402ExactEvmPayload returns the union data inside the X402V2PaymentPayload_Payload as a X402ExactEvmPayload
func (t X402V2PaymentPayload_Payload) AsX402ExactEvmPayload() (X402ExactEvmPayload, error) {
	var body X402ExactEvmPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX402ExactEvmPayload overwrites any union data inside the X402V2PaymentPayload_Payload as the provided X402ExactEvmPayload
func (t *X402V2PaymentPayload_Payload) FromX402ExactEvmPayload(v X402ExactEvmPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX402ExactEvmPayload performs a merge with any union data inside the X402V2PaymentPayload_Payload, using the provided X402ExactEvmPayload
func (t *X402V2PaymentPayload_Payload) MergeX402ExactEvmPayload(v X402ExactEvmPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsX402ExactSolanaPayload returns the union data inside the X402V2PaymentPayload_Payload as a X402ExactSolanaPayload
func (t X402V2PaymentPayload_Payload) AsX402ExactSolanaPayload() (X402ExactSolanaPayload, error) {
	var body X402ExactSolanaPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX402ExactSolanaPayload overwrites any union data inside the X402V2PaymentPayload_Payload as the provided X402ExactSolanaPayload
func (t *X402V2PaymentPayload_Payload) FromX402ExactSolanaPayload(v X402ExactSolanaPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX402ExactSolanaPayload performs a merge with any union data inside the X402V2PaymentPayload_Payload, using the provided X402ExactSolanaPayload
func (t *X402V2PaymentPayload_Payload) MergeX402ExactSolanaPayload(v X402ExactSolanaPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t X402V2PaymentPayload_Payload) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *X402V2PaymentPayload_Payload) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// CDPClient which conforms to the OpenAPI3 specification for this service.
type CDPClient struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*CDPClient) error

// Creates a new CDPClient, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*CDPClient, error) {
	// create a client with sane default values
	client := CDPClient{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *CDPClient) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *CDPClient) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListDataTokenBalances request
	ListDataTokenBalances(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListDataTokenBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTokensForAccount request
	ListTokensForAccount(ctx context.Context, network ListTokensForAccountParamsNetwork, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSQLGrammar request
	GetSQLGrammar(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunSQLQueryWithBody request with any body
	RunSQLQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunSQLQuery(ctx context.Context, body RunSQLQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWebhookSubscriptions request
	ListWebhookSubscriptions(ctx context.Context, params *ListWebhookSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWebhookSubscriptionWithBody request with any body
	CreateWebhookSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWebhookSubscription(ctx context.Context, body CreateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhookSubscription request
	DeleteWebhookSubscription(ctx context.Context, subscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhookSubscription request
	GetWebhookSubscription(ctx context.Context, subscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWebhookSubscriptionWithBody request with any body
	UpdateWebhookSubscriptionWithBody(ctx context.Context, subscriptionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWebhookSubscription(ctx context.Context, subscriptionId openapi_types.UUID, body UpdateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEndUsers request
	ListEndUsers(ctx context.Context, params *ListEndUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEndUserWithBody request with any body
	CreateEndUserWithBody(ctx context.Context, params *CreateEndUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEndUser(ctx context.Context, params *CreateEndUserParams, body CreateEndUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateEndUserAccessTokenWithBody request with any body
	ValidateEndUserAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateEndUserAccessToken(ctx context.Context, body ValidateEndUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportEndUserWithBody request with any body
	ImportEndUserWithBody(ctx context.Context, params *ImportEndUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportEndUser(ctx context.Context, params *ImportEndUserParams, body ImportEndUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEndUser request
	GetEndUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvmAccounts request
	ListEvmAccounts(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEvmAccountWithBody request with any body
	CreateEvmAccountWithBody(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEvmAccount(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmAccountByName request
	GetEvmAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportEvmAccountByNameWithBody request with any body
	ExportEvmAccountByNameWithBody(ctx context.Context, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportEvmAccountByName(ctx context.Context, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportEvmAccountWithBody request with any body
	ImportEvmAccountWithBody(ctx context.Context, params *ImportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportEvmAccount(ctx context.Context, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmAccount request
	GetEvmAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEvmAccountWithBody request with any body
	UpdateEvmAccountWithBody(ctx context.Context, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEvmAccount(ctx context.Context, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportEvmAccountWithBody request with any body
	ExportEvmAccountWithBody(ctx context.Context, address string, params *ExportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportEvmAccount(ctx context.Context, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendEvmTransactionWithBody request with any body
	SendEvmTransactionWithBody(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendEvmTransaction(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmHashWithBody request with any body
	SignEvmHashWithBody(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmHash(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmMessageWithBody request with any body
	SignEvmMessageWithBody(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmMessage(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmTransactionWithBody request with any body
	SignEvmTransactionWithBody(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmTransaction(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmTypedDataWithBody request with any body
	SignEvmTypedDataWithBody(ctx context.Context, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmTypedData(ctx context.Context, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestEvmFaucetWithBody request with any body
	RequestEvmFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestEvmFaucet(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvmSmartAccounts request
	ListEvmSmartAccounts(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEvmSmartAccountWithBody request with any body
	CreateEvmSmartAccountWithBody(ctx context.Context, params *CreateEvmSmartAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEvmSmartAccount(ctx context.Context, params *CreateEvmSmartAccountParams, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmSmartAccountByName request
	GetEvmSmartAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmSmartAccount request
	GetEvmSmartAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEvmSmartAccountWithBody request with any body
	UpdateEvmSmartAccountWithBody(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEvmSmartAccount(ctx context.Context, address string, body UpdateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpendPermissionWithBody request with any body
	CreateSpendPermissionWithBody(ctx context.Context, address string, params *CreateSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpendPermission(ctx context.Context, address string, params *CreateSpendPermissionParams, body CreateSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpendPermissions request
	ListSpendPermissions(ctx context.Context, address string, params *ListSpendPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeSpendPermissionWithBody request with any body
	RevokeSpendPermissionWithBody(ctx context.Context, address string, params *RevokeSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevokeSpendPermission(ctx context.Context, address string, params *RevokeSpendPermissionParams, body RevokeSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareUserOperationWithBody request with any body
	PrepareUserOperationWithBody(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareUserOperation(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareAndSendUserOperationWithBody request with any body
	PrepareAndSendUserOperationWithBody(ctx context.Context, address string, params *PrepareAndSendUserOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareAndSendUserOperation(ctx context.Context, address string, params *PrepareAndSendUserOperationParams, body PrepareAndSendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserOperation request
	GetUserOperation(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendUserOperationWithBody request with any body
	SendUserOperationWithBody(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendUserOperation(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEvmSwapQuoteWithBody request with any body
	CreateEvmSwapQuoteWithBody(ctx context.Context, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEvmSwapQuote(ctx context.Context, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmSwapPrice request
	GetEvmSwapPrice(ctx context.Context, params *GetEvmSwapPriceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvmTokenBalances request
	ListEvmTokenBalances(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOnrampOrderWithBody request with any body
	CreateOnrampOrderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOnrampOrder(ctx context.Context, body CreateOnrampOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOnrampOrderById request
	GetOnrampOrderById(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOnrampSessionWithBody request with any body
	CreateOnrampSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOnrampSession(ctx context.Context, body CreateOnrampSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPolicies request
	ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePolicyWithBody request with any body
	CreatePolicyWithBody(ctx context.Context, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePolicy(ctx context.Context, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePolicy request
	DeletePolicy(ctx context.Context, policyId string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicyById request
	GetPolicyById(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicyWithBody request with any body
	UpdatePolicyWithBody(ctx context.Context, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicy(ctx context.Context, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSolanaAccounts request
	ListSolanaAccounts(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSolanaAccountWithBody request with any body
	CreateSolanaAccountWithBody(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSolanaAccount(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSolanaAccountByName request
	GetSolanaAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportSolanaAccountByNameWithBody request with any body
	ExportSolanaAccountByNameWithBody(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportSolanaAccountByName(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportSolanaAccountWithBody request with any body
	ImportSolanaAccountWithBody(ctx context.Context, params *ImportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportSolanaAccount(ctx context.Context, params *ImportSolanaAccountParams, body ImportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendSolanaTransactionWithBody request with any body
	SendSolanaTransactionWithBody(ctx context.Context, params *SendSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendSolanaTransaction(ctx context.Context, params *SendSolanaTransactionParams, body SendSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSolanaAccount request
	GetSolanaAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSolanaAccountWithBody request with any body
	UpdateSolanaAccountWithBody(ctx context.Context, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSolanaAccount(ctx context.Context, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportSolanaAccountWithBody request with any body
	ExportSolanaAccountWithBody(ctx context.Context, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportSolanaAccount(ctx context.Context, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignSolanaMessageWithBody request with any body
	SignSolanaMessageWithBody(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignSolanaMessage(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignSolanaTransactionWithBody request with any body
	SignSolanaTransactionWithBody(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignSolanaTransaction(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestSolanaFaucetWithBody request with any body
	RequestSolanaFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestSolanaFaucet(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSolanaTokenBalances request
	ListSolanaTokenBalances(ctx context.Context, network ListSolanaTokenBalancesNetwork, address string, params *ListSolanaTokenBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SettleX402PaymentWithBody request with any body
	SettleX402PaymentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SettleX402Payment(ctx context.Context, body SettleX402PaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SupportedX402PaymentKinds request
	SupportedX402PaymentKinds(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyX402PaymentWithBody request with any body
	VerifyX402PaymentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VerifyX402Payment(ctx context.Context, body VerifyX402PaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *CDPClient) ListDataTokenBalances(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListDataTokenBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDataTokenBalancesRequest(c.Server, network, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListTokensForAccount(ctx context.Context, network ListTokensForAccountParamsNetwork, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTokensForAccountRequest(c.Server, network, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetSQLGrammar(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSQLGrammarRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RunSQLQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunSQLQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RunSQLQuery(ctx context.Context, body RunSQLQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunSQLQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListWebhookSubscriptions(ctx context.Context, params *ListWebhookSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebhookSubscriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateWebhookSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookSubscriptionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateWebhookSubscription(ctx context.Context, body CreateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookSubscriptionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) DeleteWebhookSubscription(ctx context.Context, subscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookSubscriptionRequest(c.Server, subscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetWebhookSubscription(ctx context.Context, subscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookSubscriptionRequest(c.Server, subscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateWebhookSubscriptionWithBody(ctx context.Context, subscriptionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookSubscriptionRequestWithBody(c.Server, subscriptionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateWebhookSubscription(ctx context.Context, subscriptionId openapi_types.UUID, body UpdateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookSubscriptionRequest(c.Server, subscriptionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListEndUsers(ctx context.Context, params *ListEndUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEndUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEndUserWithBody(ctx context.Context, params *CreateEndUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEndUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEndUser(ctx context.Context, params *CreateEndUserParams, body CreateEndUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEndUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ValidateEndUserAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateEndUserAccessTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ValidateEndUserAccessToken(ctx context.Context, body ValidateEndUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateEndUserAccessTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ImportEndUserWithBody(ctx context.Context, params *ImportEndUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportEndUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ImportEndUser(ctx context.Context, params *ImportEndUserParams, body ImportEndUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportEndUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEndUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEndUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListEvmAccounts(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEvmAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmAccountWithBody(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmAccount(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmAccountByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportEvmAccountByNameWithBody(ctx context.Context, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportEvmAccountByNameRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportEvmAccountByName(ctx context.Context, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportEvmAccountByNameRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ImportEvmAccountWithBody(ctx context.Context, params *ImportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportEvmAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ImportEvmAccount(ctx context.Context, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportEvmAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmAccountRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateEvmAccountWithBody(ctx context.Context, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEvmAccountRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateEvmAccount(ctx context.Context, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEvmAccountRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportEvmAccountWithBody(ctx context.Context, address string, params *ExportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportEvmAccountRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportEvmAccount(ctx context.Context, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportEvmAccountRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendEvmTransactionWithBody(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendEvmTransactionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendEvmTransaction(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendEvmTransactionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmHashWithBody(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmHashRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmHash(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmHashRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmMessageWithBody(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmMessageRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmMessage(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmMessageRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmTransactionWithBody(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmTransactionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmTransaction(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmTransactionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmTypedDataWithBody(ctx context.Context, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmTypedDataRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmTypedData(ctx context.Context, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmTypedDataRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestEvmFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestEvmFaucetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestEvmFaucet(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestEvmFaucetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListEvmSmartAccounts(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEvmSmartAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmSmartAccountWithBody(ctx context.Context, params *CreateEvmSmartAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmSmartAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmSmartAccount(ctx context.Context, params *CreateEvmSmartAccountParams, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmSmartAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmSmartAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmSmartAccountByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmSmartAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmSmartAccountRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateEvmSmartAccountWithBody(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEvmSmartAccountRequestWithBody(c.Server, address, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateEvmSmartAccount(ctx context.Context, address string, body UpdateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEvmSmartAccountRequest(c.Server, address, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateSpendPermissionWithBody(ctx context.Context, address string, params *CreateSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpendPermissionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateSpendPermission(ctx context.Context, address string, params *CreateSpendPermissionParams, body CreateSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpendPermissionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListSpendPermissions(ctx context.Context, address string, params *ListSpendPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpendPermissionsRequest(c.Server, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RevokeSpendPermissionWithBody(ctx context.Context, address string, params *RevokeSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeSpendPermissionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RevokeSpendPermission(ctx context.Context, address string, params *RevokeSpendPermissionParams, body RevokeSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeSpendPermissionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) PrepareUserOperationWithBody(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareUserOperationRequestWithBody(c.Server, address, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) PrepareUserOperation(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareUserOperationRequest(c.Server, address, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) PrepareAndSendUserOperationWithBody(ctx context.Context, address string, params *PrepareAndSendUserOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareAndSendUserOperationRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) PrepareAndSendUserOperation(ctx context.Context, address string, params *PrepareAndSendUserOperationParams, body PrepareAndSendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareAndSendUserOperationRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetUserOperation(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserOperationRequest(c.Server, address, userOpHash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendUserOperationWithBody(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendUserOperationRequestWithBody(c.Server, address, userOpHash, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendUserOperation(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendUserOperationRequest(c.Server, address, userOpHash, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmSwapQuoteWithBody(ctx context.Context, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmSwapQuoteRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmSwapQuote(ctx context.Context, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmSwapQuoteRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmSwapPrice(ctx context.Context, params *GetEvmSwapPriceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmSwapPriceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListEvmTokenBalances(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEvmTokenBalancesRequest(c.Server, network, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateOnrampOrderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOnrampOrderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateOnrampOrder(ctx context.Context, body CreateOnrampOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOnrampOrderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetOnrampOrderById(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOnrampOrderByIdRequest(c.Server, orderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateOnrampSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOnrampSessionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateOnrampSession(ctx context.Context, body CreateOnrampSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOnrampSessionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreatePolicyWithBody(ctx context.Context, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreatePolicy(ctx context.Context, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) DeletePolicy(ctx context.Context, policyId string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePolicyRequest(c.Server, policyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetPolicyById(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyByIdRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdatePolicyWithBody(ctx context.Context, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequestWithBody(c.Server, policyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdatePolicy(ctx context.Context, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequest(c.Server, policyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListSolanaAccounts(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSolanaAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateSolanaAccountWithBody(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSolanaAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateSolanaAccount(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSolanaAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetSolanaAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSolanaAccountByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportSolanaAccountByNameWithBody(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSolanaAccountByNameRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportSolanaAccountByName(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSolanaAccountByNameRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ImportSolanaAccountWithBody(ctx context.Context, params *ImportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportSolanaAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ImportSolanaAccount(ctx context.Context, params *ImportSolanaAccountParams, body ImportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportSolanaAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendSolanaTransactionWithBody(ctx context.Context, params *SendSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendSolanaTransactionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendSolanaTransaction(ctx context.Context, params *SendSolanaTransactionParams, body SendSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendSolanaTransactionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetSolanaAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSolanaAccountRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateSolanaAccountWithBody(ctx context.Context, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSolanaAccountRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateSolanaAccount(ctx context.Context, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSolanaAccountRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportSolanaAccountWithBody(ctx context.Context, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSolanaAccountRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportSolanaAccount(ctx context.Context, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSolanaAccountRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaMessageWithBody(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaMessageRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaMessage(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaMessageRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaTransactionWithBody(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaTransactionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaTransaction(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaTransactionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestSolanaFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestSolanaFaucetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestSolanaFaucet(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestSolanaFaucetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListSolanaTokenBalances(ctx context.Context, network ListSolanaTokenBalancesNetwork, address string, params *ListSolanaTokenBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSolanaTokenBalancesRequest(c.Server, network, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SettleX402PaymentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSettleX402PaymentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SettleX402Payment(ctx context.Context, body SettleX402PaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSettleX402PaymentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SupportedX402PaymentKinds(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSupportedX402PaymentKindsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) VerifyX402PaymentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyX402PaymentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) VerifyX402Payment(ctx context.Context, body VerifyX402PaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyX402PaymentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListDataTokenBalancesRequest generates requests for ListDataTokenBalances
func NewListDataTokenBalancesRequest(server string, network ListEvmTokenBalancesNetwork, address string, params *ListDataTokenBalancesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network", runtime.ParamLocationPath, network)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/data/evm/token-balances/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTokensForAccountRequest generates requests for ListTokensForAccount
func NewListTokensForAccountRequest(server string, network ListTokensForAccountParamsNetwork, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network", runtime.ParamLocationPath, network)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/data/evm/token-ownership/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSQLGrammarRequest generates requests for GetSQLGrammar
func NewGetSQLGrammarRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/data/query/grammar")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunSQLQueryRequest calls the generic RunSQLQuery builder with application/json body
func NewRunSQLQueryRequest(server string, body RunSQLQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunSQLQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewRunSQLQueryRequestWithBody generates requests for RunSQLQuery with any type of body
func NewRunSQLQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/data/query/run")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWebhookSubscriptionsRequest generates requests for ListWebhookSubscriptions
func NewListWebhookSubscriptionsRequest(server string, params *ListWebhookSubscriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/data/webhooks/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWebhookSubscriptionRequest calls the generic CreateWebhookSubscription builder with application/json body
func NewCreateWebhookSubscriptionRequest(server string, body CreateWebhookSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWebhookSubscriptionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWebhookSubscriptionRequestWithBody generates requests for CreateWebhookSubscription with any type of body
func NewCreateWebhookSubscriptionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/data/webhooks/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWebhookSubscriptionRequest generates requests for DeleteWebhookSubscription
func NewDeleteWebhookSubscriptionRequest(server string, subscriptionId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/data/webhooks/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhookSubscriptionRequest generates requests for GetWebhookSubscription
func NewGetWebhookSubscriptionRequest(server string, subscriptionId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/data/webhooks/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWebhookSubscriptionRequest calls the generic UpdateWebhookSubscription builder with application/json body
func NewUpdateWebhookSubscriptionRequest(server string, subscriptionId openapi_types.UUID, body UpdateWebhookSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWebhookSubscriptionRequestWithBody(server, subscriptionId, "application/json", bodyReader)
}

// NewUpdateWebhookSubscriptionRequestWithBody generates requests for UpdateWebhookSubscription with any type of body
func NewUpdateWebhookSubscriptionRequestWithBody(server string, subscriptionId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/data/webhooks/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEndUsersRequest generates requests for ListEndUsers
func NewListEndUsersRequest(server string, params *ListEndUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/end-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEndUserRequest calls the generic CreateEndUser builder with application/json body
func NewCreateEndUserRequest(server string, params *CreateEndUserParams, body CreateEndUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEndUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEndUserRequestWithBody generates requests for CreateEndUser with any type of body
func NewCreateEndUserRequestWithBody(server string, params *CreateEndUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/end-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewValidateEndUserAccessTokenRequest calls the generic ValidateEndUserAccessToken builder with application/json body
func NewValidateEndUserAccessTokenRequest(server string, body ValidateEndUserAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateEndUserAccessTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateEndUserAccessTokenRequestWithBody generates requests for ValidateEndUserAccessToken with any type of body
func NewValidateEndUserAccessTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/end-users/auth/validate-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewImportEndUserRequest calls the generic ImportEndUser builder with application/json body
func NewImportEndUserRequest(server string, params *ImportEndUserParams, body ImportEndUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportEndUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewImportEndUserRequestWithBody generates requests for ImportEndUser with any type of body
func NewImportEndUserRequestWithBody(server string, params *ImportEndUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/end-users/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetEndUserRequest generates requests for GetEndUser
func NewGetEndUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/end-users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEvmAccountsRequest generates requests for ListEvmAccounts
func NewListEvmAccountsRequest(server string, params *ListEvmAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEvmAccountRequest calls the generic CreateEvmAccount builder with application/json body
func NewCreateEvmAccountRequest(server string, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEvmAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEvmAccountRequestWithBody generates requests for CreateEvmAccount with any type of body
func NewCreateEvmAccountRequestWithBody(server string, params *CreateEvmAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetEvmAccountByNameRequest generates requests for GetEvmAccountByName
func NewGetEvmAccountByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportEvmAccountByNameRequest calls the generic ExportEvmAccountByName builder with application/json body
func NewExportEvmAccountByNameRequest(server string, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportEvmAccountByNameRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewExportEvmAccountByNameRequestWithBody generates requests for ExportEvmAccountByName with any type of body
func NewExportEvmAccountByNameRequestWithBody(server string, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/export/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewImportEvmAccountRequest calls the generic ImportEvmAccount builder with application/json body
func NewImportEvmAccountRequest(server string, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportEvmAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewImportEvmAccountRequestWithBody generates requests for ImportEvmAccount with any type of body
func NewImportEvmAccountRequestWithBody(server string, params *ImportEvmAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetEvmAccountRequest generates requests for GetEvmAccount
func NewGetEvmAccountRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEvmAccountRequest calls the generic UpdateEvmAccount builder with application/json body
func NewUpdateEvmAccountRequest(server string, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEvmAccountRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewUpdateEvmAccountRequestWithBody generates requests for UpdateEvmAccount with any type of body
func NewUpdateEvmAccountRequestWithBody(server string, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewExportEvmAccountRequest calls the generic ExportEvmAccount builder with application/json body
func NewExportEvmAccountRequest(server string, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportEvmAccountRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewExportEvmAccountRequestWithBody generates requests for ExportEvmAccount with any type of body
func NewExportEvmAccountRequestWithBody(server string, address string, params *ExportEvmAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/export", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSendEvmTransactionRequest calls the generic SendEvmTransaction builder with application/json body
func NewSendEvmTransactionRequest(server string, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendEvmTransactionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSendEvmTransactionRequestWithBody generates requests for SendEvmTransaction with any type of body
func NewSendEvmTransactionRequestWithBody(server string, address string, params *SendEvmTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/send/transaction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmHashRequest calls the generic SignEvmHash builder with application/json body
func NewSignEvmHashRequest(server string, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmHashRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmHashRequestWithBody generates requests for SignEvmHash with any type of body
func NewSignEvmHashRequestWithBody(server string, address string, params *SignEvmHashParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmMessageRequest calls the generic SignEvmMessage builder with application/json body
func NewSignEvmMessageRequest(server string, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmMessageRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmMessageRequestWithBody generates requests for SignEvmMessage with any type of body
func NewSignEvmMessageRequestWithBody(server string, address string, params *SignEvmMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign/message", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmTransactionRequest calls the generic SignEvmTransaction builder with application/json body
func NewSignEvmTransactionRequest(server string, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmTransactionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmTransactionRequestWithBody generates requests for SignEvmTransaction with any type of body
func NewSignEvmTransactionRequestWithBody(server string, address string, params *SignEvmTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign/transaction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmTypedDataRequest calls the generic SignEvmTypedData builder with application/json body
func NewSignEvmTypedDataRequest(server string, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmTypedDataRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmTypedDataRequestWithBody generates requests for SignEvmTypedData with any type of body
func NewSignEvmTypedDataRequestWithBody(server string, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign/typed-data", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewRequestEvmFaucetRequest calls the generic RequestEvmFaucet builder with application/json body
func NewRequestEvmFaucetRequest(server string, body RequestEvmFaucetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestEvmFaucetRequestWithBody(server, "application/json", bodyReader)
}

// NewRequestEvmFaucetRequestWithBody generates requests for RequestEvmFaucet with any type of body
func NewRequestEvmFaucetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/faucet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEvmSmartAccountsRequest generates requests for ListEvmSmartAccounts
func NewListEvmSmartAccountsRequest(server string, params *ListEvmSmartAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEvmSmartAccountRequest calls the generic CreateEvmSmartAccount builder with application/json body
func NewCreateEvmSmartAccountRequest(server string, params *CreateEvmSmartAccountParams, body CreateEvmSmartAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEvmSmartAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEvmSmartAccountRequestWithBody generates requests for CreateEvmSmartAccount with any type of body
func NewCreateEvmSmartAccountRequestWithBody(server string, params *CreateEvmSmartAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewGetEvmSmartAccountByNameRequest generates requests for GetEvmSmartAccountByName
func NewGetEvmSmartAccountByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEvmSmartAccountRequest generates requests for GetEvmSmartAccount
func NewGetEvmSmartAccountRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEvmSmartAccountRequest calls the generic UpdateEvmSmartAccount builder with application/json body
func NewUpdateEvmSmartAccountRequest(server string, address string, body UpdateEvmSmartAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEvmSmartAccountRequestWithBody(server, address, "application/json", bodyReader)
}

// NewUpdateEvmSmartAccountRequestWithBody generates requests for UpdateEvmSmartAccount with any type of body
func NewUpdateEvmSmartAccountRequestWithBody(server string, address string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSpendPermissionRequest calls the generic CreateSpendPermission builder with application/json body
func NewCreateSpendPermissionRequest(server string, address string, params *CreateSpendPermissionParams, body CreateSpendPermissionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpendPermissionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewCreateSpendPermissionRequestWithBody generates requests for CreateSpendPermission with any type of body
func NewCreateSpendPermissionRequestWithBody(server string, address string, params *CreateSpendPermissionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/spend-permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewListSpendPermissionsRequest generates requests for ListSpendPermissions
func NewListSpendPermissionsRequest(server string, address string, params *ListSpendPermissionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/spend-permissions/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokeSpendPermissionRequest calls the generic RevokeSpendPermission builder with application/json body
func NewRevokeSpendPermissionRequest(server string, address string, params *RevokeSpendPermissionParams, body RevokeSpendPermissionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevokeSpendPermissionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewRevokeSpendPermissionRequestWithBody generates requests for RevokeSpendPermission with any type of body
func NewRevokeSpendPermissionRequestWithBody(server string, address string, params *RevokeSpendPermissionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/spend-permissions/revoke", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewPrepareUserOperationRequest calls the generic PrepareUserOperation builder with application/json body
func NewPrepareUserOperationRequest(server string, address string, body PrepareUserOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareUserOperationRequestWithBody(server, address, "application/json", bodyReader)
}

// NewPrepareUserOperationRequestWithBody generates requests for PrepareUserOperation with any type of body
func NewPrepareUserOperationRequestWithBody(server string, address string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/user-operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPrepareAndSendUserOperationRequest calls the generic PrepareAndSendUserOperation builder with application/json body
func NewPrepareAndSendUserOperationRequest(server string, address string, params *PrepareAndSendUserOperationParams, body PrepareAndSendUserOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareAndSendUserOperationRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewPrepareAndSendUserOperationRequestWithBody generates requests for PrepareAndSendUserOperation with any type of body
func NewPrepareAndSendUserOperationRequestWithBody(server string, address string, params *PrepareAndSendUserOperationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/user-operations/prepare-and-send", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

		if params.XWalletAuth != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam1)
		}

	}

	return req, nil
}

// NewGetUserOperationRequest generates requests for GetUserOperation
func NewGetUserOperationRequest(server string, address string, userOpHash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userOpHash", runtime.ParamLocationPath, userOpHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/user-operations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendUserOperationRequest calls the generic SendUserOperation builder with application/json body
func NewSendUserOperationRequest(server string, address string, userOpHash string, body SendUserOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendUserOperationRequestWithBody(server, address, userOpHash, "application/json", bodyReader)
}

// NewSendUserOperationRequestWithBody generates requests for SendUserOperation with any type of body
func NewSendUserOperationRequestWithBody(server string, address string, userOpHash string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userOpHash", runtime.ParamLocationPath, userOpHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/user-operations/%s/send", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateEvmSwapQuoteRequest calls the generic CreateEvmSwapQuote builder with application/json body
func NewCreateEvmSwapQuoteRequest(server string, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEvmSwapQuoteRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEvmSwapQuoteRequestWithBody generates requests for CreateEvmSwapQuote with any type of body
func NewCreateEvmSwapQuoteRequestWithBody(server string, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/swaps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewGetEvmSwapPriceRequest generates requests for GetEvmSwapPrice
func NewGetEvmSwapPriceRequest(server string, params *GetEvmSwapPriceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/swaps/quote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "network", runtime.ParamLocationQuery, params.Network); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toToken", runtime.ParamLocationQuery, params.ToToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromToken", runtime.ParamLocationQuery, params.FromToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromAmount", runtime.ParamLocationQuery, params.FromAmount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taker", runtime.ParamLocationQuery, params.Taker); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SignerAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signerAddress", runtime.ParamLocationQuery, *params.SignerAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GasPrice != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gasPrice", runtime.ParamLocationQuery, *params.GasPrice); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SlippageBps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slippageBps", runtime.ParamLocationQuery, *params.SlippageBps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEvmTokenBalancesRequest generates requests for ListEvmTokenBalances
func NewListEvmTokenBalancesRequest(server string, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network", runtime.ParamLocationPath, network)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/token-balances/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOnrampOrderRequest calls the generic CreateOnrampOrder builder with application/json body
func NewCreateOnrampOrderRequest(server string, body CreateOnrampOrderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOnrampOrderRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOnrampOrderRequestWithBody generates requests for CreateOnrampOrder with any type of body
func NewCreateOnrampOrderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/onramp/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOnrampOrderByIdRequest generates requests for GetOnrampOrderById
func NewGetOnrampOrderByIdRequest(server string, orderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/onramp/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOnrampSessionRequest calls the generic CreateOnrampSession builder with application/json body
func NewCreateOnrampSessionRequest(server string, body CreateOnrampSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOnrampSessionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOnrampSessionRequestWithBody generates requests for CreateOnrampSession with any type of body
func NewCreateOnrampSessionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/onramp/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPoliciesRequest generates requests for ListPolicies
func NewListPoliciesRequest(server string, params *ListPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePolicyRequest calls the generic CreatePolicy builder with application/json body
func NewCreatePolicyRequest(server string, params *CreatePolicyParams, body CreatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePolicyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePolicyRequestWithBody generates requests for CreatePolicy with any type of body
func NewCreatePolicyRequestWithBody(server string, params *CreatePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewDeletePolicyRequest generates requests for DeletePolicy
func NewDeletePolicyRequest(server string, policyId string, params *DeletePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewGetPolicyByIdRequest generates requests for GetPolicyById
func NewGetPolicyByIdRequest(server string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePolicyRequest calls the generic UpdatePolicy builder with application/json body
func NewUpdatePolicyRequest(server string, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyRequestWithBody(server, policyId, params, "application/json", bodyReader)
}

// NewUpdatePolicyRequestWithBody generates requests for UpdatePolicy with any type of body
func NewUpdatePolicyRequestWithBody(server string, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewListSolanaAccountsRequest generates requests for ListSolanaAccounts
func NewListSolanaAccountsRequest(server string, params *ListSolanaAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSolanaAccountRequest calls the generic CreateSolanaAccount builder with application/json body
func NewCreateSolanaAccountRequest(server string, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSolanaAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSolanaAccountRequestWithBody generates requests for CreateSolanaAccount with any type of body
func NewCreateSolanaAccountRequestWithBody(server string, params *CreateSolanaAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetSolanaAccountByNameRequest generates requests for GetSolanaAccountByName
func NewGetSolanaAccountByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportSolanaAccountByNameRequest calls the generic ExportSolanaAccountByName builder with application/json body
func NewExportSolanaAccountByNameRequest(server string, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportSolanaAccountByNameRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewExportSolanaAccountByNameRequestWithBody generates requests for ExportSolanaAccountByName with any type of body
func NewExportSolanaAccountByNameRequestWithBody(server string, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/export/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewImportSolanaAccountRequest calls the generic ImportSolanaAccount builder with application/json body
func NewImportSolanaAccountRequest(server string, params *ImportSolanaAccountParams, body ImportSolanaAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportSolanaAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewImportSolanaAccountRequestWithBody generates requests for ImportSolanaAccount with any type of body
func NewImportSolanaAccountRequestWithBody(server string, params *ImportSolanaAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSendSolanaTransactionRequest calls the generic SendSolanaTransaction builder with application/json body
func NewSendSolanaTransactionRequest(server string, params *SendSolanaTransactionParams, body SendSolanaTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendSolanaTransactionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSendSolanaTransactionRequestWithBody generates requests for SendSolanaTransaction with any type of body
func NewSendSolanaTransactionRequestWithBody(server string, params *SendSolanaTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/send/transaction")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetSolanaAccountRequest generates requests for GetSolanaAccount
func NewGetSolanaAccountRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSolanaAccountRequest calls the generic UpdateSolanaAccount builder with application/json body
func NewUpdateSolanaAccountRequest(server string, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSolanaAccountRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewUpdateSolanaAccountRequestWithBody generates requests for UpdateSolanaAccount with any type of body
func NewUpdateSolanaAccountRequestWithBody(server string, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewExportSolanaAccountRequest calls the generic ExportSolanaAccount builder with application/json body
func NewExportSolanaAccountRequest(server string, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportSolanaAccountRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewExportSolanaAccountRequestWithBody generates requests for ExportSolanaAccount with any type of body
func NewExportSolanaAccountRequestWithBody(server string, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s/export", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignSolanaMessageRequest calls the generic SignSolanaMessage builder with application/json body
func NewSignSolanaMessageRequest(server string, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignSolanaMessageRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignSolanaMessageRequestWithBody generates requests for SignSolanaMessage with any type of body
func NewSignSolanaMessageRequestWithBody(server string, address string, params *SignSolanaMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s/sign/message", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignSolanaTransactionRequest calls the generic SignSolanaTransaction builder with application/json body
func NewSignSolanaTransactionRequest(server string, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignSolanaTransactionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignSolanaTransactionRequestWithBody generates requests for SignSolanaTransaction with any type of body
func NewSignSolanaTransactionRequestWithBody(server string, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s/sign/transaction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewRequestSolanaFaucetRequest calls the generic RequestSolanaFaucet builder with application/json body
func NewRequestSolanaFaucetRequest(server string, body RequestSolanaFaucetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestSolanaFaucetRequestWithBody(server, "application/json", bodyReader)
}

// NewRequestSolanaFaucetRequestWithBody generates requests for RequestSolanaFaucet with any type of body
func NewRequestSolanaFaucetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/faucet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSolanaTokenBalancesRequest generates requests for ListSolanaTokenBalances
func NewListSolanaTokenBalancesRequest(server string, network ListSolanaTokenBalancesNetwork, address string, params *ListSolanaTokenBalancesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network", runtime.ParamLocationPath, network)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/token-balances/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSettleX402PaymentRequest calls the generic SettleX402Payment builder with application/json body
func NewSettleX402PaymentRequest(server string, body SettleX402PaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSettleX402PaymentRequestWithBody(server, "application/json", bodyReader)
}

// NewSettleX402PaymentRequestWithBody generates requests for SettleX402Payment with any type of body
func NewSettleX402PaymentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/x402/settle")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSupportedX402PaymentKindsRequest generates requests for SupportedX402PaymentKinds
func NewSupportedX402PaymentKindsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/x402/supported")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerifyX402PaymentRequest calls the generic VerifyX402Payment builder with application/json body
func NewVerifyX402PaymentRequest(server string, body VerifyX402PaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVerifyX402PaymentRequestWithBody(server, "application/json", bodyReader)
}

// NewVerifyX402PaymentRequestWithBody generates requests for VerifyX402Payment with any type of body
func NewVerifyX402PaymentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/x402/verify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *CDPClient) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *CDPClient) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListDataTokenBalancesWithResponse request
	ListDataTokenBalancesWithResponse(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListDataTokenBalancesParams, reqEditors ...RequestEditorFn) (*ListDataTokenBalancesResponse, error)

	// ListTokensForAccountWithResponse request
	ListTokensForAccountWithResponse(ctx context.Context, network ListTokensForAccountParamsNetwork, address string, reqEditors ...RequestEditorFn) (*ListTokensForAccountResponse, error)

	// GetSQLGrammarWithResponse request
	GetSQLGrammarWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSQLGrammarResponse, error)

	// RunSQLQueryWithBodyWithResponse request with any body
	RunSQLQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunSQLQueryResponse, error)

	RunSQLQueryWithResponse(ctx context.Context, body RunSQLQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*RunSQLQueryResponse, error)

	// ListWebhookSubscriptionsWithResponse request
	ListWebhookSubscriptionsWithResponse(ctx context.Context, params *ListWebhookSubscriptionsParams, reqEditors ...RequestEditorFn) (*ListWebhookSubscriptionsResponse, error)

	// CreateWebhookSubscriptionWithBodyWithResponse request with any body
	CreateWebhookSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookSubscriptionResponse, error)

	CreateWebhookSubscriptionWithResponse(ctx context.Context, body CreateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookSubscriptionResponse, error)

	// DeleteWebhookSubscriptionWithResponse request
	DeleteWebhookSubscriptionWithResponse(ctx context.Context, subscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteWebhookSubscriptionResponse, error)

	// GetWebhookSubscriptionWithResponse request
	GetWebhookSubscriptionWithResponse(ctx context.Context, subscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetWebhookSubscriptionResponse, error)

	// UpdateWebhookSubscriptionWithBodyWithResponse request with any body
	UpdateWebhookSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookSubscriptionResponse, error)

	UpdateWebhookSubscriptionWithResponse(ctx context.Context, subscriptionId openapi_types.UUID, body UpdateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookSubscriptionResponse, error)

	// ListEndUsersWithResponse request
	ListEndUsersWithResponse(ctx context.Context, params *ListEndUsersParams, reqEditors ...RequestEditorFn) (*ListEndUsersResponse, error)

	// CreateEndUserWithBodyWithResponse request with any body
	CreateEndUserWithBodyWithResponse(ctx context.Context, params *CreateEndUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEndUserResponse, error)

	CreateEndUserWithResponse(ctx context.Context, params *CreateEndUserParams, body CreateEndUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEndUserResponse, error)

	// ValidateEndUserAccessTokenWithBodyWithResponse request with any body
	ValidateEndUserAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateEndUserAccessTokenResponse, error)

	ValidateEndUserAccessTokenWithResponse(ctx context.Context, body ValidateEndUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateEndUserAccessTokenResponse, error)

	// ImportEndUserWithBodyWithResponse request with any body
	ImportEndUserWithBodyWithResponse(ctx context.Context, params *ImportEndUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportEndUserResponse, error)

	ImportEndUserWithResponse(ctx context.Context, params *ImportEndUserParams, body ImportEndUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportEndUserResponse, error)

	// GetEndUserWithResponse request
	GetEndUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetEndUserResponse, error)

	// ListEvmAccountsWithResponse request
	ListEvmAccountsWithResponse(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmAccountsResponse, error)

	// CreateEvmAccountWithBodyWithResponse request with any body
	CreateEvmAccountWithBodyWithResponse(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error)

	CreateEvmAccountWithResponse(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error)

	// GetEvmAccountByNameWithResponse request
	GetEvmAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetEvmAccountByNameResponse, error)

	// ExportEvmAccountByNameWithBodyWithResponse request with any body
	ExportEvmAccountByNameWithBodyWithResponse(ctx context.Context, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportEvmAccountByNameResponse, error)

	ExportEvmAccountByNameWithResponse(ctx context.Context, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportEvmAccountByNameResponse, error)

	// ImportEvmAccountWithBodyWithResponse request with any body
	ImportEvmAccountWithBodyWithResponse(ctx context.Context, params *ImportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportEvmAccountResponse, error)

	ImportEvmAccountWithResponse(ctx context.Context, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportEvmAccountResponse, error)

	// GetEvmAccountWithResponse request
	GetEvmAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmAccountResponse, error)

	// UpdateEvmAccountWithBodyWithResponse request with any body
	UpdateEvmAccountWithBodyWithResponse(ctx context.Context, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEvmAccountResponse, error)

	UpdateEvmAccountWithResponse(ctx context.Context, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEvmAccountResponse, error)

	// ExportEvmAccountWithBodyWithResponse request with any body
	ExportEvmAccountWithBodyWithResponse(ctx context.Context, address string, params *ExportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportEvmAccountResponse, error)

	ExportEvmAccountWithResponse(ctx context.Context, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportEvmAccountResponse, error)

	// SendEvmTransactionWithBodyWithResponse request with any body
	SendEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error)

	SendEvmTransactionWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error)

	// SignEvmHashWithBodyWithResponse request with any body
	SignEvmHashWithBodyWithResponse(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error)

	SignEvmHashWithResponse(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error)

	// SignEvmMessageWithBodyWithResponse request with any body
	SignEvmMessageWithBodyWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error)

	SignEvmMessageWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error)

	// SignEvmTransactionWithBodyWithResponse request with any body
	SignEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error)

	SignEvmTransactionWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error)

	// SignEvmTypedDataWithBodyWithResponse request with any body
	SignEvmTypedDataWithBodyWithResponse(ctx context.Context, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmTypedDataResponse, error)

	SignEvmTypedDataWithResponse(ctx context.Context, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmTypedDataResponse, error)

	// RequestEvmFaucetWithBodyWithResponse request with any body
	RequestEvmFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error)

	RequestEvmFaucetWithResponse(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error)

	// ListEvmSmartAccountsWithResponse request
	ListEvmSmartAccountsWithResponse(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmSmartAccountsResponse, error)

	// CreateEvmSmartAccountWithBodyWithResponse request with any body
	CreateEvmSmartAccountWithBodyWithResponse(ctx context.Context, params *CreateEvmSmartAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error)

	CreateEvmSmartAccountWithResponse(ctx context.Context, params *CreateEvmSmartAccountParams, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error)

	// GetEvmSmartAccountByNameWithResponse request
	GetEvmSmartAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetEvmSmartAccountByNameResponse, error)

	// GetEvmSmartAccountWithResponse request
	GetEvmSmartAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmSmartAccountResponse, error)

	// UpdateEvmSmartAccountWithBodyWithResponse request with any body
	UpdateEvmSmartAccountWithBodyWithResponse(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEvmSmartAccountResponse, error)

	UpdateEvmSmartAccountWithResponse(ctx context.Context, address string, body UpdateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEvmSmartAccountResponse, error)

	// CreateSpendPermissionWithBodyWithResponse request with any body
	CreateSpendPermissionWithBodyWithResponse(ctx context.Context, address string, params *CreateSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpendPermissionResponse, error)

	CreateSpendPermissionWithResponse(ctx context.Context, address string, params *CreateSpendPermissionParams, body CreateSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpendPermissionResponse, error)

	// ListSpendPermissionsWithResponse request
	ListSpendPermissionsWithResponse(ctx context.Context, address string, params *ListSpendPermissionsParams, reqEditors ...RequestEditorFn) (*ListSpendPermissionsResponse, error)

	// RevokeSpendPermissionWithBodyWithResponse request with any body
	RevokeSpendPermissionWithBodyWithResponse(ctx context.Context, address string, params *RevokeSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeSpendPermissionResponse, error)

	RevokeSpendPermissionWithResponse(ctx context.Context, address string, params *RevokeSpendPermissionParams, body RevokeSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeSpendPermissionResponse, error)

	// PrepareUserOperationWithBodyWithResponse request with any body
	PrepareUserOperationWithBodyWithResponse(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error)

	PrepareUserOperationWithResponse(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error)

	// PrepareAndSendUserOperationWithBodyWithResponse request with any body
	PrepareAndSendUserOperationWithBodyWithResponse(ctx context.Context, address string, params *PrepareAndSendUserOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareAndSendUserOperationResponse, error)

	PrepareAndSendUserOperationWithResponse(ctx context.Context, address string, params *PrepareAndSendUserOperationParams, body PrepareAndSendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareAndSendUserOperationResponse, error)

	// GetUserOperationWithResponse request
	GetUserOperationWithResponse(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*GetUserOperationResponse, error)

	// SendUserOperationWithBodyWithResponse request with any body
	SendUserOperationWithBodyWithResponse(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error)

	SendUserOperationWithResponse(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error)

	// CreateEvmSwapQuoteWithBodyWithResponse request with any body
	CreateEvmSwapQuoteWithBodyWithResponse(ctx context.Context, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmSwapQuoteResponse, error)

	CreateEvmSwapQuoteWithResponse(ctx context.Context, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmSwapQuoteResponse, error)

	// GetEvmSwapPriceWithResponse request
	GetEvmSwapPriceWithResponse(ctx context.Context, params *GetEvmSwapPriceParams, reqEditors ...RequestEditorFn) (*GetEvmSwapPriceResponse, error)

	// ListEvmTokenBalancesWithResponse request
	ListEvmTokenBalancesWithResponse(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*ListEvmTokenBalancesResponse, error)

	// CreateOnrampOrderWithBodyWithResponse request with any body
	CreateOnrampOrderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOnrampOrderResponse, error)

	CreateOnrampOrderWithResponse(ctx context.Context, body CreateOnrampOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOnrampOrderResponse, error)

	// GetOnrampOrderByIdWithResponse request
	GetOnrampOrderByIdWithResponse(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*GetOnrampOrderByIdResponse, error)

	// CreateOnrampSessionWithBodyWithResponse request with any body
	CreateOnrampSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOnrampSessionResponse, error)

	CreateOnrampSessionWithResponse(ctx context.Context, body CreateOnrampSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOnrampSessionResponse, error)

	// ListPoliciesWithResponse request
	ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error)

	// CreatePolicyWithBodyWithResponse request with any body
	CreatePolicyWithBodyWithResponse(ctx context.Context, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	CreatePolicyWithResponse(ctx context.Context, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	// DeletePolicyWithResponse request
	DeletePolicyWithResponse(ctx context.Context, policyId string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error)

	// GetPolicyByIdWithResponse request
	GetPolicyByIdWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetPolicyByIdResponse, error)

	// UpdatePolicyWithBodyWithResponse request with any body
	UpdatePolicyWithBodyWithResponse(ctx context.Context, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	UpdatePolicyWithResponse(ctx context.Context, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	// ListSolanaAccountsWithResponse request
	ListSolanaAccountsWithResponse(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*ListSolanaAccountsResponse, error)

	// CreateSolanaAccountWithBodyWithResponse request with any body
	CreateSolanaAccountWithBodyWithResponse(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error)

	CreateSolanaAccountWithResponse(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error)

	// GetSolanaAccountByNameWithResponse request
	GetSolanaAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetSolanaAccountByNameResponse, error)

	// ExportSolanaAccountByNameWithBodyWithResponse request with any body
	ExportSolanaAccountByNameWithBodyWithResponse(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportSolanaAccountByNameResponse, error)

	ExportSolanaAccountByNameWithResponse(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportSolanaAccountByNameResponse, error)

	// ImportSolanaAccountWithBodyWithResponse request with any body
	ImportSolanaAccountWithBodyWithResponse(ctx context.Context, params *ImportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportSolanaAccountResponse, error)

	ImportSolanaAccountWithResponse(ctx context.Context, params *ImportSolanaAccountParams, body ImportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportSolanaAccountResponse, error)

	// SendSolanaTransactionWithBodyWithResponse request with any body
	SendSolanaTransactionWithBodyWithResponse(ctx context.Context, params *SendSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendSolanaTransactionResponse, error)

	SendSolanaTransactionWithResponse(ctx context.Context, params *SendSolanaTransactionParams, body SendSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SendSolanaTransactionResponse, error)

	// GetSolanaAccountWithResponse request
	GetSolanaAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetSolanaAccountResponse, error)

	// UpdateSolanaAccountWithBodyWithResponse request with any body
	UpdateSolanaAccountWithBodyWithResponse(ctx context.Context, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSolanaAccountResponse, error)

	UpdateSolanaAccountWithResponse(ctx context.Context, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSolanaAccountResponse, error)

	// ExportSolanaAccountWithBodyWithResponse request with any body
	ExportSolanaAccountWithBodyWithResponse(ctx context.Context, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportSolanaAccountResponse, error)

	ExportSolanaAccountWithResponse(ctx context.Context, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportSolanaAccountResponse, error)

	// SignSolanaMessageWithBodyWithResponse request with any body
	SignSolanaMessageWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error)

	SignSolanaMessageWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error)

	// SignSolanaTransactionWithBodyWithResponse request with any body
	SignSolanaTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error)

	SignSolanaTransactionWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error)

	// RequestSolanaFaucetWithBodyWithResponse request with any body
	RequestSolanaFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error)

	RequestSolanaFaucetWithResponse(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error)

	// ListSolanaTokenBalancesWithResponse request
	ListSolanaTokenBalancesWithResponse(ctx context.Context, network ListSolanaTokenBalancesNetwork, address string, params *ListSolanaTokenBalancesParams, reqEditors ...RequestEditorFn) (*ListSolanaTokenBalancesResponse, error)

	// SettleX402PaymentWithBodyWithResponse request with any body
	SettleX402PaymentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SettleX402PaymentResponse, error)

	SettleX402PaymentWithResponse(ctx context.Context, body SettleX402PaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*SettleX402PaymentResponse, error)

	// SupportedX402PaymentKindsWithResponse request
	SupportedX402PaymentKindsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SupportedX402PaymentKindsResponse, error)

	// VerifyX402PaymentWithBodyWithResponse request with any body
	VerifyX402PaymentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyX402PaymentResponse, error)

	VerifyX402PaymentWithResponse(ctx context.Context, body VerifyX402PaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyX402PaymentResponse, error)
}

type ListDataTokenBalancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Balances The list of EVM token balances.
		Balances []TokenBalance `json:"balances"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON400 *Error
	JSON404 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListDataTokenBalancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDataTokenBalancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTokensForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountTokenAddressesResponse
	JSON400      *Error
	JSON401      *UnauthorizedError
	JSON429      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListTokensForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTokensForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSQLGrammarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON401      *UnauthorizedError
	JSON429      *Error
	JSON500      *InternalServerError
	JSON504      *TimedOutError
}

// Status returns HTTPResponse.Status
func (r GetSQLGrammarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSQLGrammarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunSQLQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OnchainDataResult
	JSON400      *InvalidSQLQueryError
	JSON401      *UnauthorizedError
	JSON408      *Error
	JSON429      *Error
	JSON500      *InternalServerError
	JSON504      *TimedOutError
}

// Status returns HTTPResponse.Status
func (r RunSQLQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunSQLQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWebhookSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookSubscriptionListResponse
	JSON400      *Error
	JSON401      *UnauthorizedError
	JSON429      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListWebhookSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebhookSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWebhookSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WebhookSubscriptionResponse
	JSON400      *Error
	JSON401      *UnauthorizedError
	JSON429      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateWebhookSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebhookSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON404      *Error
	JSON429      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookSubscriptionResponse
	JSON401      *UnauthorizedError
	JSON404      *Error
	JSON429      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetWebhookSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWebhookSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookSubscriptionResponse
	JSON400      *Error
	JSON401      *UnauthorizedError
	JSON404      *Error
	JSON429      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateWebhookSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWebhookSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEndUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EndUsers The list of end users.
		EndUsers []EndUser `json:"endUsers"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON400 *Error
	JSON401 *UnauthorizedError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListEndUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEndUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EndUser
	JSON400      *Error
	JSON401      *Error
	JSON402      *PaymentMethodRequiredError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateEndUserAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndUser
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ValidateEndUserAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateEndUserAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EndUser
	JSON400      *Error
	JSON401      *Error
	JSON402      *PaymentMethodRequiredError
	JSON409      *Error
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ImportEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndUser
	JSON404      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEvmAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Accounts The list of EVM accounts.
		Accounts []EvmAccount `json:"accounts"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListEvmAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEvmAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmAccount
	JSON400      *Error
	JSON401      *Error
	JSON402      *PaymentMethodRequiredError
	JSON409      *Error
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreateEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportEvmAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
		EncryptedPrivateKey string `json:"encryptedPrivateKey"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ExportEvmAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportEvmAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmAccount
	JSON400      *Error
	JSON401      *Error
	JSON402      *PaymentMethodRequiredError
	JSON409      *Error
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ImportEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmAccount
	JSON400      *Error
	JSON404      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdateEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
		EncryptedPrivateKey string `json:"encryptedPrivateKey"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ExportEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendEvmTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TransactionHash The hash of the transaction, as a 0x-prefixed hex string.
		TransactionHash string `json:"transactionHash"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON403 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SendEvmTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendEvmTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the hash, as a 0x-prefixed hex string.
		Signature string `json:"signature"`
	}
	JSON400 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignEvmHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the message, as a 0x-prefixed hex string.
		Signature string `json:"signature"`
	}
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignEvmMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// SignedTransaction The RLP-encoded signed transaction, as a 0x-prefixed hex string.
		SignedTransaction string `json:"signedTransaction"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON403 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignEvmTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmTypedDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the typed data, as a 0x-prefixed hex string.
		Signature string `json:"signature"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignEvmTypedDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmTypedDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestEvmFaucetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TransactionHash The hash of the transaction that requested the funds.
		// **Note:** In rare cases, when gas conditions are unusually high, the transaction may not confirm, and the system may issue a replacement transaction to complete the faucet request. In these rare cases, the `transactionHash` will be out of sync with the actual faucet transaction that was confirmed onchain.
		TransactionHash string `json:"transactionHash"`
	}
	JSON400 *Error
	JSON403 *Error
	JSON429 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r RequestEvmFaucetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestEvmFaucetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEvmSmartAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Accounts The list of Smart Accounts.
		Accounts []EvmSmartAccount `json:"accounts"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON400 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListEvmSmartAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEvmSmartAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEvmSmartAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmSmartAccount
	JSON400      *Error
	JSON402      *PaymentMethodRequiredError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreateEvmSmartAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEvmSmartAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmSmartAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmSmartAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmSmartAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmSmartAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmSmartAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmSmartAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmSmartAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmSmartAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEvmSmartAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmSmartAccount
	JSON400      *Error
	JSON404      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdateEvmSmartAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEvmSmartAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpendPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmUserOperation
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreateSpendPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpendPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpendPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`

		// SpendPermissions The spend permissions for the smart account.
		SpendPermissions []SpendPermissionResponseObject `json:"spendPermissions"`
	}
	JSON400 *Error
	JSON404 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListSpendPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpendPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeSpendPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmUserOperation
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r RevokeSpendPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeSpendPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareUserOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmUserOperation
	JSON400      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r PrepareUserOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareUserOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareAndSendUserOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmUserOperation
	JSON400      *Error
	JSON401      *UnauthorizedError
	JSON402      *PaymentMethodRequiredError
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r PrepareAndSendUserOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareAndSendUserOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmUserOperation
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetUserOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendUserOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmUserOperation
	JSON400      *Error
	JSON402      *PaymentMethodRequiredError
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SendUserOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendUserOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEvmSwapQuoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateSwapQuoteResponseWrapper
	JSON400      *Error
	JSON403      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreateEvmSwapQuoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEvmSwapQuoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmSwapPriceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSwapPriceResponseWrapper
	JSON400      *Error
	JSON403      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmSwapPriceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmSwapPriceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEvmTokenBalancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Balances The list of EVM token balances.
		Balances []TokenBalance `json:"balances"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON400 *Error
	JSON404 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListEvmTokenBalancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEvmTokenBalancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOnrampOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Order An Onramp order.
		Order OnrampOrder `json:"order"`

		// PaymentLink A payment link to pay for an order.
		//
		// Please refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/onramp-overview) for details on how to integrate with the different payment link types.
		PaymentLink *OnrampPaymentLink `json:"paymentLink,omitempty"`
	}
	JSON400 *Error
	JSON401 *UnauthorizedError
	JSON429 *RateLimitExceeded
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateOnrampOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOnrampOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOnrampOrderByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Order An Onramp order.
		Order OnrampOrder `json:"order"`
	}
	JSON401 *UnauthorizedError
	JSON404 *Error
	JSON429 *RateLimitExceeded
}

// Status returns HTTPResponse.Status
func (r GetOnrampOrderByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOnrampOrderByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOnrampSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Quote Quote information with pricing details for the crypto purchase.
		Quote *OnrampQuote `json:"quote,omitempty"`

		// Session An onramp session containing a ready-to-use onramp URL.
		Session OnrampSession `json:"session"`
	}
	JSON400 *Error
	JSON401 *UnauthorizedError
	JSON429 *RateLimitExceeded
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateOnrampSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOnrampSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`

		// Policies The list of policies.
		Policies []Policy `json:"policies"`
	}
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Policy
	JSON400      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r DeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetPolicyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON400      *Error
	JSON404      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSolanaAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Accounts The list of Solana accounts.
		Accounts []SolanaAccount `json:"accounts"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListSolanaAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSolanaAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SolanaAccount
	JSON400      *Error
	JSON401      *Error
	JSON402      *PaymentMethodRequiredError
	JSON409      *Error
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreateSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSolanaAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SolanaAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetSolanaAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSolanaAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportSolanaAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EncryptedPrivateKey The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
		EncryptedPrivateKey string `json:"encryptedPrivateKey"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ExportSolanaAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportSolanaAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SolanaAccount
	JSON400      *Error
	JSON401      *Error
	JSON402      *PaymentMethodRequiredError
	JSON409      *Error
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ImportSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendSolanaTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TransactionSignature The base58 encoded transaction signature.
		TransactionSignature string `json:"transactionSignature"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON403 *Error
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SendSolanaTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendSolanaTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SolanaAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SolanaAccount
	JSON400      *Error
	JSON404      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdateSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EncryptedPrivateKey The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
		EncryptedPrivateKey string `json:"encryptedPrivateKey"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ExportSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignSolanaMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the message, as a base58 encoded string.
		Signature string `json:"signature"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignSolanaMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignSolanaMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignSolanaTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// SignedTransaction The base64 encoded signed transaction.
		SignedTransaction string `json:"signedTransaction"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON403 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignSolanaTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignSolanaTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestSolanaFaucetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TransactionSignature The signature identifying the transaction that requested the funds.
		TransactionSignature string `json:"transactionSignature"`
	}
	JSON400 *Error
	JSON403 *Error
	JSON429 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r RequestSolanaFaucetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestSolanaFaucetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSolanaTokenBalancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Balances The list of Solana token balances.
		Balances []SolanaTokenBalance `json:"balances"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON400 *Error
	JSON404 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListSolanaTokenBalancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSolanaTokenBalancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SettleX402PaymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *X402SettleResponse
	JSON400      *X402SettleError
	JSON402      *PaymentMethodRequiredError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SettleX402PaymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SettleX402PaymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SupportedX402PaymentKindsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *X402SupportedPaymentKindsResponse
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SupportedX402PaymentKindsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SupportedX402PaymentKindsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyX402PaymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *X402VerifyResponse
	JSON400      *X402VerifyInvalidError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r VerifyX402PaymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyX402PaymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListDataTokenBalancesWithResponse request returning *ListDataTokenBalancesResponse
func (c *ClientWithResponses) ListDataTokenBalancesWithResponse(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListDataTokenBalancesParams, reqEditors ...RequestEditorFn) (*ListDataTokenBalancesResponse, error) {
	rsp, err := c.ListDataTokenBalances(ctx, network, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDataTokenBalancesResponse(rsp)
}

// ListTokensForAccountWithResponse request returning *ListTokensForAccountResponse
func (c *ClientWithResponses) ListTokensForAccountWithResponse(ctx context.Context, network ListTokensForAccountParamsNetwork, address string, reqEditors ...RequestEditorFn) (*ListTokensForAccountResponse, error) {
	rsp, err := c.ListTokensForAccount(ctx, network, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTokensForAccountResponse(rsp)
}

// GetSQLGrammarWithResponse request returning *GetSQLGrammarResponse
func (c *ClientWithResponses) GetSQLGrammarWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSQLGrammarResponse, error) {
	rsp, err := c.GetSQLGrammar(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSQLGrammarResponse(rsp)
}

// RunSQLQueryWithBodyWithResponse request with arbitrary body returning *RunSQLQueryResponse
func (c *ClientWithResponses) RunSQLQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunSQLQueryResponse, error) {
	rsp, err := c.RunSQLQueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunSQLQueryResponse(rsp)
}

func (c *ClientWithResponses) RunSQLQueryWithResponse(ctx context.Context, body RunSQLQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*RunSQLQueryResponse, error) {
	rsp, err := c.RunSQLQuery(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunSQLQueryResponse(rsp)
}

// ListWebhookSubscriptionsWithResponse request returning *ListWebhookSubscriptionsResponse
func (c *ClientWithResponses) ListWebhookSubscriptionsWithResponse(ctx context.Context, params *ListWebhookSubscriptionsParams, reqEditors ...RequestEditorFn) (*ListWebhookSubscriptionsResponse, error) {
	rsp, err := c.ListWebhookSubscriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebhookSubscriptionsResponse(rsp)
}

// CreateWebhookSubscriptionWithBodyWithResponse request with arbitrary body returning *CreateWebhookSubscriptionResponse
func (c *ClientWithResponses) CreateWebhookSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookSubscriptionResponse, error) {
	rsp, err := c.CreateWebhookSubscriptionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) CreateWebhookSubscriptionWithResponse(ctx context.Context, body CreateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookSubscriptionResponse, error) {
	rsp, err := c.CreateWebhookSubscription(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookSubscriptionResponse(rsp)
}

// DeleteWebhookSubscriptionWithResponse request returning *DeleteWebhookSubscriptionResponse
func (c *ClientWithResponses) DeleteWebhookSubscriptionWithResponse(ctx context.Context, subscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteWebhookSubscriptionResponse, error) {
	rsp, err := c.DeleteWebhookSubscription(ctx, subscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookSubscriptionResponse(rsp)
}

// GetWebhookSubscriptionWithResponse request returning *GetWebhookSubscriptionResponse
func (c *ClientWithResponses) GetWebhookSubscriptionWithResponse(ctx context.Context, subscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetWebhookSubscriptionResponse, error) {
	rsp, err := c.GetWebhookSubscription(ctx, subscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookSubscriptionResponse(rsp)
}

// UpdateWebhookSubscriptionWithBodyWithResponse request with arbitrary body returning *UpdateWebhookSubscriptionResponse
func (c *ClientWithResponses) UpdateWebhookSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookSubscriptionResponse, error) {
	rsp, err := c.UpdateWebhookSubscriptionWithBody(ctx, subscriptionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) UpdateWebhookSubscriptionWithResponse(ctx context.Context, subscriptionId openapi_types.UUID, body UpdateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookSubscriptionResponse, error) {
	rsp, err := c.UpdateWebhookSubscription(ctx, subscriptionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookSubscriptionResponse(rsp)
}

// ListEndUsersWithResponse request returning *ListEndUsersResponse
func (c *ClientWithResponses) ListEndUsersWithResponse(ctx context.Context, params *ListEndUsersParams, reqEditors ...RequestEditorFn) (*ListEndUsersResponse, error) {
	rsp, err := c.ListEndUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEndUsersResponse(rsp)
}

// CreateEndUserWithBodyWithResponse request with arbitrary body returning *CreateEndUserResponse
func (c *ClientWithResponses) CreateEndUserWithBodyWithResponse(ctx context.Context, params *CreateEndUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEndUserResponse, error) {
	rsp, err := c.CreateEndUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEndUserResponse(rsp)
}

func (c *ClientWithResponses) CreateEndUserWithResponse(ctx context.Context, params *CreateEndUserParams, body CreateEndUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEndUserResponse, error) {
	rsp, err := c.CreateEndUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEndUserResponse(rsp)
}

// ValidateEndUserAccessTokenWithBodyWithResponse request with arbitrary body returning *ValidateEndUserAccessTokenResponse
func (c *ClientWithResponses) ValidateEndUserAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateEndUserAccessTokenResponse, error) {
	rsp, err := c.ValidateEndUserAccessTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateEndUserAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) ValidateEndUserAccessTokenWithResponse(ctx context.Context, body ValidateEndUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateEndUserAccessTokenResponse, error) {
	rsp, err := c.ValidateEndUserAccessToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateEndUserAccessTokenResponse(rsp)
}

// ImportEndUserWithBodyWithResponse request with arbitrary body returning *ImportEndUserResponse
func (c *ClientWithResponses) ImportEndUserWithBodyWithResponse(ctx context.Context, params *ImportEndUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportEndUserResponse, error) {
	rsp, err := c.ImportEndUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportEndUserResponse(rsp)
}

func (c *ClientWithResponses) ImportEndUserWithResponse(ctx context.Context, params *ImportEndUserParams, body ImportEndUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportEndUserResponse, error) {
	rsp, err := c.ImportEndUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportEndUserResponse(rsp)
}

// GetEndUserWithResponse request returning *GetEndUserResponse
func (c *ClientWithResponses) GetEndUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetEndUserResponse, error) {
	rsp, err := c.GetEndUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEndUserResponse(rsp)
}

// ListEvmAccountsWithResponse request returning *ListEvmAccountsResponse
func (c *ClientWithResponses) ListEvmAccountsWithResponse(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmAccountsResponse, error) {
	rsp, err := c.ListEvmAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEvmAccountsResponse(rsp)
}

// CreateEvmAccountWithBodyWithResponse request with arbitrary body returning *CreateEvmAccountResponse
func (c *ClientWithResponses) CreateEvmAccountWithBodyWithResponse(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error) {
	rsp, err := c.CreateEvmAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateEvmAccountWithResponse(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error) {
	rsp, err := c.CreateEvmAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmAccountResponse(rsp)
}

// GetEvmAccountByNameWithResponse request returning *GetEvmAccountByNameResponse
func (c *ClientWithResponses) GetEvmAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetEvmAccountByNameResponse, error) {
	rsp, err := c.GetEvmAccountByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmAccountByNameResponse(rsp)
}

// ExportEvmAccountByNameWithBodyWithResponse request with arbitrary body returning *ExportEvmAccountByNameResponse
func (c *ClientWithResponses) ExportEvmAccountByNameWithBodyWithResponse(ctx context.Context, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportEvmAccountByNameResponse, error) {
	rsp, err := c.ExportEvmAccountByNameWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportEvmAccountByNameResponse(rsp)
}

func (c *ClientWithResponses) ExportEvmAccountByNameWithResponse(ctx context.Context, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportEvmAccountByNameResponse, error) {
	rsp, err := c.ExportEvmAccountByName(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportEvmAccountByNameResponse(rsp)
}

// ImportEvmAccountWithBodyWithResponse request with arbitrary body returning *ImportEvmAccountResponse
func (c *ClientWithResponses) ImportEvmAccountWithBodyWithResponse(ctx context.Context, params *ImportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportEvmAccountResponse, error) {
	rsp, err := c.ImportEvmAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportEvmAccountResponse(rsp)
}

func (c *ClientWithResponses) ImportEvmAccountWithResponse(ctx context.Context, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportEvmAccountResponse, error) {
	rsp, err := c.ImportEvmAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportEvmAccountResponse(rsp)
}

// GetEvmAccountWithResponse request returning *GetEvmAccountResponse
func (c *ClientWithResponses) GetEvmAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmAccountResponse, error) {
	rsp, err := c.GetEvmAccount(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmAccountResponse(rsp)
}

// UpdateEvmAccountWithBodyWithResponse request with arbitrary body returning *UpdateEvmAccountResponse
func (c *ClientWithResponses) UpdateEvmAccountWithBodyWithResponse(ctx context.Context, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEvmAccountResponse, error) {
	rsp, err := c.UpdateEvmAccountWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEvmAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateEvmAccountWithResponse(ctx context.Context, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEvmAccountResponse, error) {
	rsp, err := c.UpdateEvmAccount(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEvmAccountResponse(rsp)
}

// ExportEvmAccountWithBodyWithResponse request with arbitrary body returning *ExportEvmAccountResponse
func (c *ClientWithResponses) ExportEvmAccountWithBodyWithResponse(ctx context.Context, address string, params *ExportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportEvmAccountResponse, error) {
	rsp, err := c.ExportEvmAccountWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportEvmAccountResponse(rsp)
}

func (c *ClientWithResponses) ExportEvmAccountWithResponse(ctx context.Context, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportEvmAccountResponse, error) {
	rsp, err := c.ExportEvmAccount(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportEvmAccountResponse(rsp)
}

// SendEvmTransactionWithBodyWithResponse request with arbitrary body returning *SendEvmTransactionResponse
func (c *ClientWithResponses) SendEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error) {
	rsp, err := c.SendEvmTransactionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendEvmTransactionResponse(rsp)
}

func (c *ClientWithResponses) SendEvmTransactionWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error) {
	rsp, err := c.SendEvmTransaction(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendEvmTransactionResponse(rsp)
}

// SignEvmHashWithBodyWithResponse request with arbitrary body returning *SignEvmHashResponse
func (c *ClientWithResponses) SignEvmHashWithBodyWithResponse(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error) {
	rsp, err := c.SignEvmHashWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmHashResponse(rsp)
}

func (c *ClientWithResponses) SignEvmHashWithResponse(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error) {
	rsp, err := c.SignEvmHash(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmHashResponse(rsp)
}

// SignEvmMessageWithBodyWithResponse request with arbitrary body returning *SignEvmMessageResponse
func (c *ClientWithResponses) SignEvmMessageWithBodyWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error) {
	rsp, err := c.SignEvmMessageWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmMessageResponse(rsp)
}

func (c *ClientWithResponses) SignEvmMessageWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error) {
	rsp, err := c.SignEvmMessage(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmMessageResponse(rsp)
}

// SignEvmTransactionWithBodyWithResponse request with arbitrary body returning *SignEvmTransactionResponse
func (c *ClientWithResponses) SignEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error) {
	rsp, err := c.SignEvmTransactionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmTransactionResponse(rsp)
}

func (c *ClientWithResponses) SignEvmTransactionWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error) {
	rsp, err := c.SignEvmTransaction(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmTransactionResponse(rsp)
}

// SignEvmTypedDataWithBodyWithResponse request with arbitrary body returning *SignEvmTypedDataResponse
func (c *ClientWithResponses) SignEvmTypedDataWithBodyWithResponse(ctx context.Context, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmTypedDataResponse, error) {
	rsp, err := c.SignEvmTypedDataWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmTypedDataResponse(rsp)
}

func (c *ClientWithResponses) SignEvmTypedDataWithResponse(ctx context.Context, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmTypedDataResponse, error) {
	rsp, err := c.SignEvmTypedData(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmTypedDataResponse(rsp)
}

// RequestEvmFaucetWithBodyWithResponse request with arbitrary body returning *RequestEvmFaucetResponse
func (c *ClientWithResponses) RequestEvmFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error) {
	rsp, err := c.RequestEvmFaucetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestEvmFaucetResponse(rsp)
}

func (c *ClientWithResponses) RequestEvmFaucetWithResponse(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error) {
	rsp, err := c.RequestEvmFaucet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestEvmFaucetResponse(rsp)
}

// ListEvmSmartAccountsWithResponse request returning *ListEvmSmartAccountsResponse
func (c *ClientWithResponses) ListEvmSmartAccountsWithResponse(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmSmartAccountsResponse, error) {
	rsp, err := c.ListEvmSmartAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEvmSmartAccountsResponse(rsp)
}

// CreateEvmSmartAccountWithBodyWithResponse request with arbitrary body returning *CreateEvmSmartAccountResponse
func (c *ClientWithResponses) CreateEvmSmartAccountWithBodyWithResponse(ctx context.Context, params *CreateEvmSmartAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error) {
	rsp, err := c.CreateEvmSmartAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmSmartAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateEvmSmartAccountWithResponse(ctx context.Context, params *CreateEvmSmartAccountParams, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error) {
	rsp, err := c.CreateEvmSmartAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmSmartAccountResponse(rsp)
}

// GetEvmSmartAccountByNameWithResponse request returning *GetEvmSmartAccountByNameResponse
func (c *ClientWithResponses) GetEvmSmartAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetEvmSmartAccountByNameResponse, error) {
	rsp, err := c.GetEvmSmartAccountByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmSmartAccountByNameResponse(rsp)
}

// GetEvmSmartAccountWithResponse request returning *GetEvmSmartAccountResponse
func (c *ClientWithResponses) GetEvmSmartAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmSmartAccountResponse, error) {
	rsp, err := c.GetEvmSmartAccount(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmSmartAccountResponse(rsp)
}

// UpdateEvmSmartAccountWithBodyWithResponse request with arbitrary body returning *UpdateEvmSmartAccountResponse
func (c *ClientWithResponses) UpdateEvmSmartAccountWithBodyWithResponse(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEvmSmartAccountResponse, error) {
	rsp, err := c.UpdateEvmSmartAccountWithBody(ctx, address, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEvmSmartAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateEvmSmartAccountWithResponse(ctx context.Context, address string, body UpdateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEvmSmartAccountResponse, error) {
	rsp, err := c.UpdateEvmSmartAccount(ctx, address, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEvmSmartAccountResponse(rsp)
}

// CreateSpendPermissionWithBodyWithResponse request with arbitrary body returning *CreateSpendPermissionResponse
func (c *ClientWithResponses) CreateSpendPermissionWithBodyWithResponse(ctx context.Context, address string, params *CreateSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpendPermissionResponse, error) {
	rsp, err := c.CreateSpendPermissionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpendPermissionResponse(rsp)
}

func (c *ClientWithResponses) CreateSpendPermissionWithResponse(ctx context.Context, address string, params *CreateSpendPermissionParams, body CreateSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpendPermissionResponse, error) {
	rsp, err := c.CreateSpendPermission(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpendPermissionResponse(rsp)
}

// ListSpendPermissionsWithResponse request returning *ListSpendPermissionsResponse
func (c *ClientWithResponses) ListSpendPermissionsWithResponse(ctx context.Context, address string, params *ListSpendPermissionsParams, reqEditors ...RequestEditorFn) (*ListSpendPermissionsResponse, error) {
	rsp, err := c.ListSpendPermissions(ctx, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpendPermissionsResponse(rsp)
}

// RevokeSpendPermissionWithBodyWithResponse request with arbitrary body returning *RevokeSpendPermissionResponse
func (c *ClientWithResponses) RevokeSpendPermissionWithBodyWithResponse(ctx context.Context, address string, params *RevokeSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeSpendPermissionResponse, error) {
	rsp, err := c.RevokeSpendPermissionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeSpendPermissionResponse(rsp)
}

func (c *ClientWithResponses) RevokeSpendPermissionWithResponse(ctx context.Context, address string, params *RevokeSpendPermissionParams, body RevokeSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeSpendPermissionResponse, error) {
	rsp, err := c.RevokeSpendPermission(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeSpendPermissionResponse(rsp)
}

// PrepareUserOperationWithBodyWithResponse request with arbitrary body returning *PrepareUserOperationResponse
func (c *ClientWithResponses) PrepareUserOperationWithBodyWithResponse(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error) {
	rsp, err := c.PrepareUserOperationWithBody(ctx, address, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareUserOperationResponse(rsp)
}

func (c *ClientWithResponses) PrepareUserOperationWithResponse(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error) {
	rsp, err := c.PrepareUserOperation(ctx, address, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareUserOperationResponse(rsp)
}

// PrepareAndSendUserOperationWithBodyWithResponse request with arbitrary body returning *PrepareAndSendUserOperationResponse
func (c *ClientWithResponses) PrepareAndSendUserOperationWithBodyWithResponse(ctx context.Context, address string, params *PrepareAndSendUserOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareAndSendUserOperationResponse, error) {
	rsp, err := c.PrepareAndSendUserOperationWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareAndSendUserOperationResponse(rsp)
}

func (c *ClientWithResponses) PrepareAndSendUserOperationWithResponse(ctx context.Context, address string, params *PrepareAndSendUserOperationParams, body PrepareAndSendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareAndSendUserOperationResponse, error) {
	rsp, err := c.PrepareAndSendUserOperation(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareAndSendUserOperationResponse(rsp)
}

// GetUserOperationWithResponse request returning *GetUserOperationResponse
func (c *ClientWithResponses) GetUserOperationWithResponse(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*GetUserOperationResponse, error) {
	rsp, err := c.GetUserOperation(ctx, address, userOpHash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserOperationResponse(rsp)
}

// SendUserOperationWithBodyWithResponse request with arbitrary body returning *SendUserOperationResponse
func (c *ClientWithResponses) SendUserOperationWithBodyWithResponse(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error) {
	rsp, err := c.SendUserOperationWithBody(ctx, address, userOpHash, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendUserOperationResponse(rsp)
}

func (c *ClientWithResponses) SendUserOperationWithResponse(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error) {
	rsp, err := c.SendUserOperation(ctx, address, userOpHash, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendUserOperationResponse(rsp)
}

// CreateEvmSwapQuoteWithBodyWithResponse request with arbitrary body returning *CreateEvmSwapQuoteResponse
func (c *ClientWithResponses) CreateEvmSwapQuoteWithBodyWithResponse(ctx context.Context, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmSwapQuoteResponse, error) {
	rsp, err := c.CreateEvmSwapQuoteWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmSwapQuoteResponse(rsp)
}

func (c *ClientWithResponses) CreateEvmSwapQuoteWithResponse(ctx context.Context, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmSwapQuoteResponse, error) {
	rsp, err := c.CreateEvmSwapQuote(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmSwapQuoteResponse(rsp)
}

// GetEvmSwapPriceWithResponse request returning *GetEvmSwapPriceResponse
func (c *ClientWithResponses) GetEvmSwapPriceWithResponse(ctx context.Context, params *GetEvmSwapPriceParams, reqEditors ...RequestEditorFn) (*GetEvmSwapPriceResponse, error) {
	rsp, err := c.GetEvmSwapPrice(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmSwapPriceResponse(rsp)
}

// ListEvmTokenBalancesWithResponse request returning *ListEvmTokenBalancesResponse
func (c *ClientWithResponses) ListEvmTokenBalancesWithResponse(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*ListEvmTokenBalancesResponse, error) {
	rsp, err := c.ListEvmTokenBalances(ctx, network, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEvmTokenBalancesResponse(rsp)
}

// CreateOnrampOrderWithBodyWithResponse request with arbitrary body returning *CreateOnrampOrderResponse
func (c *ClientWithResponses) CreateOnrampOrderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOnrampOrderResponse, error) {
	rsp, err := c.CreateOnrampOrderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOnrampOrderResponse(rsp)
}

func (c *ClientWithResponses) CreateOnrampOrderWithResponse(ctx context.Context, body CreateOnrampOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOnrampOrderResponse, error) {
	rsp, err := c.CreateOnrampOrder(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOnrampOrderResponse(rsp)
}

// GetOnrampOrderByIdWithResponse request returning *GetOnrampOrderByIdResponse
func (c *ClientWithResponses) GetOnrampOrderByIdWithResponse(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*GetOnrampOrderByIdResponse, error) {
	rsp, err := c.GetOnrampOrderById(ctx, orderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOnrampOrderByIdResponse(rsp)
}

// CreateOnrampSessionWithBodyWithResponse request with arbitrary body returning *CreateOnrampSessionResponse
func (c *ClientWithResponses) CreateOnrampSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOnrampSessionResponse, error) {
	rsp, err := c.CreateOnrampSessionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOnrampSessionResponse(rsp)
}

func (c *ClientWithResponses) CreateOnrampSessionWithResponse(ctx context.Context, body CreateOnrampSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOnrampSessionResponse, error) {
	rsp, err := c.CreateOnrampSession(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOnrampSessionResponse(rsp)
}

// ListPoliciesWithResponse request returning *ListPoliciesResponse
func (c *ClientWithResponses) ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error) {
	rsp, err := c.ListPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPoliciesResponse(rsp)
}

// CreatePolicyWithBodyWithResponse request with arbitrary body returning *CreatePolicyResponse
func (c *ClientWithResponses) CreatePolicyWithBodyWithResponse(ctx context.Context, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePolicyWithResponse(ctx context.Context, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicy(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

// DeletePolicyWithResponse request returning *DeletePolicyResponse
func (c *ClientWithResponses) DeletePolicyWithResponse(ctx context.Context, policyId string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error) {
	rsp, err := c.DeletePolicy(ctx, policyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePolicyResponse(rsp)
}

// GetPolicyByIdWithResponse request returning *GetPolicyByIdResponse
func (c *ClientWithResponses) GetPolicyByIdWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetPolicyByIdResponse, error) {
	rsp, err := c.GetPolicyById(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyByIdResponse(rsp)
}

// UpdatePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePolicyResponse
func (c *ClientWithResponses) UpdatePolicyWithBodyWithResponse(ctx context.Context, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicyWithBody(ctx, policyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyWithResponse(ctx context.Context, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicy(ctx, policyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

// ListSolanaAccountsWithResponse request returning *ListSolanaAccountsResponse
func (c *ClientWithResponses) ListSolanaAccountsWithResponse(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*ListSolanaAccountsResponse, error) {
	rsp, err := c.ListSolanaAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSolanaAccountsResponse(rsp)
}

// CreateSolanaAccountWithBodyWithResponse request with arbitrary body returning *CreateSolanaAccountResponse
func (c *ClientWithResponses) CreateSolanaAccountWithBodyWithResponse(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error) {
	rsp, err := c.CreateSolanaAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSolanaAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateSolanaAccountWithResponse(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error) {
	rsp, err := c.CreateSolanaAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSolanaAccountResponse(rsp)
}

// GetSolanaAccountByNameWithResponse request returning *GetSolanaAccountByNameResponse
func (c *ClientWithResponses) GetSolanaAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetSolanaAccountByNameResponse, error) {
	rsp, err := c.GetSolanaAccountByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSolanaAccountByNameResponse(rsp)
}

// ExportSolanaAccountByNameWithBodyWithResponse request with arbitrary body returning *ExportSolanaAccountByNameResponse
func (c *ClientWithResponses) ExportSolanaAccountByNameWithBodyWithResponse(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportSolanaAccountByNameResponse, error) {
	rsp, err := c.ExportSolanaAccountByNameWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSolanaAccountByNameResponse(rsp)
}

func (c *ClientWithResponses) ExportSolanaAccountByNameWithResponse(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportSolanaAccountByNameResponse, error) {
	rsp, err := c.ExportSolanaAccountByName(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSolanaAccountByNameResponse(rsp)
}

// ImportSolanaAccountWithBodyWithResponse request with arbitrary body returning *ImportSolanaAccountResponse
func (c *ClientWithResponses) ImportSolanaAccountWithBodyWithResponse(ctx context.Context, params *ImportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportSolanaAccountResponse, error) {
	rsp, err := c.ImportSolanaAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportSolanaAccountResponse(rsp)
}

func (c *ClientWithResponses) ImportSolanaAccountWithResponse(ctx context.Context, params *ImportSolanaAccountParams, body ImportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportSolanaAccountResponse, error) {
	rsp, err := c.ImportSolanaAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportSolanaAccountResponse(rsp)
}

// SendSolanaTransactionWithBodyWithResponse request with arbitrary body returning *SendSolanaTransactionResponse
func (c *ClientWithResponses) SendSolanaTransactionWithBodyWithResponse(ctx context.Context, params *SendSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendSolanaTransactionResponse, error) {
	rsp, err := c.SendSolanaTransactionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendSolanaTransactionResponse(rsp)
}

func (c *ClientWithResponses) SendSolanaTransactionWithResponse(ctx context.Context, params *SendSolanaTransactionParams, body SendSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SendSolanaTransactionResponse, error) {
	rsp, err := c.SendSolanaTransaction(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendSolanaTransactionResponse(rsp)
}

// GetSolanaAccountWithResponse request returning *GetSolanaAccountResponse
func (c *ClientWithResponses) GetSolanaAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetSolanaAccountResponse, error) {
	rsp, err := c.GetSolanaAccount(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSolanaAccountResponse(rsp)
}

// UpdateSolanaAccountWithBodyWithResponse request with arbitrary body returning *UpdateSolanaAccountResponse
func (c *ClientWithResponses) UpdateSolanaAccountWithBodyWithResponse(ctx context.Context, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSolanaAccountResponse, error) {
	rsp, err := c.UpdateSolanaAccountWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSolanaAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateSolanaAccountWithResponse(ctx context.Context, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSolanaAccountResponse, error) {
	rsp, err := c.UpdateSolanaAccount(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSolanaAccountResponse(rsp)
}

// ExportSolanaAccountWithBodyWithResponse request with arbitrary body returning *ExportSolanaAccountResponse
func (c *ClientWithResponses) ExportSolanaAccountWithBodyWithResponse(ctx context.Context, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportSolanaAccountResponse, error) {
	rsp, err := c.ExportSolanaAccountWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSolanaAccountResponse(rsp)
}

func (c *ClientWithResponses) ExportSolanaAccountWithResponse(ctx context.Context, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportSolanaAccountResponse, error) {
	rsp, err := c.ExportSolanaAccount(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSolanaAccountResponse(rsp)
}

// SignSolanaMessageWithBodyWithResponse request with arbitrary body returning *SignSolanaMessageResponse
func (c *ClientWithResponses) SignSolanaMessageWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error) {
	rsp, err := c.SignSolanaMessageWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaMessageResponse(rsp)
}

func (c *ClientWithResponses) SignSolanaMessageWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error) {
	rsp, err := c.SignSolanaMessage(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaMessageResponse(rsp)
}

// SignSolanaTransactionWithBodyWithResponse request with arbitrary body returning *SignSolanaTransactionResponse
func (c *ClientWithResponses) SignSolanaTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error) {
	rsp, err := c.SignSolanaTransactionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaTransactionResponse(rsp)
}

func (c *ClientWithResponses) SignSolanaTransactionWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error) {
	rsp, err := c.SignSolanaTransaction(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaTransactionResponse(rsp)
}

// RequestSolanaFaucetWithBodyWithResponse request with arbitrary body returning *RequestSolanaFaucetResponse
func (c *ClientWithResponses) RequestSolanaFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error) {
	rsp, err := c.RequestSolanaFaucetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestSolanaFaucetResponse(rsp)
}

func (c *ClientWithResponses) RequestSolanaFaucetWithResponse(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error) {
	rsp, err := c.RequestSolanaFaucet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestSolanaFaucetResponse(rsp)
}

// ListSolanaTokenBalancesWithResponse request returning *ListSolanaTokenBalancesResponse
func (c *ClientWithResponses) ListSolanaTokenBalancesWithResponse(ctx context.Context, network ListSolanaTokenBalancesNetwork, address string, params *ListSolanaTokenBalancesParams, reqEditors ...RequestEditorFn) (*ListSolanaTokenBalancesResponse, error) {
	rsp, err := c.ListSolanaTokenBalances(ctx, network, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSolanaTokenBalancesResponse(rsp)
}

// SettleX402PaymentWithBodyWithResponse request with arbitrary body returning *SettleX402PaymentResponse
func (c *ClientWithResponses) SettleX402PaymentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SettleX402PaymentResponse, error) {
	rsp, err := c.SettleX402PaymentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSettleX402PaymentResponse(rsp)
}

func (c *ClientWithResponses) SettleX402PaymentWithResponse(ctx context.Context, body SettleX402PaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*SettleX402PaymentResponse, error) {
	rsp, err := c.SettleX402Payment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSettleX402PaymentResponse(rsp)
}

// SupportedX402PaymentKindsWithResponse request returning *SupportedX402PaymentKindsResponse
func (c *ClientWithResponses) SupportedX402PaymentKindsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SupportedX402PaymentKindsResponse, error) {
	rsp, err := c.SupportedX402PaymentKinds(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSupportedX402PaymentKindsResponse(rsp)
}

// VerifyX402PaymentWithBodyWithResponse request with arbitrary body returning *VerifyX402PaymentResponse
func (c *ClientWithResponses) VerifyX402PaymentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyX402PaymentResponse, error) {
	rsp, err := c.VerifyX402PaymentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyX402PaymentResponse(rsp)
}

func (c *ClientWithResponses) VerifyX402PaymentWithResponse(ctx context.Context, body VerifyX402PaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyX402PaymentResponse, error) {
	rsp, err := c.VerifyX402Payment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyX402PaymentResponse(rsp)
}

// ParseListDataTokenBalancesResponse parses an HTTP response from a ListDataTokenBalancesWithResponse call
func ParseListDataTokenBalancesResponse(rsp *http.Response) (*ListDataTokenBalancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDataTokenBalancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Balances The list of EVM token balances.
			Balances []TokenBalance `json:"balances"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListTokensForAccountResponse parses an HTTP response from a ListTokensForAccountWithResponse call
func ParseListTokensForAccountResponse(rsp *http.Response) (*ListTokensForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTokensForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountTokenAddressesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSQLGrammarResponse parses an HTTP response from a GetSQLGrammarWithResponse call
func ParseGetSQLGrammarResponse(rsp *http.Response) (*GetSQLGrammarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSQLGrammarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest TimedOutError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseRunSQLQueryResponse parses an HTTP response from a RunSQLQueryWithResponse call
func ParseRunSQLQueryResponse(rsp *http.Response) (*RunSQLQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunSQLQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OnchainDataResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidSQLQueryError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest TimedOutError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseListWebhookSubscriptionsResponse parses an HTTP response from a ListWebhookSubscriptionsWithResponse call
func ParseListWebhookSubscriptionsResponse(rsp *http.Response) (*ListWebhookSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWebhookSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookSubscriptionListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateWebhookSubscriptionResponse parses an HTTP response from a CreateWebhookSubscriptionWithResponse call
func ParseCreateWebhookSubscriptionResponse(rsp *http.Response) (*CreateWebhookSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWebhookSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WebhookSubscriptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookSubscriptionResponse parses an HTTP response from a DeleteWebhookSubscriptionWithResponse call
func ParseDeleteWebhookSubscriptionResponse(rsp *http.Response) (*DeleteWebhookSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWebhookSubscriptionResponse parses an HTTP response from a GetWebhookSubscriptionWithResponse call
func ParseGetWebhookSubscriptionResponse(rsp *http.Response) (*GetWebhookSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookSubscriptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateWebhookSubscriptionResponse parses an HTTP response from a UpdateWebhookSubscriptionWithResponse call
func ParseUpdateWebhookSubscriptionResponse(rsp *http.Response) (*UpdateWebhookSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWebhookSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookSubscriptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEndUsersResponse parses an HTTP response from a ListEndUsersWithResponse call
func ParseListEndUsersResponse(rsp *http.Response) (*ListEndUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEndUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EndUsers The list of end users.
			EndUsers []EndUser `json:"endUsers"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateEndUserResponse parses an HTTP response from a CreateEndUserWithResponse call
func ParseCreateEndUserResponse(rsp *http.Response) (*CreateEndUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EndUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseValidateEndUserAccessTokenResponse parses an HTTP response from a ValidateEndUserAccessTokenWithResponse call
func ParseValidateEndUserAccessTokenResponse(rsp *http.Response) (*ValidateEndUserAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateEndUserAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseImportEndUserResponse parses an HTTP response from a ImportEndUserWithResponse call
func ParseImportEndUserResponse(rsp *http.Response) (*ImportEndUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EndUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEndUserResponse parses an HTTP response from a GetEndUserWithResponse call
func ParseGetEndUserResponse(rsp *http.Response) (*GetEndUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEvmAccountsResponse parses an HTTP response from a ListEvmAccountsWithResponse call
func ParseListEvmAccountsResponse(rsp *http.Response) (*ListEvmAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEvmAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Accounts The list of EVM accounts.
			Accounts []EvmAccount `json:"accounts"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateEvmAccountResponse parses an HTTP response from a CreateEvmAccountWithResponse call
func ParseCreateEvmAccountResponse(rsp *http.Response) (*CreateEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmAccountByNameResponse parses an HTTP response from a GetEvmAccountByNameWithResponse call
func ParseGetEvmAccountByNameResponse(rsp *http.Response) (*GetEvmAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExportEvmAccountByNameResponse parses an HTTP response from a ExportEvmAccountByNameWithResponse call
func ParseExportEvmAccountByNameResponse(rsp *http.Response) (*ExportEvmAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportEvmAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
			EncryptedPrivateKey string `json:"encryptedPrivateKey"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseImportEvmAccountResponse parses an HTTP response from a ImportEvmAccountWithResponse call
func ParseImportEvmAccountResponse(rsp *http.Response) (*ImportEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmAccountResponse parses an HTTP response from a GetEvmAccountWithResponse call
func ParseGetEvmAccountResponse(rsp *http.Response) (*GetEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateEvmAccountResponse parses an HTTP response from a UpdateEvmAccountWithResponse call
func ParseUpdateEvmAccountResponse(rsp *http.Response) (*UpdateEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExportEvmAccountResponse parses an HTTP response from a ExportEvmAccountWithResponse call
func ParseExportEvmAccountResponse(rsp *http.Response) (*ExportEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
			EncryptedPrivateKey string `json:"encryptedPrivateKey"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSendEvmTransactionResponse parses an HTTP response from a SendEvmTransactionWithResponse call
func ParseSendEvmTransactionResponse(rsp *http.Response) (*SendEvmTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendEvmTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TransactionHash The hash of the transaction, as a 0x-prefixed hex string.
			TransactionHash string `json:"transactionHash"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignEvmHashResponse parses an HTTP response from a SignEvmHashWithResponse call
func ParseSignEvmHashResponse(rsp *http.Response) (*SignEvmHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the hash, as a 0x-prefixed hex string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignEvmMessageResponse parses an HTTP response from a SignEvmMessageWithResponse call
func ParseSignEvmMessageResponse(rsp *http.Response) (*SignEvmMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the message, as a 0x-prefixed hex string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignEvmTransactionResponse parses an HTTP response from a SignEvmTransactionWithResponse call
func ParseSignEvmTransactionResponse(rsp *http.Response) (*SignEvmTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// SignedTransaction The RLP-encoded signed transaction, as a 0x-prefixed hex string.
			SignedTransaction string `json:"signedTransaction"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignEvmTypedDataResponse parses an HTTP response from a SignEvmTypedDataWithResponse call
func ParseSignEvmTypedDataResponse(rsp *http.Response) (*SignEvmTypedDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmTypedDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the typed data, as a 0x-prefixed hex string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRequestEvmFaucetResponse parses an HTTP response from a RequestEvmFaucetWithResponse call
func ParseRequestEvmFaucetResponse(rsp *http.Response) (*RequestEvmFaucetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestEvmFaucetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TransactionHash The hash of the transaction that requested the funds.
			// **Note:** In rare cases, when gas conditions are unusually high, the transaction may not confirm, and the system may issue a replacement transaction to complete the faucet request. In these rare cases, the `transactionHash` will be out of sync with the actual faucet transaction that was confirmed onchain.
			TransactionHash string `json:"transactionHash"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListEvmSmartAccountsResponse parses an HTTP response from a ListEvmSmartAccountsWithResponse call
func ParseListEvmSmartAccountsResponse(rsp *http.Response) (*ListEvmSmartAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEvmSmartAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Accounts The list of Smart Accounts.
			Accounts []EvmSmartAccount `json:"accounts"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateEvmSmartAccountResponse parses an HTTP response from a CreateEvmSmartAccountWithResponse call
func ParseCreateEvmSmartAccountResponse(rsp *http.Response) (*CreateEvmSmartAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEvmSmartAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmSmartAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmSmartAccountByNameResponse parses an HTTP response from a GetEvmSmartAccountByNameWithResponse call
func ParseGetEvmSmartAccountByNameResponse(rsp *http.Response) (*GetEvmSmartAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmSmartAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmSmartAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmSmartAccountResponse parses an HTTP response from a GetEvmSmartAccountWithResponse call
func ParseGetEvmSmartAccountResponse(rsp *http.Response) (*GetEvmSmartAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmSmartAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmSmartAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateEvmSmartAccountResponse parses an HTTP response from a UpdateEvmSmartAccountWithResponse call
func ParseUpdateEvmSmartAccountResponse(rsp *http.Response) (*UpdateEvmSmartAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEvmSmartAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmSmartAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateSpendPermissionResponse parses an HTTP response from a CreateSpendPermissionWithResponse call
func ParseCreateSpendPermissionResponse(rsp *http.Response) (*CreateSpendPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpendPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListSpendPermissionsResponse parses an HTTP response from a ListSpendPermissionsWithResponse call
func ParseListSpendPermissionsResponse(rsp *http.Response) (*ListSpendPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpendPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`

			// SpendPermissions The spend permissions for the smart account.
			SpendPermissions []SpendPermissionResponseObject `json:"spendPermissions"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevokeSpendPermissionResponse parses an HTTP response from a RevokeSpendPermissionWithResponse call
func ParseRevokeSpendPermissionResponse(rsp *http.Response) (*RevokeSpendPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeSpendPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePrepareUserOperationResponse parses an HTTP response from a PrepareUserOperationWithResponse call
func ParsePrepareUserOperationResponse(rsp *http.Response) (*PrepareUserOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrepareUserOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePrepareAndSendUserOperationResponse parses an HTTP response from a PrepareAndSendUserOperationWithResponse call
func ParsePrepareAndSendUserOperationResponse(rsp *http.Response) (*PrepareAndSendUserOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrepareAndSendUserOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetUserOperationResponse parses an HTTP response from a GetUserOperationWithResponse call
func ParseGetUserOperationResponse(rsp *http.Response) (*GetUserOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSendUserOperationResponse parses an HTTP response from a SendUserOperationWithResponse call
func ParseSendUserOperationResponse(rsp *http.Response) (*SendUserOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendUserOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateEvmSwapQuoteResponse parses an HTTP response from a CreateEvmSwapQuoteWithResponse call
func ParseCreateEvmSwapQuoteResponse(rsp *http.Response) (*CreateEvmSwapQuoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEvmSwapQuoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSwapQuoteResponseWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmSwapPriceResponse parses an HTTP response from a GetEvmSwapPriceWithResponse call
func ParseGetEvmSwapPriceResponse(rsp *http.Response) (*GetEvmSwapPriceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmSwapPriceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSwapPriceResponseWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListEvmTokenBalancesResponse parses an HTTP response from a ListEvmTokenBalancesWithResponse call
func ParseListEvmTokenBalancesResponse(rsp *http.Response) (*ListEvmTokenBalancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEvmTokenBalancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Balances The list of EVM token balances.
			Balances []TokenBalance `json:"balances"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateOnrampOrderResponse parses an HTTP response from a CreateOnrampOrderWithResponse call
func ParseCreateOnrampOrderResponse(rsp *http.Response) (*CreateOnrampOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOnrampOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Order An Onramp order.
			Order OnrampOrder `json:"order"`

			// PaymentLink A payment link to pay for an order.
			//
			// Please refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/onramp-overview) for details on how to integrate with the different payment link types.
			PaymentLink *OnrampPaymentLink `json:"paymentLink,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOnrampOrderByIdResponse parses an HTTP response from a GetOnrampOrderByIdWithResponse call
func ParseGetOnrampOrderByIdResponse(rsp *http.Response) (*GetOnrampOrderByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOnrampOrderByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Order An Onramp order.
			Order OnrampOrder `json:"order"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCreateOnrampSessionResponse parses an HTTP response from a CreateOnrampSessionWithResponse call
func ParseCreateOnrampSessionResponse(rsp *http.Response) (*CreateOnrampSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOnrampSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Quote Quote information with pricing details for the crypto purchase.
			Quote *OnrampQuote `json:"quote,omitempty"`

			// Session An onramp session containing a ready-to-use onramp URL.
			Session OnrampSession `json:"session"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPoliciesResponse parses an HTTP response from a ListPoliciesWithResponse call
func ParseListPoliciesResponse(rsp *http.Response) (*ListPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`

			// Policies The list of policies.
			Policies []Policy `json:"policies"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreatePolicyResponse parses an HTTP response from a CreatePolicyWithResponse call
func ParseCreatePolicyResponse(rsp *http.Response) (*CreatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeletePolicyResponse parses an HTTP response from a DeletePolicyWithResponse call
func ParseDeletePolicyResponse(rsp *http.Response) (*DeletePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPolicyByIdResponse parses an HTTP response from a GetPolicyByIdWithResponse call
func ParseGetPolicyByIdResponse(rsp *http.Response) (*GetPolicyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdatePolicyResponse parses an HTTP response from a UpdatePolicyWithResponse call
func ParseUpdatePolicyResponse(rsp *http.Response) (*UpdatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListSolanaAccountsResponse parses an HTTP response from a ListSolanaAccountsWithResponse call
func ParseListSolanaAccountsResponse(rsp *http.Response) (*ListSolanaAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSolanaAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Accounts The list of Solana accounts.
			Accounts []SolanaAccount `json:"accounts"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateSolanaAccountResponse parses an HTTP response from a CreateSolanaAccountWithResponse call
func ParseCreateSolanaAccountResponse(rsp *http.Response) (*CreateSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetSolanaAccountByNameResponse parses an HTTP response from a GetSolanaAccountByNameWithResponse call
func ParseGetSolanaAccountByNameResponse(rsp *http.Response) (*GetSolanaAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSolanaAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExportSolanaAccountByNameResponse parses an HTTP response from a ExportSolanaAccountByNameWithResponse call
func ParseExportSolanaAccountByNameResponse(rsp *http.Response) (*ExportSolanaAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportSolanaAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EncryptedPrivateKey The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
			EncryptedPrivateKey string `json:"encryptedPrivateKey"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseImportSolanaAccountResponse parses an HTTP response from a ImportSolanaAccountWithResponse call
func ParseImportSolanaAccountResponse(rsp *http.Response) (*ImportSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSendSolanaTransactionResponse parses an HTTP response from a SendSolanaTransactionWithResponse call
func ParseSendSolanaTransactionResponse(rsp *http.Response) (*SendSolanaTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendSolanaTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TransactionSignature The base58 encoded transaction signature.
			TransactionSignature string `json:"transactionSignature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetSolanaAccountResponse parses an HTTP response from a GetSolanaAccountWithResponse call
func ParseGetSolanaAccountResponse(rsp *http.Response) (*GetSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateSolanaAccountResponse parses an HTTP response from a UpdateSolanaAccountWithResponse call
func ParseUpdateSolanaAccountResponse(rsp *http.Response) (*UpdateSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExportSolanaAccountResponse parses an HTTP response from a ExportSolanaAccountWithResponse call
func ParseExportSolanaAccountResponse(rsp *http.Response) (*ExportSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EncryptedPrivateKey The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
			EncryptedPrivateKey string `json:"encryptedPrivateKey"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignSolanaMessageResponse parses an HTTP response from a SignSolanaMessageWithResponse call
func ParseSignSolanaMessageResponse(rsp *http.Response) (*SignSolanaMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignSolanaMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the message, as a base58 encoded string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignSolanaTransactionResponse parses an HTTP response from a SignSolanaTransactionWithResponse call
func ParseSignSolanaTransactionResponse(rsp *http.Response) (*SignSolanaTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignSolanaTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// SignedTransaction The base64 encoded signed transaction.
			SignedTransaction string `json:"signedTransaction"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRequestSolanaFaucetResponse parses an HTTP response from a RequestSolanaFaucetWithResponse call
func ParseRequestSolanaFaucetResponse(rsp *http.Response) (*RequestSolanaFaucetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestSolanaFaucetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TransactionSignature The signature identifying the transaction that requested the funds.
			TransactionSignature string `json:"transactionSignature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListSolanaTokenBalancesResponse parses an HTTP response from a ListSolanaTokenBalancesWithResponse call
func ParseListSolanaTokenBalancesResponse(rsp *http.Response) (*ListSolanaTokenBalancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSolanaTokenBalancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Balances The list of Solana token balances.
			Balances []SolanaTokenBalance `json:"balances"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSettleX402PaymentResponse parses an HTTP response from a SettleX402PaymentWithResponse call
func ParseSettleX402PaymentResponse(rsp *http.Response) (*SettleX402PaymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SettleX402PaymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest X402SettleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest X402SettleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSupportedX402PaymentKindsResponse parses an HTTP response from a SupportedX402PaymentKindsWithResponse call
func ParseSupportedX402PaymentKindsResponse(rsp *http.Response) (*SupportedX402PaymentKindsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SupportedX402PaymentKindsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest X402SupportedPaymentKindsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseVerifyX402PaymentResponse parses an HTTP response from a VerifyX402PaymentWithResponse call
func ParseVerifyX402PaymentResponse(rsp *http.Response) (*VerifyX402PaymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyX402PaymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest X402VerifyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest X402VerifyInvalidError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
